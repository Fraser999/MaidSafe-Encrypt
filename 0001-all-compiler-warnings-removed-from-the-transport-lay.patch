From d29e9d3ea98d48c328352995b04479e2ab95c66e Mon Sep 17 00:00:00 2001
From: dirvine <dirvine@6165b5c9-d236-0410-b717-85aa93a55b26>
Date: Sun, 22 Mar 2009 00:38:03 +0000
Subject: [PATCH] all compiler warnings removed from the transport layer

git-svn-id: svn+ssh://www.maidsafe.net/srv/svn/dawn/trunk@3182 6165b5c9-d236-0410-b717-85aa93a55b26
---
 src/transport/api.cpp         | 3704 +++++++++++++++++++++--------------------
 src/transport/buffer.cpp      |   12 +-
 src/transport/ccc.cpp         |   12 +-
 src/transport/ccc.h           |    4 +
 src/transport/channel.cpp     |  672 ++++----
 src/transport/common.cpp      |    8 +-
 src/transport/core.cpp        |  234 ++--
 src/transport/packet.cpp      |   13 +-
 src/transport/queue.cpp       | 2282 +++++++++++++-------------
 src/transport/queue.h         |    1 +
 src/transport/transportapi.cc |    2 +-
 src/transport/window.cpp      |   14 +-
 12 files changed, 3492 insertions(+), 3466 deletions(-)

diff --git a/src/transport/api.cpp b/src/transport/api.cpp
index d51bec8..2f31185 100644
--- a/src/transport/api.cpp
+++ b/src/transport/api.cpp
@@ -1,1846 +1,1858 @@
-/*****************************************************************************
-Copyright (c) 2001 - 2009, The Board of Trustees of the University of Illinois.
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-
-* Redistributions of source code must retain the above
-  copyright notice, this list of conditions and the
-  following disclaimer.
-
-* Redistributions in binary form must reproduce the
-  above copyright notice, this list of conditions
-  and the following disclaimer in the documentation
-  and/or other materials provided with the distribution.
-
-* Neither the name of the University of Illinois
-  nor the names of its contributors may be used to
-  endorse or promote products derived from this
-  software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
-THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
-CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
-EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
-PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*****************************************************************************/
-
-/*****************************************************************************
-written by
-   Yunhong Gu, last updated 01/22/2009
-*****************************************************************************/
-
-#ifdef WIN32
-   #include <winsock2.h>
-   #include <ws2tcpip.h>
-#ifdef __MSVC__
-   #include <wspiapi.h>
-#endif // __MSVC__
-#else
-   #include <unistd.h>
-#endif
-#include <cstring>
-#include "api.h"
-#include "core.h"
-
-using namespace std;
-
-CUDTSocket::CUDTSocket():
-m_pSelfAddr(NULL),
-m_pPeerAddr(NULL),
-m_pUDT(NULL),
-m_pQueuedSockets(NULL),
-m_pAcceptSockets(NULL)
-{
-   #ifndef WIN32
-      pthread_mutex_init(&m_AcceptLock, NULL);
-      pthread_cond_init(&m_AcceptCond, NULL);
-   #else
-      m_AcceptLock = CreateMutex(NULL, false, NULL);
-      m_AcceptCond = CreateEvent(NULL, false, false, NULL);
-   #endif
-}
-
-CUDTSocket::~CUDTSocket()
-{
-   if (AF_INET == m_iIPversion)
-   {
-      delete (sockaddr_in*)m_pSelfAddr;
-      delete (sockaddr_in*)m_pPeerAddr;
-   }
-   else
-   {
-      delete (sockaddr_in6*)m_pSelfAddr;
-      delete (sockaddr_in6*)m_pPeerAddr;
-   }
-
-   delete m_pUDT;
-
-   delete m_pQueuedSockets;
-   delete m_pAcceptSockets;
-
-   #ifndef WIN32
-      pthread_mutex_destroy(&m_AcceptLock);
-      pthread_cond_destroy(&m_AcceptCond);
-   #else
-      CloseHandle(m_AcceptLock);
-      CloseHandle(m_AcceptCond);
-   #endif
-}
-
-////////////////////////////////////////////////////////////////////////////////
-
-CUDTUnited::CUDTUnited()
-{
-   srand((unsigned int)CTimer::getTime());
-   m_SocketID = 1 + (int)((1 << 30) * (double(rand()) / RAND_MAX));
-
-   #ifndef WIN32
-      pthread_mutex_init(&m_ControlLock, NULL);
-      pthread_mutex_init(&m_IDLock, NULL);
-      pthread_mutex_init(&m_InitLock, NULL);
-   #else
-      m_ControlLock = CreateMutex(NULL, false, NULL);
-      m_IDLock = CreateMutex(NULL, false, NULL);
-      m_InitLock = CreateMutex(NULL, false, NULL);
-   #endif
-
-   #ifndef WIN32
-      pthread_key_create(&m_TLSError, TLSDestroy);
-   #else
-      m_TLSError = TlsAlloc();
-      m_TLSLock = CreateMutex(NULL, false, NULL);
-   #endif
-
-   // Global initialization code
-   #ifdef WIN32
-      WORD wVersionRequested;
-      WSADATA wsaData;
-      wVersionRequested = MAKEWORD(2, 2);
-
-      if (0 != WSAStartup(wVersionRequested, &wsaData))
-         throw CUDTException(1, 0,  WSAGetLastError());
-   #endif
-
-   m_vMultiplexer.clear();
-   m_pController = new CControl;
-
-   m_bGCStatus = false;
-}
-
-CUDTUnited::~CUDTUnited()
-{
-   #ifndef WIN32
-      pthread_mutex_destroy(&m_ControlLock);
-      pthread_mutex_destroy(&m_IDLock);
-      pthread_mutex_destroy(&m_InitLock);
-   #else
-      CloseHandle(m_ControlLock);
-      CloseHandle(m_IDLock);
-      CloseHandle(m_InitLock);
-   #endif
-
-   #ifndef WIN32
-      pthread_key_delete(m_TLSError);
-   #else
-      TlsFree(m_TLSError);
-      CloseHandle(m_TLSLock);
-   #endif
-
-   m_vMultiplexer.clear();
-   delete m_pController;
-
-   // Global destruction code
-   #ifdef WIN32
-      WSACleanup();
-   #endif
-}
-
-int CUDTUnited::startup()
-{
-   CGuard gcinit(m_InitLock);
-
-   if (m_bGCStatus)
-      return true;
-
-   m_bClosing = false;
-   #ifndef WIN32
-      pthread_mutex_init(&m_GCStopLock, NULL);
-      pthread_cond_init(&m_GCStopCond, NULL);
-      pthread_create(&m_GCThread, NULL, garbageCollect, this);
-   #else
-      m_GCStopLock = CreateMutex(NULL, false, NULL);
-      m_GCStopCond = CreateEvent(NULL, false, false, NULL);
-      DWORD ThreadID;
-      m_GCThread = CreateThread(NULL, 0, garbageCollect, this, NULL, &ThreadID);
-   #endif
-
-   m_bGCStatus = true;
-
-   return 0;
-}
-
-int CUDTUnited::cleanup()
-{
-   CGuard gcinit(m_InitLock);
-
-   if (!m_bGCStatus)
-      return 0;
-
-   m_bClosing = true;
-   #ifndef WIN32
-      pthread_cond_signal(&m_GCStopCond);
-      pthread_join(m_GCThread, NULL);
-      pthread_mutex_destroy(&m_GCStopLock);
-      pthread_cond_destroy(&m_GCStopCond);
-   #else
-      SetEvent(m_GCStopCond);
-      WaitForSingleObject(m_GCThread, INFINITE);
-      CloseHandle(m_GCThread);
-      CloseHandle(m_GCStopLock);
-      CloseHandle(m_GCStopCond);
-   #endif
-
-   m_bGCStatus = false;
-
-   return 0;
-}
-
-UDTSOCKET CUDTUnited::newSocket(const int& af, const int& type)
-{
-   if ((type != SOCK_STREAM) && (type != SOCK_DGRAM))
-      throw CUDTException(5, 3, 0);
-
-   CUDTSocket* ns = NULL;
-
-   try
-   {
-      ns = new CUDTSocket;
-      ns->m_pUDT = new CUDT;
-      if (AF_INET == af)
-      {
-         ns->m_pSelfAddr = (sockaddr*)(new sockaddr_in);
-         ((sockaddr_in*)(ns->m_pSelfAddr))->sin_port = 0;
-      }
-      else
-      {
-         ns->m_pSelfAddr = (sockaddr*)(new sockaddr_in6);
-         ((sockaddr_in6*)(ns->m_pSelfAddr))->sin6_port = 0;
-      }
-   }
-   catch (...)
-   {
-      delete ns;
-      throw CUDTException(3, 2, 0);
-   }
-
-   CGuard::enterCS(m_IDLock);
-   ns->m_SocketID = -- m_SocketID;
-   CGuard::leaveCS(m_IDLock);
-
-   ns->m_Status = CUDTSocket::INIT;
-   ns->m_ListenSocket = 0;
-   ns->m_pUDT->m_SocketID = ns->m_SocketID;
-   ns->m_pUDT->m_iSockType = (SOCK_STREAM == type) ? UDT_STREAM : UDT_DGRAM;
-   ns->m_pUDT->m_iIPversion = ns->m_iIPversion = af;
-   ns->m_pUDT->m_pController = m_pController;
-
-   // protect the m_Sockets structure.
-   CGuard::enterCS(m_ControlLock);
-   try
-   {
-      m_Sockets[ns->m_SocketID] = ns;
-   }
-   catch (...)
-   {
-      //failure and rollback
-      delete ns;
-      ns = NULL;
-   }
-   CGuard::leaveCS(m_ControlLock);
-
-   if (NULL == ns)
-      throw CUDTException(3, 2, 0);
-
-   return ns->m_SocketID;
-}
-
-int CUDTUnited::newConnection(const UDTSOCKET listen, const sockaddr* peer, CHandShake* hs)
-{
-   CUDTSocket* ns = NULL;
-   CUDTSocket* ls = locate(listen);
-
-   // if this connection has already been processed
-   if (NULL != (ns = locate(listen, peer, hs->m_iID, hs->m_iISN)))
-   {
-      if (ns->m_pUDT->m_bBroken)
-      {
-         // last connection from the "peer" address has been broken
-         ns->m_Status = CUDTSocket::CLOSED;
-         ns->m_TimeStamp = CTimer::getTime();
-
-         CGuard::enterCS(ls->m_AcceptLock);
-         ls->m_pQueuedSockets->erase(ns->m_SocketID);
-         ls->m_pAcceptSockets->erase(ns->m_SocketID);
-         CGuard::leaveCS(ls->m_AcceptLock);
-      }
-      else
-      {
-         // connection already exist, this is a repeated connection request
-         // respond with existing HS information
-
-         hs->m_iISN = ns->m_pUDT->m_iISN;
-         hs->m_iMSS = ns->m_pUDT->m_iMSS;
-         hs->m_iFlightFlagSize = ns->m_pUDT->m_iFlightFlagSize;
-         hs->m_iReqType = -1;
-         hs->m_iID = ns->m_SocketID;
-
-         return 0;
-
-         //except for this situation a new connection should be started
-      }
-   }
-
-   // checking if ls = NULL (failed to located listen socket)
-   if (ls == NULL)
-     return -1;
-   // exceeding backlog, refuse the connection request
-   if (ls->m_pQueuedSockets->size() >= ls->m_uiBackLog)
-      return -1;
-
-   try
-   {
-      ns = new CUDTSocket;
-      ns->m_pUDT = new CUDT(*(ls->m_pUDT));
-      if (AF_INET == ls->m_iIPversion)
-      {
-         ns->m_pSelfAddr = (sockaddr*)(new sockaddr_in);
-         ((sockaddr_in*)(ns->m_pSelfAddr))->sin_port = 0;
-         ns->m_pPeerAddr = (sockaddr*)(new sockaddr_in);
-         memcpy(ns->m_pPeerAddr, peer, sizeof(sockaddr_in));
-      }
-      else
-      {
-         ns->m_pSelfAddr = (sockaddr*)(new sockaddr_in6);
-         ((sockaddr_in6*)(ns->m_pSelfAddr))->sin6_port = 0;
-         ns->m_pPeerAddr = (sockaddr*)(new sockaddr_in6);
-         memcpy(ns->m_pPeerAddr, peer, sizeof(sockaddr_in6));
-      }
-   }
-   catch (...)
-   {
-      delete ns;
-      return -1;
-   }
-
-   CGuard::enterCS(m_IDLock);
-   ns->m_SocketID = -- m_SocketID;
-   CGuard::leaveCS(m_IDLock);
-
-   ns->m_ListenSocket = listen;
-   ns->m_iIPversion = ls->m_iIPversion;
-   ns->m_pUDT->m_SocketID = ns->m_SocketID;
-   ns->m_PeerID = hs->m_iID;
-   ns->m_iISN = hs->m_iISN;
-
-   int error = 0;
-
-   try
-   {
-      // bind to the same addr of listening socket
-      ns->m_pUDT->open();
-      updateMux(ns->m_pUDT, ls);
-      ns->m_pUDT->connect(peer, hs);
-   }
-   catch (...)
-   {
-      error = 1;
-      goto ERR_ROLLBACK;
-   }
-
-   ns->m_Status = CUDTSocket::CONNECTED;
-
-   // copy address information of local node
-   ns->m_pUDT->m_pSndQueue->m_pChannel->getSockAddr(ns->m_pSelfAddr);
-
-   // protect the m_Sockets structure.
-   CGuard::enterCS(m_ControlLock);
-   try
-   {
-      m_Sockets[ns->m_SocketID] = ns;
-   }
-   catch (...)
-   {
-      error = 2;
-   }
-   CGuard::leaveCS(m_ControlLock);
-
-   CGuard::enterCS(ls->m_AcceptLock);
-   try
-   {
-      ls->m_pQueuedSockets->insert(ns->m_SocketID);
-   }
-   catch (...)
-   {
-      error = 3;
-   }
-   CGuard::leaveCS(ls->m_AcceptLock);
-
-   CTimer::triggerEvent();
-
-   ERR_ROLLBACK:
-   if (error > 0)
-   {
-      ns->m_pUDT->close();
-      ns->m_Status = CUDTSocket::CLOSED;
-      ns->m_TimeStamp = CTimer::getTime();
-
-      return -1;
-   }
-
-   // wake up a waiting accept() call
-   #ifndef WIN32
-      pthread_cond_signal(&(ls->m_AcceptCond));
-   #else
-      SetEvent(ls->m_AcceptCond);
-   #endif
-
-   return 1;
-}
-
-CUDT* CUDTUnited::lookup(const UDTSOCKET u)
-{
-   // protects the m_Sockets structure
-   CGuard cg(m_ControlLock);
-
-   map<UDTSOCKET, CUDTSocket*>::iterator i = m_Sockets.find(u);
-
-   if ((i == m_Sockets.end()) || (i->second->m_Status == CUDTSocket::CLOSED))
-      throw CUDTException(5, 4, 0);
-
-   return i->second->m_pUDT;
-}
-
-CUDTSocket::UDTSTATUS CUDTUnited::getStatus(const UDTSOCKET u)
-{
-   // protects the m_Sockets structure
-   CGuard cg(m_ControlLock);
-
-   map<UDTSOCKET, CUDTSocket*>::iterator i = m_Sockets.find(u);
-
-   if (i == m_Sockets.end())
-      return CUDTSocket::INIT;
-
-   if (i->second->m_pUDT->m_bBroken)
-      return CUDTSocket::BROKEN;
-
-   return i->second->m_Status;
-}
-
-int CUDTUnited::bind(const UDTSOCKET u, const sockaddr* name, const int& namelen)
-{
-   CUDTSocket* s = locate(u);
-
-   if (NULL == s)
-      throw CUDTException(5, 4, 0);
-
-   // cannot bind a socket more than once
-   if (CUDTSocket::INIT != s->m_Status)
-      throw CUDTException(5, 0, 0);
-
-   // check the size of SOCKADDR structure
-   if (AF_INET == s->m_iIPversion)
-   {
-      if (namelen != sizeof(sockaddr_in))
-         throw CUDTException(5, 3, 0);
-   }
-   else
-   {
-      if (namelen != sizeof(sockaddr_in6))
-         throw CUDTException(5, 3, 0);
-   }
-
-   s->m_pUDT->open();
-   updateMux(s->m_pUDT, name);
-   s->m_Status = CUDTSocket::OPENED;
-
-   // copy address information of local node
-   s->m_pUDT->m_pSndQueue->m_pChannel->getSockAddr(s->m_pSelfAddr);
-
-   return 0;
-}
-
-int CUDTUnited::bind(UDTSOCKET u, UDPSOCKET udpsock)
-{
-   CUDTSocket* s = locate(u);
-
-   if (NULL == s)
-      throw CUDTException(5, 4, 0);
-
-   // cannot bind a socket more than once
-   if (CUDTSocket::INIT != s->m_Status)
-      throw CUDTException(5, 0, 0);
-
-   sockaddr_in name4;
-   sockaddr_in6 name6;
-   sockaddr* name;
-   socklen_t namelen;
-
-   if (AF_INET == s->m_iIPversion)
-   {
-      namelen = sizeof(sockaddr_in);
-      name = (sockaddr*)&name4;
-   }
-   else
-   {
-      namelen = sizeof(sockaddr_in6);
-      name = (sockaddr*)&name6;
-   }
-
-   if (-1 == ::getsockname(udpsock, name, &namelen))
-      throw CUDTException(5, 3);
-
-   s->m_pUDT->open();
-   updateMux(s->m_pUDT, name, &udpsock);
-   s->m_Status = CUDTSocket::OPENED;
-
-   // copy address information of local node
-   s->m_pUDT->m_pSndQueue->m_pChannel->getSockAddr(s->m_pSelfAddr);
-
-   return 0;
-}
-
-int CUDTUnited::listen(const UDTSOCKET u, const int& backlog)
-{
-   CUDTSocket* s = locate(u);
-
-   if (NULL == s)
-      throw CUDTException(5, 4, 0);
-
-   // do nothing if the socket is already listening
-   if (CUDTSocket::LISTENING == s->m_Status)
-      return 0;
-
-   // a socket can listen only if is in OPENED status
-   if (CUDTSocket::OPENED != s->m_Status)
-      throw CUDTException(5, 5, 0);
-
-   // listen is not supported in rendezvous connection setup
-   if (s->m_pUDT->m_bRendezvous)
-      throw CUDTException(5, 7, 0);
-
-   if (backlog <= 0)
-      throw CUDTException(5, 3, 0);
-
-   s->m_uiBackLog = backlog;
-
-   try
-   {
-      s->m_pQueuedSockets = new set<UDTSOCKET>;
-      s->m_pAcceptSockets = new set<UDTSOCKET>;
-   }
-   catch (...)
-   {
-      delete s->m_pQueuedSockets;
-      throw CUDTException(3, 2, 0);
-   }
-
-   s->m_pUDT->listen();
-
-   s->m_Status = CUDTSocket::LISTENING;
-
-   return 0;
-}
-
-UDTSOCKET CUDTUnited::accept(const UDTSOCKET listen, sockaddr* addr, int* addrlen)
-{
-   if ((NULL != addr) && (NULL == addrlen))
-      throw CUDTException(5, 3, 0);
-
-   CUDTSocket* ls = locate(listen);
-
-   if (ls == NULL)
-      throw CUDTException(5, 4, 0);
-
-   // the "listen" socket must be in LISTENING status
-   if (CUDTSocket::LISTENING != ls->m_Status)
-      throw CUDTException(5, 6, 0);
-
-   // no "accept" in rendezvous connection setup
-   if (ls->m_pUDT->m_bRendezvous)
-      throw CUDTException(5, 7, 0);
-
-   UDTSOCKET u = CUDT::INVALID_SOCK;
-   bool accepted = false;
-
-   // !!only one conection can be set up each time!!
-   #ifndef WIN32
-      while (!accepted)
-      {
-         pthread_mutex_lock(&(ls->m_AcceptLock));
-
-         if (ls->m_pQueuedSockets->size() > 0)
-         {
-            u = *(ls->m_pQueuedSockets->begin());
-            ls->m_pAcceptSockets->insert(ls->m_pAcceptSockets->end(), u);
-            ls->m_pQueuedSockets->erase(ls->m_pQueuedSockets->begin());
-
-            accepted = true;
-         }
-         else if (!ls->m_pUDT->m_bSynRecving)
-            accepted = true;
-         else if (CUDTSocket::LISTENING == ls->m_Status)
-            pthread_cond_wait(&(ls->m_AcceptCond), &(ls->m_AcceptLock));
-
-         if (CUDTSocket::LISTENING != ls->m_Status)
-            accepted = true;
-
-         pthread_mutex_unlock(&(ls->m_AcceptLock));
-      }
-   #else
-      while (!accepted)
-      {
-         WaitForSingleObject(ls->m_AcceptLock, INFINITE);
-
-         if (ls->m_pQueuedSockets->size() > 0)
-         {
-            u = *(ls->m_pQueuedSockets->begin());
-            ls->m_pAcceptSockets->insert(ls->m_pAcceptSockets->end(), u);
-            ls->m_pQueuedSockets->erase(ls->m_pQueuedSockets->begin());
-
-            accepted = true;
-         }
-         else if (!ls->m_pUDT->m_bSynRecving)
-            accepted = true;
-
-         ReleaseMutex(ls->m_AcceptLock);
-
-         if  (!accepted & (CUDTSocket::LISTENING == ls->m_Status))
-            WaitForSingleObject(ls->m_AcceptCond, INFINITE);
-
-         if (CUDTSocket::LISTENING != ls->m_Status)
-         {
-            SetEvent(ls->m_AcceptCond);
-            accepted = true;
-         }
-      }
-   #endif
-
-   if (u == CUDT::INVALID_SOCK)
-   {
-      // non-blocking receiving, no connection available
-      if (!ls->m_pUDT->m_bSynRecving)
-         throw CUDTException(6, 2, 0);
-
-      // listening socket is closed
-      throw CUDTException(5, 6, 0);
-   }
-
-   if (AF_INET == locate(u)->m_iIPversion)
-      *addrlen = sizeof(sockaddr_in);
-   else
-      *addrlen = sizeof(sockaddr_in6);
-
-   // copy address information of peer node
-   memcpy(addr, locate(u)->m_pPeerAddr, *addrlen);
-
-   return u;
-}
-
-int CUDTUnited::connect(const UDTSOCKET u, const sockaddr* name, const int& namelen)
-{
-   CUDTSocket* s = locate(u);
-   if (NULL == s) 
-      throw CUDTException(5, 4, 0);
-
-   // check the size of SOCKADDR structure
-   if (AF_INET == s->m_iIPversion)
-   {
-      if (namelen != sizeof(sockaddr_in)) 
-         throw CUDTException(5, 3, 0);
-   }
-   else
-   {
-      if (namelen != sizeof(sockaddr_in6))
-         throw CUDTException(5, 3, 0);
-   }
-
-   // a socket can "connect" only if it is in INIT or OPENED status
-   if (CUDTSocket::INIT == s->m_Status)
-   {
-      if (!s->m_pUDT->m_bRendezvous)
-      {
-         s->m_pUDT->open();
-         updateMux(s->m_pUDT);
-         s->m_Status = CUDTSocket::OPENED;
-      }
-      else 
-         throw CUDTException(5, 8, 0);
-   }
-   else if (CUDTSocket::OPENED != s->m_Status)
-      throw CUDTException(5, 2, 0);
-
-   s->m_pUDT->connect(name);
-   s->m_Status = CUDTSocket::CONNECTED;
-
-   // copy address information of local node
-   s->m_pUDT->m_pSndQueue->m_pChannel->getSockAddr(s->m_pSelfAddr);
-
-   // record peer address
-   if (AF_INET == s->m_iIPversion)
-   {
-      s->m_pPeerAddr = (sockaddr*)(new sockaddr_in);
-      memcpy(s->m_pPeerAddr, name, sizeof(sockaddr_in));
-   }
-   else
-   {
-      s->m_pPeerAddr = (sockaddr*)(new sockaddr_in6);
-      memcpy(s->m_pPeerAddr, name, sizeof(sockaddr_in6));
-   }
-
-   return 0;
-}
-
-int CUDTUnited::close(const UDTSOCKET u)
-{
-   CUDTSocket* s = locate(u);
-
-   // silently drop a request to close an invalid ID, rather than return error
-   if (NULL == s)
-      return 0;
-
-   s->m_pUDT->close();
-
-   // a socket will not be immediated removed when it is closed
-   // in order to prevent other methods from accessing invalid address
-   // a timer is started and the socket will be removed after approximately 1 second
-   s->m_TimeStamp = CTimer::getTime();
-
-   CUDTSocket::UDTSTATUS os = s->m_Status;
-
-   // synchronize with garbage collection.
-   CGuard::enterCS(m_ControlLock);
-
-   s->m_Status = CUDTSocket::CLOSED;
-
-   m_Sockets.erase(s->m_SocketID);
-   m_ClosedSockets[s->m_SocketID] = s;
-
-   if (0 != s->m_ListenSocket)
-   {
-      // if it is an accepted socket, remove it from the listener's queue
-      map<UDTSOCKET, CUDTSocket*>::iterator ls = m_Sockets.find(s->m_ListenSocket);
-      if (ls != m_Sockets.end())
-      {
-         CGuard::enterCS(ls->second->m_AcceptLock);
-         ls->second->m_pAcceptSockets->erase(s->m_SocketID);
-         CGuard::leaveCS(ls->second->m_AcceptLock);
-      }
-   }
-
-   CGuard::leaveCS(m_ControlLock);
-
-   // broadcast all "accept" waiting
-   if (CUDTSocket::LISTENING == os)
-   {
-      #ifndef WIN32
-         pthread_mutex_lock(&(s->m_AcceptLock));
-         pthread_mutex_unlock(&(s->m_AcceptLock));
-         pthread_cond_broadcast(&(s->m_AcceptCond));
-      #else
-         SetEvent(s->m_AcceptCond);
-      #endif
-   }
-
-   CTimer::triggerEvent();
-
-   return 0;
-}
-
-int CUDTUnited::getpeername(const UDTSOCKET u, sockaddr* name, int* namelen)
-{
-   if (CUDTSocket::CONNECTED != getStatus(u))
-      throw CUDTException(2, 2, 0);
-
-   CUDTSocket* s = locate(u);
-
-   if (NULL == s)
-      throw CUDTException(5, 4, 0);
-
-   if (!s->m_pUDT->m_bConnected || s->m_pUDT->m_bBroken)
-      throw CUDTException(2, 2, 0);
-
-   if (AF_INET == s->m_iIPversion)
-      *namelen = sizeof(sockaddr_in);
-   else
-      *namelen = sizeof(sockaddr_in6);
-
-   // copy address information of peer node
-   memcpy(name, s->m_pPeerAddr, *namelen);
-
-   return 0;
-}
-
-int CUDTUnited::getsockname(const UDTSOCKET u, sockaddr* name, int* namelen)
-{
-   CUDTSocket* s = locate(u);
-
-   if (NULL == s)
-      throw CUDTException(5, 4, 0);
-
-   if (CUDTSocket::INIT == s->m_Status)
-      throw CUDTException(2, 2, 0);
-
-   if (AF_INET == s->m_iIPversion)
-      *namelen = sizeof(sockaddr_in);
-   else
-      *namelen = sizeof(sockaddr_in6);
-
-   // copy address information of local node
-   memcpy(name, s->m_pSelfAddr, *namelen);
-
-   return 0;
-}
-
-int CUDTUnited::select(ud_set* readfds, ud_set* writefds, ud_set* exceptfds, const timeval* timeout)
-{
-   uint64_t entertime = CTimer::getTime();
-
-   uint64_t to;
-   if (NULL == timeout)
-      to = 0xFFFFFFFFFFFFFFFFULL;
-   else
-      to = timeout->tv_sec * 1000000 + timeout->tv_usec;
-
-   // initialize results
-   int count = 0;
-   set<UDTSOCKET> rs, ws, es;
-
-   // retrieve related UDT sockets
-   vector<CUDTSocket*> ru, wu, eu;
-   CUDTSocket* s;
-   if (NULL != readfds)
-      for (set<UDTSOCKET>::iterator i1 = readfds->begin(); i1 != readfds->end(); ++ i1)
-      {
-         if (CUDTSocket::BROKEN == getStatus(*i1))
-         {
-            rs.insert(*i1);
-            ++ count;
-         }
-         else if (NULL == (s = locate(*i1)))
-            throw CUDTException(5, 4, 0);
-         else
-            ru.insert(ru.end(), s);
-      }
-   if (NULL != writefds)
-      for (set<UDTSOCKET>::iterator i2 = writefds->begin(); i2 != writefds->end(); ++ i2)
-      {
-         if (CUDTSocket::BROKEN == getStatus(*i2))
-         {
-            ws.insert(*i2);
-            ++ count;
-         }
-         else if (NULL == (s = locate(*i2)))
-            throw CUDTException(5, 4, 0);
-         else
-            wu.insert(wu.end(), s);
-      }
-   if (NULL != exceptfds)
-      for (set<UDTSOCKET>::iterator i3 = exceptfds->begin(); i3 != exceptfds->end(); ++ i3)
-      {
-         if (CUDTSocket::BROKEN == getStatus(*i3))
-         {
-            es.insert(*i3);
-            ++ count;
-         }
-         else if (NULL == (s = locate(*i3)))
-            throw CUDTException(5, 4, 0);
-         else
-            eu.insert(eu.end(), s);
-      }
-
-   do
-   {
-      // query read sockets
-      for (vector<CUDTSocket*>::iterator j1 = ru.begin(); j1 != ru.end(); ++ j1)
-      {
-         s = *j1;
-
-         if ((s->m_pUDT->m_bConnected && (s->m_pUDT->m_pRcvBuffer->getRcvDataSize() > 0) && ((s->m_pUDT->m_iSockType == UDT_STREAM) || (s->m_pUDT->m_pRcvBuffer->getRcvMsgNum() > 0)))
-            || (!s->m_pUDT->m_bListening && (s->m_pUDT->m_bBroken || !s->m_pUDT->m_bConnected))
-            || (s->m_pUDT->m_bListening && (s->m_pQueuedSockets->size() > 0))
-            || (s->m_Status == CUDTSocket::CLOSED))
-         {
-            rs.insert(s->m_SocketID);
-            ++ count;
-         }
-      }
-
-      // query write sockets
-      for (vector<CUDTSocket*>::iterator j2 = wu.begin(); j2 != wu.end(); ++ j2)
-      {
-         s = *j2;
-
-         if ((s->m_pUDT->m_bConnected && (s->m_pUDT->m_pSndBuffer->getCurrBufSize() < s->m_pUDT->m_iSndBufSize))
-            || s->m_pUDT->m_bBroken || !s->m_pUDT->m_bConnected || (s->m_Status == CUDTSocket::CLOSED))
-         {
-            ws.insert(s->m_SocketID);
-            ++ count;
-         }
-      }
-
-      // query exceptions on sockets
-      for (vector<CUDTSocket*>::iterator j3 = eu.begin(); j3 != eu.end(); ++ j3)
-      {
-         // check connection request status, not supported now
-      }
-
-      if (0 < count)
-         break;
-
-      CTimer::waitForEvent();
-   } while (to > CTimer::getTime() - entertime);
-
-   if (NULL != readfds)
-      *readfds = rs;
-
-   if (NULL != writefds)
-      *writefds = ws;
-
-   if (NULL != exceptfds)
-      *exceptfds = es;
-
-   return count;
-}
-
-CUDTSocket* CUDTUnited::locate(const UDTSOCKET u)
-{
-   CGuard cg(m_ControlLock);
-
-   map<UDTSOCKET, CUDTSocket*>::iterator i = m_Sockets.find(u);
-
-   if ( (i == m_Sockets.end()) || (i->second->m_Status == CUDTSocket::CLOSED)) {
-      if (i == m_Sockets.end()) {
-        printf("socket not found\n");
-      } else {
-        printf("socket status = CUDTSocket::CLOSED\n");
-      }
-      return NULL;
-   }
-
-   return i->second;
-}
-
-CUDTSocket* CUDTUnited::locate(const UDTSOCKET u, const sockaddr* peer, const UDTSOCKET& id, const int32_t& isn)
-{
-   CGuard cg(m_ControlLock);
-
-   map<UDTSOCKET, CUDTSocket*>::iterator i = m_Sockets.find(u);
-
-   CGuard ag(i->second->m_AcceptLock);
-
-   // look up the "peer" address in queued sockets set
-   for (set<UDTSOCKET>::iterator j1 = i->second->m_pQueuedSockets->begin(); j1 != i->second->m_pQueuedSockets->end(); ++ j1)
-   {
-      map<UDTSOCKET, CUDTSocket*>::iterator k1 = m_Sockets.find(*j1);
-      // this socket might have been closed and moved m_ClosedSockets
-      if (k1 == m_Sockets.end())
-         continue;
-
-      if (CIPAddress::ipcmp(peer, k1->second->m_pPeerAddr, i->second->m_iIPversion))
-      {
-         if ((id == k1->second->m_PeerID) && (isn == k1->second->m_iISN))
-            return k1->second;
-      }
-   }
-
-   // look up the "peer" address in accept sockets set
-   for (set<UDTSOCKET>::iterator j2 = i->second->m_pAcceptSockets->begin(); j2 != i->second->m_pAcceptSockets->end(); ++ j2)
-   {
-      map<UDTSOCKET, CUDTSocket*>::iterator k2 = m_Sockets.find(*j2);
-      // this socket might have been closed and moved m_ClosedSockets
-      if (k2 == m_Sockets.end())
-         continue;
-
-      if (CIPAddress::ipcmp(peer, k2->second->m_pPeerAddr, i->second->m_iIPversion))
-      {
-         if ((id == k2->second->m_PeerID) && (isn == k2->second->m_iISN))
-            return k2->second;
-      }
-   }
-
-   return NULL;
-}
-
-void CUDTUnited::checkBrokenSockets()
-{
-   CGuard cg(m_ControlLock);
-
-   // set of sockets To Be Closed and To Be Removed
-   set<UDTSOCKET> tbc;
-   set<UDTSOCKET> tbr;
-
-   for (map<UDTSOCKET, CUDTSocket*>::iterator i = m_Sockets.begin(); i != m_Sockets.end(); ++ i)
-   {
-      // check broken connection
-      if (i->second->m_pUDT->m_bBroken)
-      {
-         // if there is still data in the receiver buffer, wait longer
-         if ((i->second->m_pUDT->m_pRcvBuffer->getRcvDataSize() > 0) && (i->second->m_pUDT->m_iBrokenCounter -- > 0))
-            continue;
-
-         //close broken connections and start removal timer
-         i->second->m_Status = CUDTSocket::CLOSED;
-         i->second->m_TimeStamp = CTimer::getTime();
-         tbc.insert(i->first);
-         m_ClosedSockets[i->first] = i->second;
-
-         // remove from listener's queue
-         map<UDTSOCKET, CUDTSocket*>::iterator ls = m_Sockets.find(i->second->m_ListenSocket);
-         if (ls != m_Sockets.end())
-         {
-            CGuard::enterCS(ls->second->m_AcceptLock);
-            ls->second->m_pQueuedSockets->erase(i->second->m_SocketID);
-            ls->second->m_pAcceptSockets->erase(i->second->m_SocketID);
-            CGuard::leaveCS(ls->second->m_AcceptLock);
-         }
-      }
-   }
-
-   for (map<UDTSOCKET, CUDTSocket*>::iterator j = m_ClosedSockets.begin(); j != m_ClosedSockets.end(); ++ j)
-   {
-      // timeout 1 second to destroy a socket AND it has been removed from RcvUList
-      if ((CTimer::getTime() - j->second->m_TimeStamp > 1000000) && ((NULL == j->second->m_pUDT->m_pRNode) || !j->second->m_pUDT->m_pRNode->m_bOnList))
-         tbr.insert(j->first);
-
-      // sockets cannot be removed here because it will invalidate the map iterator
-   }
-
-   // move closed sockets to the ClosedSockets structure
-   for (set<UDTSOCKET>::iterator k = tbc.begin(); k != tbc.end(); ++ k)
-      m_Sockets.erase(*k);
-
-   // remove those timeout sockets
-   for (set<UDTSOCKET>::iterator l = tbr.begin(); l != tbr.end(); ++ l)
-      removeSocket(*l);
-}
-
-void CUDTUnited::removeSocket(const UDTSOCKET u)
-{
-   map<UDTSOCKET, CUDTSocket*>::iterator i = m_ClosedSockets.find(u);
-
-   // invalid socket ID
-   if (i == m_ClosedSockets.end())
-      return;
-
-   // decrease multiplexer reference count, and remove it if necessary
-   int port;
-   if (AF_INET == i->second->m_iIPversion)
-      port = ntohs(((sockaddr_in*)(i->second->m_pSelfAddr))->sin_port);
-   else
-      port = ntohs(((sockaddr_in6*)(i->second->m_pSelfAddr))->sin6_port);
-
-   vector<CMultiplexer>::iterator m;
-   for (m = m_vMultiplexer.begin(); m != m_vMultiplexer.end(); ++ m)
-      if (port == m->m_iPort)
-         break;
-
-   if (NULL != i->second->m_pQueuedSockets)
-   {
-      CGuard::enterCS(i->second->m_AcceptLock);
-
-      // if it is a listener, close all un-accepted sockets in its queue and remove them later
-      set<UDTSOCKET> tbc;
-      for (set<UDTSOCKET>::iterator q = i->second->m_pQueuedSockets->begin(); q != i->second->m_pQueuedSockets->end(); ++ q)
-      {
-         m_Sockets[*q]->m_pUDT->close();
-         m_Sockets[*q]->m_TimeStamp = CTimer::getTime();
-         m_Sockets[*q]->m_Status = CUDTSocket::CLOSED;
-	 tbc.insert(*q);
-         m_ClosedSockets[*q] = m_Sockets[*q];
-      }
-      for (set<UDTSOCKET>::iterator c = tbc.begin(); c != tbc.end(); ++ c)
-         m_Sockets.erase(*c);
-
-      CGuard::leaveCS(i->second->m_AcceptLock);
-   }
-
-   // delete this one
-   i->second->m_pUDT->close();
-   delete m_ClosedSockets[u];
-   m_ClosedSockets.erase(u);
-
-   if (m == m_vMultiplexer.end())
-      return;
-
-   m->m_iRefCount --;
-   if (0 == m->m_iRefCount)
-   {
-      m->m_pChannel->close();
-      delete m->m_pSndQueue;
-      delete m->m_pRcvQueue;
-      delete m->m_pTimer;
-      delete m->m_pChannel;
-      m_vMultiplexer.erase(m);
-   }
-}
-
-void CUDTUnited::setError(CUDTException* e)
-{
-   #ifndef WIN32
-      delete (CUDTException*)pthread_getspecific(m_TLSError);
-      pthread_setspecific(m_TLSError, e);
-   #else
-      CGuard tg(m_TLSLock);
-      delete (CUDTException*)TlsGetValue(m_TLSError);
-      TlsSetValue(m_TLSError, e);
-      m_mTLSRecord[GetCurrentThreadId()] = e;
-   #endif
-}
-
-CUDTException* CUDTUnited::getError()
-{
-   #ifndef WIN32
-      if(NULL == pthread_getspecific(m_TLSError))
-         pthread_setspecific(m_TLSError, new CUDTException);
-      return (CUDTException*)pthread_getspecific(m_TLSError);
-   #else
-      CGuard tg(m_TLSLock);
-      if(NULL == TlsGetValue(m_TLSError))
-      {
-         CUDTException* e = new CUDTException;
-         TlsSetValue(m_TLSError, e);
-         m_mTLSRecord[GetCurrentThreadId()] = e;
-      }
-      return (CUDTException*)TlsGetValue(m_TLSError);
-   #endif
-}
-
-#ifdef WIN32
-void CUDTUnited::checkTLSValue()
-{
-   CGuard tg(m_TLSLock);
-
-   vector<DWORD> tbr;
-   for (map<DWORD, CUDTException*>::iterator i = m_mTLSRecord.begin(); i != m_mTLSRecord.end(); ++ i)
-   {
-      HANDLE h = OpenThread(THREAD_QUERY_INFORMATION, FALSE, i->first);
-      if (NULL == h)
-      {
-         tbr.insert(tbr.end(), i->first);
-         break;
-      }
-      if (WAIT_OBJECT_0 == WaitForSingleObject(h, 0))
-      {
-         delete i->second;
-         tbr.insert(tbr.end(), i->first);
-      }
-      CloseHandle(h);
-   }
-   for (vector<DWORD>::iterator j = tbr.begin(); j != tbr.end(); ++ j)
-      m_mTLSRecord.erase(*j);
-}
-#endif
-
-void CUDTUnited::updateMux(CUDT* u, const sockaddr* addr, const UDPSOCKET* udpsock)
-{
-   CGuard cg(m_ControlLock);
-
-   if ((u->m_bReuseAddr) && (NULL != addr))
-   {
-      int port = (AF_INET == u->m_iIPversion) ? ntohs(((sockaddr_in*)addr)->sin_port) : ntohs(((sockaddr_in6*)addr)->sin6_port);
-
-      // find a reusable address
-      for (vector<CMultiplexer>::iterator i = m_vMultiplexer.begin(); i != m_vMultiplexer.end(); ++ i)
-      {
-         if ((i->m_iIPversion == u->m_iIPversion) && (i->m_iMSS == u->m_iMSS) && i->m_bReusable)
-         {
-            if (i->m_iPort == port)
-            {
-               // reuse the existing multiplexer
-               ++ i->m_iRefCount;
-               u->m_pSndQueue = i->m_pSndQueue;
-               u->m_pRcvQueue = i->m_pRcvQueue;
-               return;
-            }
-         }
-      }
-   }
-
-   // a new multiplexer is needed
-   CMultiplexer m;
-   m.m_iMSS = u->m_iMSS;
-   m.m_iIPversion = u->m_iIPversion;
-   m.m_iRefCount = 1;
-   m.m_bReusable = u->m_bReuseAddr;
-
-   m.m_pChannel = new CChannel(u->m_iIPversion);
-   m.m_pChannel->setSndBufSize(u->m_iUDPSndBufSize);
-   m.m_pChannel->setRcvBufSize(u->m_iUDPRcvBufSize);
-
-   try
-   {
-      if (NULL != udpsock)
-         m.m_pChannel->open(*udpsock);
-      else
-         m.m_pChannel->open(addr);
-   }
-   catch (CUDTException& e)
-   {
-      m.m_pChannel->close();
-      delete m.m_pChannel;
-      throw e;
-   }
-
-   sockaddr* sa = (AF_INET == u->m_iIPversion) ? (sockaddr*) new sockaddr_in : (sockaddr*) new sockaddr_in6;
-   m.m_pChannel->getSockAddr(sa);
-   m.m_iPort = (AF_INET == u->m_iIPversion) ? ntohs(((sockaddr_in*)sa)->sin_port) : ntohs(((sockaddr_in6*)sa)->sin6_port);
-   if (AF_INET == u->m_iIPversion) delete (sockaddr_in*)sa; else delete (sockaddr_in6*)sa;
-
-   m.m_pTimer = new CTimer;
-
-   m.m_pSndQueue = new CSndQueue;
-   m.m_pSndQueue->init(m.m_pChannel, m.m_pTimer);
-   m.m_pRcvQueue = new CRcvQueue;
-   m.m_pRcvQueue->init(32, u->m_iPayloadSize, m.m_iIPversion, 1024, m.m_pChannel, m.m_pTimer);
-
-   m_vMultiplexer.insert(m_vMultiplexer.end(), m);
-
-   u->m_pSndQueue = m.m_pSndQueue;
-   u->m_pRcvQueue = m.m_pRcvQueue;
-}
-
-void CUDTUnited::updateMux(CUDT* u, const CUDTSocket* ls)
-{
-   CGuard cg(m_ControlLock);
-
-   int port = (AF_INET == ls->m_iIPversion) ? ntohs(((sockaddr_in*)ls->m_pSelfAddr)->sin_port) : ntohs(((sockaddr_in6*)ls->m_pSelfAddr)->sin6_port);
-
-   // find the listener's address
-   for (vector<CMultiplexer>::iterator i = m_vMultiplexer.begin(); i != m_vMultiplexer.end(); ++ i)
-   {
-      if (i->m_iPort == port)
-      {
-         // reuse the existing multiplexer
-         ++ i->m_iRefCount;
-         u->m_pSndQueue = i->m_pSndQueue;
-         u->m_pRcvQueue = i->m_pRcvQueue;
-         return;
-      }
-   }
-}
-
-#ifndef WIN32
-   void* CUDTUnited::garbageCollect(void* p)
-#else
-   DWORD WINAPI CUDTUnited::garbageCollect(LPVOID p)
-#endif
-{
-   CUDTUnited* self = (CUDTUnited*)p;
-
-   while (!self->m_bClosing)
-   {
-      self->checkBrokenSockets();
-
-      #ifdef WIN32
-         self->checkTLSValue();
-      #endif
-
-      #ifndef WIN32
-         timeval now;
-         timespec timeout;
-         gettimeofday(&now, 0);
-         timeout.tv_sec = now.tv_sec + 1;
-         timeout.tv_nsec = now.tv_usec * 1000;
-
-         pthread_cond_timedwait(&self->m_GCStopCond, &self->m_GCStopLock, &timeout);
-      #else
-         WaitForSingleObject(self->m_GCStopCond, 1000);
-      #endif
-   }
-
-   // remove sockets and multiplpexers
-   for (map<UDTSOCKET, CUDTSocket*>::iterator i = self->m_Sockets.begin(); i != self->m_Sockets.end(); ++ i)
-   {
-      i->second->m_pUDT->close();
-      i->second->m_Status = CUDTSocket::CLOSED;
-      i->second->m_TimeStamp = 0;
-      self->m_ClosedSockets[i->first] = i->second;
-   }
-     self->m_ClosedSockets = self->m_Sockets;
-     self->m_Sockets.clear();
-   self->checkBrokenSockets();
-for (vector<CMultiplexer>::iterator m = self->m_vMultiplexer.begin(); m != self->m_vMultiplexer.end(); ++ m) {
-	     m->m_pChannel->close();
-	     delete m->m_pSndQueue;
-	     delete m->m_pRcvQueue;
-	     delete m->m_pTimer;
-	     delete m->m_pChannel;
-}
-self->m_vMultiplexer.clear();
-for (map<UDTSOCKET, CUDTSocket*>::iterator c = self->m_ClosedSockets.begin(); c != self->m_ClosedSockets.end(); ++ c) {
-	delete c->second;
-}
-self->m_ClosedSockets.clear();
-
-   #ifndef WIN32
-      return NULL;
-   #else
-      return 0;
-   #endif
-}
-
-////////////////////////////////////////////////////////////////////////////////
-
-int CUDT::startup()
-{
-   return s_UDTUnited.startup();
-}
-
-int CUDT::cleanup()
-{
-   return s_UDTUnited.cleanup();
-}
-
-UDTSOCKET CUDT::socket(int af, int type, int)
-{
-   if (!s_UDTUnited.m_bGCStatus)
-      s_UDTUnited.startup();
-
-   try
-   {
-      return s_UDTUnited.newSocket(af, type);
-   }
-   catch (CUDTException& e)
-   {
-      s_UDTUnited.setError(new CUDTException(e));
-      return INVALID_SOCK;
-   }
-   catch (bad_alloc&)
-   {
-      s_UDTUnited.setError(new CUDTException(3, 2, 0));
-      return INVALID_SOCK;
-   }
-   catch (...)
-   {
-      s_UDTUnited.setError(new CUDTException(-1, 0, 0));
-      return INVALID_SOCK;
-   }
-}
-
-int CUDT::bind(UDTSOCKET u, const sockaddr* name, int namelen)
-{
-   try
-   {
-      return s_UDTUnited.bind(u, name, namelen);
-   }
-   catch (CUDTException& e)
-   {
-      s_UDTUnited.setError(new CUDTException(e));
-      return ERROR;
-   }
-   catch (bad_alloc&)
-   {
-      s_UDTUnited.setError(new CUDTException(3, 2, 0));
-      return ERROR;
-   }
-   catch (...)
-   {
-      s_UDTUnited.setError(new CUDTException(-1, 0, 0));
-      return ERROR;
-   }
-}
-
-int CUDT::bind(UDTSOCKET u, UDPSOCKET udpsock)
-{
-   try
-   {
-      return s_UDTUnited.bind(u, udpsock);
-   }
-   catch (CUDTException& e)
-   {
-      s_UDTUnited.setError(new CUDTException(e));
-      return ERROR;
-   }
-   catch (bad_alloc&)
-   {
-      s_UDTUnited.setError(new CUDTException(3, 2, 0));
-      return ERROR;
-   }
-   catch (...)
-   {
-      s_UDTUnited.setError(new CUDTException(-1, 0, 0));
-      return ERROR;
-   }
-}
-
-int CUDT::listen(UDTSOCKET u, int backlog)
-{
-   try
-   {
-      return s_UDTUnited.listen(u, backlog);
-   }
-   catch (CUDTException& e)
-   {
-      s_UDTUnited.setError(new CUDTException(e));
-      return ERROR;
-   }
-   catch (bad_alloc&)
-   {
-      s_UDTUnited.setError(new CUDTException(3, 2, 0));
-      return ERROR;
-   }
-   catch (...)
-   {
-      s_UDTUnited.setError(new CUDTException(-1, 0, 0));
-      return ERROR;
-   }
-}
-
-UDTSOCKET CUDT::accept(UDTSOCKET u, sockaddr* addr, int* addrlen)
-{
-   try
-   {
-      return s_UDTUnited.accept(u, addr, addrlen);
-   }
-   catch (CUDTException& e)
-   {
-      s_UDTUnited.setError(new CUDTException(e));
-      return INVALID_SOCK;
-   }
-   catch (...)
-   {
-      s_UDTUnited.setError(new CUDTException(-1, 0, 0));
-      return INVALID_SOCK;
-   }
-}
-
-int CUDT::connect(UDTSOCKET u, const sockaddr* name, int namelen)
-{
-   try
-   {
-      return s_UDTUnited.connect(u, name, namelen);
-   }
-   catch (CUDTException e)
-   {
-      s_UDTUnited.setError(new CUDTException(e));
-      return ERROR;
-   }
-   catch (bad_alloc&)
-   {
-      s_UDTUnited.setError(new CUDTException(3, 2, 0));
-      return ERROR;
-   }
-   catch (...)
-   {
-      s_UDTUnited.setError(new CUDTException(-1, 0, 0));
-      return ERROR;
-   }
-}
-
-int CUDT::close(UDTSOCKET u)
-{
-   try
-   {
-      return s_UDTUnited.close(u);
-   }
-   catch (CUDTException e)
-   {
-      s_UDTUnited.setError(new CUDTException(e));
-      return ERROR;
-   }
-   catch (...)
-   {
-      s_UDTUnited.setError(new CUDTException(-1, 0, 0));
-      return ERROR;
-   }
-}
-
-int CUDT::getpeername(UDTSOCKET u, sockaddr* name, int* namelen)
-{
-   try
-   {
-      return s_UDTUnited.getpeername(u, name, namelen);
-   }
-   catch (CUDTException e)
-   {
-      s_UDTUnited.setError(new CUDTException(e));
-      return ERROR;
-   }
-   catch (...)
-   {
-      s_UDTUnited.setError(new CUDTException(-1, 0, 0));
-      return ERROR;
-   }
-}
-
-int CUDT::getsockname(UDTSOCKET u, sockaddr* name, int* namelen)
-{
-   try
-   {
-      return s_UDTUnited.getsockname(u, name, namelen);;
-   }
-   catch (CUDTException e)
-   {
-      s_UDTUnited.setError(new CUDTException(e));
-      return ERROR;
-   }
-   catch (...)
-   {
-      s_UDTUnited.setError(new CUDTException(-1, 0, 0));
-      return ERROR;
-   }
-}
-
-int CUDT::getsockopt(UDTSOCKET u, int, UDTOpt optname, void* optval, int* optlen)
-{
-   try
-   {
-      CUDT* udt = s_UDTUnited.lookup(u);
-      udt->getOpt(optname, optval, *optlen);
-      return 0;
-   }
-   catch (CUDTException e)
-   {
-      s_UDTUnited.setError(new CUDTException(e));
-      return ERROR;
-   }
-   catch (...)
-   {
-      s_UDTUnited.setError(new CUDTException(-1, 0, 0));
-      return ERROR;
-   }
-}
-
-int CUDT::setsockopt(UDTSOCKET u, int, UDTOpt optname, const void* optval, int optlen)
-{
-   try
-   {
-      CUDT* udt = s_UDTUnited.lookup(u);
-      udt->setOpt(optname, optval, optlen);
-      return 0;
-   }
-   catch (CUDTException e)
-   {
-      s_UDTUnited.setError(new CUDTException(e));
-      return ERROR;
-   }
-   catch (...)
-   {
-      s_UDTUnited.setError(new CUDTException(-1, 0, 0));
-      return ERROR;
-   }
-}
-
-int CUDT::send(UDTSOCKET u, const char* buf, int len, int)
-{
-   try
-   {
-      CUDT* udt = s_UDTUnited.lookup(u);
-      return udt->send((char*)buf, len);
-   }
-   catch (CUDTException e)
-   {
-      s_UDTUnited.setError(new CUDTException(e));
-      return ERROR;
-   }
-   catch (bad_alloc&)
-   {
-      s_UDTUnited.setError(new CUDTException(3, 2, 0));
-      return ERROR;
-   }
-   catch (...)
-   {
-      s_UDTUnited.setError(new CUDTException(-1, 0, 0));
-      return ERROR;
-   }
-}
-
-int CUDT::recv(UDTSOCKET u, char* buf, int len, int)
-{
-   try
-   {
-      CUDT* udt = s_UDTUnited.lookup(u);
-      return udt->recv(buf, len);
-   }
-   catch (CUDTException e)
-   {
-      s_UDTUnited.setError(new CUDTException(e));
-      return ERROR;
-   }
-   catch (...)
-   {
-      s_UDTUnited.setError(new CUDTException(-1, 0, 0));
-      return ERROR;
-   }
-}
-
-int CUDT::sendmsg(UDTSOCKET u, const char* buf, int len, int ttl, bool inorder)
-{
-   try
-   {
-      CUDT* udt = s_UDTUnited.lookup(u);
-      return udt->sendmsg((char*)buf, len, ttl, inorder);
-   }
-   catch (CUDTException e)
-   {
-      s_UDTUnited.setError(new CUDTException(e));
-      return ERROR;
-   }
-   catch (bad_alloc&)
-   {
-      s_UDTUnited.setError(new CUDTException(3, 2, 0));
-      return ERROR;
-   }
-   catch (...)
-   {
-      s_UDTUnited.setError(new CUDTException(-1, 0, 0));
-      return ERROR;
-   }
-}
-
-int CUDT::recvmsg(UDTSOCKET u, char* buf, int len)
-{
-   try
-   {
-      CUDT* udt = s_UDTUnited.lookup(u);
-      return udt->recvmsg(buf, len);
-   }
-   catch (CUDTException e)
-   {
-      s_UDTUnited.setError(new CUDTException(e));
-      return ERROR;
-   }
-   catch (...)
-   {
-      s_UDTUnited.setError(new CUDTException(-1, 0, 0));
-      return ERROR;
-   }
-}
-
-int64_t CUDT::sendfile(UDTSOCKET u, ifstream& ifs, const int64_t& offset, const int64_t& size, const int& block)
-{
-   try
-   {
-      CUDT* udt = s_UDTUnited.lookup(u);
-      return udt->sendfile(ifs, offset, size, block);
-   }
-   catch (CUDTException e)
-   {
-      s_UDTUnited.setError(new CUDTException(e));
-      return ERROR;
-   }
-   catch (bad_alloc&)
-   {
-      s_UDTUnited.setError(new CUDTException(3, 2, 0));
-      return ERROR;
-   }
-   catch (...)
-   {
-      s_UDTUnited.setError(new CUDTException(-1, 0, 0));
-      return ERROR;
-   }
-}
-
-int64_t CUDT::recvfile(UDTSOCKET u, ofstream& ofs, const int64_t& offset, const int64_t& size, const int& block)
-{
-   try
-   {
-      CUDT* udt = s_UDTUnited.lookup(u);
-      return udt->recvfile(ofs, offset, size, block);
-   }
-   catch (CUDTException e)
-   {
-      s_UDTUnited.setError(new CUDTException(e));
-      return ERROR;
-   }
-   catch (...)
-   {
-      s_UDTUnited.setError(new CUDTException(-1, 0, 0));
-      return ERROR;
-   }
-}
-
-int CUDT::select(int, ud_set* readfds, ud_set* writefds, ud_set* exceptfds, const timeval* timeout)
-{
-   if ((NULL == readfds) && (NULL == writefds) && (NULL == exceptfds))
-   {
-      s_UDTUnited.setError(new CUDTException(5, 3, 0));
-      return ERROR;
-   }
-
-   try
-   {
-      return s_UDTUnited.select(readfds, writefds, exceptfds, timeout);
-   }
-   catch (CUDTException e)
-   {
-      s_UDTUnited.setError(new CUDTException(e));
-      return ERROR;
-   }
-   catch (bad_alloc&)
-   {
-      s_UDTUnited.setError(new CUDTException(3, 2, 0));
-      return ERROR;
-   }
-   catch (...)
-   {
-      s_UDTUnited.setError(new CUDTException(-1, 0, 0));
-      return ERROR;
-   }
-}
-
-CUDTException& CUDT::getlasterror()
-{
-   return *s_UDTUnited.getError();
-}
-
-int CUDT::perfmon(UDTSOCKET u, CPerfMon* perf, bool clear)
-{
-   try
-   {
-      CUDT* udt = s_UDTUnited.lookup(u);
-      udt->sample(perf, clear);
-      return 0;
-   }
-   catch (CUDTException e)
-   {
-      s_UDTUnited.setError(new CUDTException(e));
-      return ERROR;
-   }
-   catch (...)
-   {
-      s_UDTUnited.setError(new CUDTException(-1, 0, 0));
-      return ERROR;
-   }
-}
-
-CUDT* CUDT::getUDTHandle(UDTSOCKET u)
-{
-   return s_UDTUnited.lookup(u);
-}
-
-////////////////////////////////////////////////////////////////////////////////
-
-namespace UDT
-{
-
-int startup()
-{
-   return CUDT::startup();
-}
-
-int cleanup()
-{
-   return CUDT::cleanup();
-}
-
-UDTSOCKET socket(int af, int type, int protocol)
-{
-   return CUDT::socket(af, type, protocol);
-}
-
-int bind(UDTSOCKET u, const struct sockaddr* name, int namelen)
-{
-   return CUDT::bind(u, name, namelen);
-}
-
-int bind(UDTSOCKET u, UDPSOCKET udpsock)
-{
-   return CUDT::bind(u, udpsock);
-}
-
-int listen(UDTSOCKET u, int backlog)
-{
-   return CUDT::listen(u, backlog);
-}
-
-UDTSOCKET accept(UDTSOCKET u, struct sockaddr* addr, int* addrlen)
-{
-   return CUDT::accept(u, addr, addrlen);
-}
-
-int connect(UDTSOCKET u, const struct sockaddr* name, int namelen)
-{
-   return CUDT::connect(u, name, namelen);
-}
-
-int close(UDTSOCKET u)
-{
-   return CUDT::close(u);
-}
-
-int getpeername(UDTSOCKET u, struct sockaddr* name, int* namelen)
-{
-   return CUDT::getpeername(u, name, namelen);
-}
-
-int getsockname(UDTSOCKET u, struct sockaddr* name, int* namelen)
-{
-   return CUDT::getsockname(u, name, namelen);
-}
-
-int getsockopt(UDTSOCKET u, int level, SOCKOPT optname, void* optval, int* optlen)
-{
-   return CUDT::getsockopt(u, level, optname, optval, optlen);
-}
-
-int setsockopt(UDTSOCKET u, int level, SOCKOPT optname, const void* optval, int optlen)
-{
-   return CUDT::setsockopt(u, level, optname, optval, optlen);
-}
-
-int send(UDTSOCKET u, const char* buf, int len, int flags)
-{
-   return CUDT::send(u, buf, len, flags);
-}
-
-int recv(UDTSOCKET u, char* buf, int len, int flags)
-{
-   return CUDT::recv(u, buf, len, flags);
-}
-
-int sendmsg(UDTSOCKET u, const char* buf, int len, int ttl, bool inorder)
-{
-   return CUDT::sendmsg(u, buf, len, ttl, inorder);
-}
-
-int recvmsg(UDTSOCKET u, char* buf, int len)
-{
-   return CUDT::recvmsg(u, buf, len);
-}
-
-int64_t sendfile(UDTSOCKET u, ifstream& ifs, int64_t offset, int64_t size, int block)
-{
-   return CUDT::sendfile(u, ifs, offset, size, block);
-}
-
-int64_t recvfile(UDTSOCKET u, ofstream& ofs, int64_t offset, int64_t size, int block)
-{
-   return CUDT::recvfile(u, ofs, offset, size, block);
-}
-
-int select(int nfds, UDSET* readfds, UDSET* writefds, UDSET* exceptfds, const struct timeval* timeout)
-{
-   return CUDT::select(nfds, readfds, writefds, exceptfds, timeout);
-}
-
-ERRORINFO& getlasterror()
-{
-   return CUDT::getlasterror();
-}
-
-int perfmon(UDTSOCKET u, TRACEINFO* perf, bool clear)
-{
-   return CUDT::perfmon(u, perf, clear);
-}
-
-}
+/*****************************************************************************
+Copyright (c) 2001 - 2009, The Board of Trustees of the University of Illinois.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+
+* Redistributions of source code must retain the above
+  copyright notice, this list of conditions and the
+  following disclaimer.
+
+* Redistributions in binary form must reproduce the
+  above copyright notice, this list of conditions
+  and the following disclaimer in the documentation
+  and/or other materials provided with the distribution.
+
+* Neither the name of the University of Illinois
+  nor the names of its contributors may be used to
+  endorse or promote products derived from this
+  software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*****************************************************************************/
+
+/*****************************************************************************
+written by
+   Yunhong Gu, last updated 01/22/2009
+*****************************************************************************/
+
+#ifdef WIN32
+   #include <winsock2.h>
+   #include <ws2tcpip.h>
+#ifdef __MSVC__
+   #include <wspiapi.h>
+#endif // __MSVC__
+#else
+   #include <unistd.h>
+#endif
+#include <cstring>
+#include "api.h"
+#include "core.h"
+
+using namespace std;
+
+CUDTSocket::CUDTSocket():
+m_Status(),
+m_TimeStamp(),
+m_iIPversion(),
+m_pSelfAddr(),
+m_pPeerAddr(),
+m_SocketID(),
+m_ListenSocket(),
+m_PeerID(),
+m_iISN(),
+m_pUDT(),
+m_pQueuedSockets(),
+m_pAcceptSockets(),
+m_AcceptCond(),
+m_AcceptLock(),
+m_uiBackLog()
+{
+   #ifndef WIN32
+      pthread_mutex_init(&m_AcceptLock, NULL);
+      pthread_cond_init(&m_AcceptCond, NULL);
+   #else
+      m_AcceptLock = CreateMutex(NULL, false, NULL);
+      m_AcceptCond = CreateEvent(NULL, false, false, NULL);
+   #endif
+}
+
+CUDTSocket::~CUDTSocket()
+{
+   if (AF_INET == m_iIPversion)
+   {
+      delete (sockaddr_in*)m_pSelfAddr;
+      delete (sockaddr_in*)m_pPeerAddr;
+   }
+   else
+   {
+      delete (sockaddr_in6*)m_pSelfAddr;
+      delete (sockaddr_in6*)m_pPeerAddr;
+   }
+
+   delete m_pUDT;
+
+   delete m_pQueuedSockets;
+   delete m_pAcceptSockets;
+
+   #ifndef WIN32
+      pthread_mutex_destroy(&m_AcceptLock);
+      pthread_cond_destroy(&m_AcceptCond);
+   #else
+      CloseHandle(m_AcceptLock);
+      CloseHandle(m_AcceptCond);
+   #endif
+}
+
+////////////////////////////////////////////////////////////////////////////////
+
+CUDTUnited::CUDTUnited() : m_Sockets(), m_ControlLock(), m_IDLock(),
+m_SocketID(), m_TLSError(), m_vMultiplexer(), m_MultiplexerLock(),
+m_pController(), m_bClosing(), m_GCStopLock(), m_GCStopCond(),
+m_InitLock(), m_bGCStatus(false), m_GCThread(), m_ClosedSockets()
+{
+   srand((unsigned int)CTimer::getTime());
+   m_SocketID = 1 + (int)((1 << 30) * (double(rand()) / RAND_MAX));
+
+   #ifndef WIN32
+      pthread_mutex_init(&m_ControlLock, NULL);
+      pthread_mutex_init(&m_IDLock, NULL);
+      pthread_mutex_init(&m_InitLock, NULL);
+   #else
+      m_ControlLock = CreateMutex(NULL, false, NULL);
+      m_IDLock = CreateMutex(NULL, false, NULL);
+      m_InitLock = CreateMutex(NULL, false, NULL);
+   #endif
+
+   #ifndef WIN32
+      pthread_key_create(&m_TLSError, TLSDestroy);
+   #else
+      m_TLSError = TlsAlloc();
+      m_TLSLock = CreateMutex(NULL, false, NULL);
+   #endif
+
+   // Global initialization code
+   #ifdef WIN32
+      WORD wVersionRequested;
+      WSADATA wsaData;
+      wVersionRequested = MAKEWORD(2, 2);
+
+      if (0 != WSAStartup(wVersionRequested, &wsaData))
+         throw CUDTException(1, 0,  WSAGetLastError());
+   #endif
+
+   m_vMultiplexer.clear();
+   m_pController = new CControl;
+
+}
+
+CUDTUnited::~CUDTUnited()
+{
+   #ifndef WIN32
+      pthread_mutex_destroy(&m_ControlLock);
+      pthread_mutex_destroy(&m_IDLock);
+      pthread_mutex_destroy(&m_InitLock);
+   #else
+      CloseHandle(m_ControlLock);
+      CloseHandle(m_IDLock);
+      CloseHandle(m_InitLock);
+   #endif
+
+   #ifndef WIN32
+      pthread_key_delete(m_TLSError);
+   #else
+      TlsFree(m_TLSError);
+      CloseHandle(m_TLSLock);
+   #endif
+
+   m_vMultiplexer.clear();
+   delete m_pController;
+
+   // Global destruction code
+   #ifdef WIN32
+      WSACleanup();
+   #endif
+}
+
+int CUDTUnited::startup()
+{
+   CGuard gcinit(m_InitLock);
+
+   if (m_bGCStatus)
+      return true;
+
+   m_bClosing = false;
+   #ifndef WIN32
+      pthread_mutex_init(&m_GCStopLock, NULL);
+      pthread_cond_init(&m_GCStopCond, NULL);
+      pthread_create(&m_GCThread, NULL, garbageCollect, this);
+   #else
+      m_GCStopLock = CreateMutex(NULL, false, NULL);
+      m_GCStopCond = CreateEvent(NULL, false, false, NULL);
+      DWORD ThreadID;
+      m_GCThread = CreateThread(NULL, 0, garbageCollect, this, NULL, &ThreadID);
+   #endif
+
+   m_bGCStatus = true;
+
+   return 0;
+}
+
+int CUDTUnited::cleanup()
+{
+   CGuard gcinit(m_InitLock);
+
+   if (!m_bGCStatus)
+      return 0;
+
+   m_bClosing = true;
+   #ifndef WIN32
+      pthread_cond_signal(&m_GCStopCond);
+      pthread_join(m_GCThread, NULL);
+      pthread_mutex_destroy(&m_GCStopLock);
+      pthread_cond_destroy(&m_GCStopCond);
+   #else
+      SetEvent(m_GCStopCond);
+      WaitForSingleObject(m_GCThread, INFINITE);
+      CloseHandle(m_GCThread);
+      CloseHandle(m_GCStopLock);
+      CloseHandle(m_GCStopCond);
+   #endif
+
+   m_bGCStatus = false;
+
+   return 0;
+}
+
+UDTSOCKET CUDTUnited::newSocket(const int& af, const int& type)
+{
+   if ((type != SOCK_STREAM) && (type != SOCK_DGRAM))
+      throw CUDTException(5, 3, 0);
+
+   CUDTSocket* ns = NULL;
+
+   try
+   {
+      ns = new CUDTSocket;
+      ns->m_pUDT = new CUDT;
+      if (AF_INET == af)
+      {
+         ns->m_pSelfAddr = (sockaddr*)(new sockaddr_in);
+         ((sockaddr_in*)(ns->m_pSelfAddr))->sin_port = 0;
+      }
+      else
+      {
+         ns->m_pSelfAddr = (sockaddr*)(new sockaddr_in6);
+         ((sockaddr_in6*)(ns->m_pSelfAddr))->sin6_port = 0;
+      }
+   }
+   catch (...)
+   {
+      delete ns;
+      throw CUDTException(3, 2, 0);
+   }
+
+   CGuard::enterCS(m_IDLock);
+   ns->m_SocketID = -- m_SocketID;
+   CGuard::leaveCS(m_IDLock);
+
+   ns->m_Status = CUDTSocket::INIT;
+   ns->m_ListenSocket = 0;
+   ns->m_pUDT->m_SocketID = ns->m_SocketID;
+   ns->m_pUDT->m_iSockType = (SOCK_STREAM == type) ? UDT_STREAM : UDT_DGRAM;
+   ns->m_pUDT->m_iIPversion = ns->m_iIPversion = af;
+   ns->m_pUDT->m_pController = m_pController;
+
+   // protect the m_Sockets structure.
+   CGuard::enterCS(m_ControlLock);
+   try
+   {
+      m_Sockets[ns->m_SocketID] = ns;
+   }
+   catch (...)
+   {
+      //failure and rollback
+      delete ns;
+      ns = NULL;
+   }
+   CGuard::leaveCS(m_ControlLock);
+
+   if (NULL == ns)
+      throw CUDTException(3, 2, 0);
+
+   return ns->m_SocketID;
+}
+
+int CUDTUnited::newConnection(const UDTSOCKET listen, const sockaddr* peer, CHandShake* hs)
+{
+   CUDTSocket* ns = NULL;
+   CUDTSocket* ls = locate(listen);
+
+   // if this connection has already been processed
+   if (NULL != (ns = locate(listen, peer, hs->m_iID, hs->m_iISN)))
+   {
+      if (ns->m_pUDT->m_bBroken)
+      {
+         // last connection from the "peer" address has been broken
+         ns->m_Status = CUDTSocket::CLOSED;
+         ns->m_TimeStamp = CTimer::getTime();
+
+         CGuard::enterCS(ls->m_AcceptLock);
+         ls->m_pQueuedSockets->erase(ns->m_SocketID);
+         ls->m_pAcceptSockets->erase(ns->m_SocketID);
+         CGuard::leaveCS(ls->m_AcceptLock);
+      }
+      else
+      {
+         // connection already exist, this is a repeated connection request
+         // respond with existing HS information
+
+         hs->m_iISN = ns->m_pUDT->m_iISN;
+         hs->m_iMSS = ns->m_pUDT->m_iMSS;
+         hs->m_iFlightFlagSize = ns->m_pUDT->m_iFlightFlagSize;
+         hs->m_iReqType = -1;
+         hs->m_iID = ns->m_SocketID;
+
+         return 0;
+
+         //except for this situation a new connection should be started
+      }
+   }
+
+   // checking if ls = NULL (failed to located listen socket)
+   if (ls == NULL)
+     return -1;
+   // exceeding backlog, refuse the connection request
+   if (ls->m_pQueuedSockets->size() >= ls->m_uiBackLog)
+      return -1;
+
+   try
+   {
+      ns = new CUDTSocket;
+      ns->m_pUDT = new CUDT(*(ls->m_pUDT));
+      if (AF_INET == ls->m_iIPversion)
+      {
+         ns->m_pSelfAddr = (sockaddr*)(new sockaddr_in);
+         ((sockaddr_in*)(ns->m_pSelfAddr))->sin_port = 0;
+         ns->m_pPeerAddr = (sockaddr*)(new sockaddr_in);
+         memcpy(ns->m_pPeerAddr, peer, sizeof(sockaddr_in));
+      }
+      else
+      {
+         ns->m_pSelfAddr = (sockaddr*)(new sockaddr_in6);
+         ((sockaddr_in6*)(ns->m_pSelfAddr))->sin6_port = 0;
+         ns->m_pPeerAddr = (sockaddr*)(new sockaddr_in6);
+         memcpy(ns->m_pPeerAddr, peer, sizeof(sockaddr_in6));
+      }
+   }
+   catch (...)
+   {
+      delete ns;
+      return -1;
+   }
+
+   CGuard::enterCS(m_IDLock);
+   ns->m_SocketID = -- m_SocketID;
+   CGuard::leaveCS(m_IDLock);
+
+   ns->m_ListenSocket = listen;
+   ns->m_iIPversion = ls->m_iIPversion;
+   ns->m_pUDT->m_SocketID = ns->m_SocketID;
+   ns->m_PeerID = hs->m_iID;
+   ns->m_iISN = hs->m_iISN;
+
+   int error = 0;
+
+   try
+   {
+      // bind to the same addr of listening socket
+      ns->m_pUDT->open();
+      updateMux(ns->m_pUDT, ls);
+      ns->m_pUDT->connect(peer, hs);
+   }
+   catch (...)
+   {
+      error = 1;
+      goto ERR_ROLLBACK;
+   }
+
+   ns->m_Status = CUDTSocket::CONNECTED;
+
+   // copy address information of local node
+   ns->m_pUDT->m_pSndQueue->m_pChannel->getSockAddr(ns->m_pSelfAddr);
+
+   // protect the m_Sockets structure.
+   CGuard::enterCS(m_ControlLock);
+   try
+   {
+      m_Sockets[ns->m_SocketID] = ns;
+   }
+   catch (...)
+   {
+      error = 2;
+   }
+   CGuard::leaveCS(m_ControlLock);
+
+   CGuard::enterCS(ls->m_AcceptLock);
+   try
+   {
+      ls->m_pQueuedSockets->insert(ns->m_SocketID);
+   }
+   catch (...)
+   {
+      error = 3;
+   }
+   CGuard::leaveCS(ls->m_AcceptLock);
+
+   CTimer::triggerEvent();
+
+   ERR_ROLLBACK:
+   if (error > 0)
+   {
+      ns->m_pUDT->close();
+      ns->m_Status = CUDTSocket::CLOSED;
+      ns->m_TimeStamp = CTimer::getTime();
+
+      return -1;
+   }
+
+   // wake up a waiting accept() call
+   #ifndef WIN32
+      pthread_cond_signal(&(ls->m_AcceptCond));
+   #else
+      SetEvent(ls->m_AcceptCond);
+   #endif
+
+   return 1;
+}
+
+CUDT* CUDTUnited::lookup(const UDTSOCKET u)
+{
+   // protects the m_Sockets structure
+   CGuard cg(m_ControlLock);
+
+   map<UDTSOCKET, CUDTSocket*>::iterator i = m_Sockets.find(u);
+
+   if ((i == m_Sockets.end()) || (i->second->m_Status == CUDTSocket::CLOSED))
+      throw CUDTException(5, 4, 0);
+
+   return i->second->m_pUDT;
+}
+
+CUDTSocket::UDTSTATUS CUDTUnited::getStatus(const UDTSOCKET u)
+{
+   // protects the m_Sockets structure
+   CGuard cg(m_ControlLock);
+
+   map<UDTSOCKET, CUDTSocket*>::iterator i = m_Sockets.find(u);
+
+   if (i == m_Sockets.end())
+      return CUDTSocket::INIT;
+
+   if (i->second->m_pUDT->m_bBroken)
+      return CUDTSocket::BROKEN;
+
+   return i->second->m_Status;
+}
+
+int CUDTUnited::bind(const UDTSOCKET u, const sockaddr* name, const int& namelen)
+{
+   CUDTSocket* s = locate(u);
+
+   if (NULL == s)
+      throw CUDTException(5, 4, 0);
+
+   // cannot bind a socket more than once
+   if (CUDTSocket::INIT != s->m_Status)
+      throw CUDTException(5, 0, 0);
+
+   // check the size of SOCKADDR structure
+   if (AF_INET == s->m_iIPversion)
+   {
+      if (namelen != sizeof(sockaddr_in))
+         throw CUDTException(5, 3, 0);
+   }
+   else
+   {
+      if (namelen != sizeof(sockaddr_in6))
+         throw CUDTException(5, 3, 0);
+   }
+
+   s->m_pUDT->open();
+   updateMux(s->m_pUDT, name);
+   s->m_Status = CUDTSocket::OPENED;
+
+   // copy address information of local node
+   s->m_pUDT->m_pSndQueue->m_pChannel->getSockAddr(s->m_pSelfAddr);
+
+   return 0;
+}
+
+int CUDTUnited::bind(UDTSOCKET u, UDPSOCKET udpsock)
+{
+   CUDTSocket* s = locate(u);
+
+   if (NULL == s)
+      throw CUDTException(5, 4, 0);
+
+   // cannot bind a socket more than once
+   if (CUDTSocket::INIT != s->m_Status)
+      throw CUDTException(5, 0, 0);
+
+   sockaddr_in name4;
+   sockaddr_in6 name6;
+   sockaddr* name;
+   socklen_t namelen;
+
+   if (AF_INET == s->m_iIPversion)
+   {
+      namelen = sizeof(sockaddr_in);
+      name = (sockaddr*)&name4;
+   }
+   else
+   {
+      namelen = sizeof(sockaddr_in6);
+      name = (sockaddr*)&name6;
+   }
+
+   if (-1 == ::getsockname(udpsock, name, &namelen))
+      throw CUDTException(5, 3);
+
+   s->m_pUDT->open();
+   updateMux(s->m_pUDT, name, &udpsock);
+   s->m_Status = CUDTSocket::OPENED;
+
+   // copy address information of local node
+   s->m_pUDT->m_pSndQueue->m_pChannel->getSockAddr(s->m_pSelfAddr);
+
+   return 0;
+}
+
+int CUDTUnited::listen(const UDTSOCKET u, const int& backlog)
+{
+   CUDTSocket* s = locate(u);
+
+   if (NULL == s)
+      throw CUDTException(5, 4, 0);
+
+   // do nothing if the socket is already listening
+   if (CUDTSocket::LISTENING == s->m_Status)
+      return 0;
+
+   // a socket can listen only if is in OPENED status
+   if (CUDTSocket::OPENED != s->m_Status)
+      throw CUDTException(5, 5, 0);
+
+   // listen is not supported in rendezvous connection setup
+   if (s->m_pUDT->m_bRendezvous)
+      throw CUDTException(5, 7, 0);
+
+   if (backlog <= 0)
+      throw CUDTException(5, 3, 0);
+
+   s->m_uiBackLog = backlog;
+
+   try
+   {
+      s->m_pQueuedSockets = new set<UDTSOCKET>;
+      s->m_pAcceptSockets = new set<UDTSOCKET>;
+   }
+   catch (...)
+   {
+      delete s->m_pQueuedSockets;
+      throw CUDTException(3, 2, 0);
+   }
+
+   s->m_pUDT->listen();
+
+   s->m_Status = CUDTSocket::LISTENING;
+
+   return 0;
+}
+
+UDTSOCKET CUDTUnited::accept(const UDTSOCKET listen, sockaddr* addr, int* addrlen)
+{
+   if ((NULL != addr) && (NULL == addrlen))
+      throw CUDTException(5, 3, 0);
+
+   CUDTSocket* ls = locate(listen);
+
+   if (ls == NULL)
+      throw CUDTException(5, 4, 0);
+
+   // the "listen" socket must be in LISTENING status
+   if (CUDTSocket::LISTENING != ls->m_Status)
+      throw CUDTException(5, 6, 0);
+
+   // no "accept" in rendezvous connection setup
+   if (ls->m_pUDT->m_bRendezvous)
+      throw CUDTException(5, 7, 0);
+
+   UDTSOCKET u = CUDT::INVALID_SOCK;
+   bool accepted = false;
+
+   // !!only one conection can be set up each time!!
+   #ifndef WIN32
+      while (!accepted)
+      {
+         pthread_mutex_lock(&(ls->m_AcceptLock));
+
+         if (ls->m_pQueuedSockets->size() > 0)
+         {
+            u = *(ls->m_pQueuedSockets->begin());
+            ls->m_pAcceptSockets->insert(ls->m_pAcceptSockets->end(), u);
+            ls->m_pQueuedSockets->erase(ls->m_pQueuedSockets->begin());
+
+            accepted = true;
+         }
+         else if (!ls->m_pUDT->m_bSynRecving)
+            accepted = true;
+         else if (CUDTSocket::LISTENING == ls->m_Status)
+            pthread_cond_wait(&(ls->m_AcceptCond), &(ls->m_AcceptLock));
+
+         if (CUDTSocket::LISTENING != ls->m_Status)
+            accepted = true;
+
+         pthread_mutex_unlock(&(ls->m_AcceptLock));
+      }
+   #else
+      while (!accepted)
+      {
+         WaitForSingleObject(ls->m_AcceptLock, INFINITE);
+
+         if (ls->m_pQueuedSockets->size() > 0)
+         {
+            u = *(ls->m_pQueuedSockets->begin());
+            ls->m_pAcceptSockets->insert(ls->m_pAcceptSockets->end(), u);
+            ls->m_pQueuedSockets->erase(ls->m_pQueuedSockets->begin());
+
+            accepted = true;
+         }
+         else if (!ls->m_pUDT->m_bSynRecving)
+            accepted = true;
+
+         ReleaseMutex(ls->m_AcceptLock);
+
+         if  (!accepted & (CUDTSocket::LISTENING == ls->m_Status))
+            WaitForSingleObject(ls->m_AcceptCond, INFINITE);
+
+         if (CUDTSocket::LISTENING != ls->m_Status)
+         {
+            SetEvent(ls->m_AcceptCond);
+            accepted = true;
+         }
+      }
+   #endif
+
+   if (u == CUDT::INVALID_SOCK)
+   {
+      // non-blocking receiving, no connection available
+      if (!ls->m_pUDT->m_bSynRecving)
+         throw CUDTException(6, 2, 0);
+
+      // listening socket is closed
+      throw CUDTException(5, 6, 0);
+   }
+
+   if (AF_INET == locate(u)->m_iIPversion)
+      *addrlen = sizeof(sockaddr_in);
+   else
+      *addrlen = sizeof(sockaddr_in6);
+
+   // copy address information of peer node
+   memcpy(addr, locate(u)->m_pPeerAddr, *addrlen);
+
+   return u;
+}
+
+int CUDTUnited::connect(const UDTSOCKET u, const sockaddr* name, const int& namelen)
+{
+   CUDTSocket* s = locate(u);
+   if (NULL == s)
+      throw CUDTException(5, 4, 0);
+
+   // check the size of SOCKADDR structure
+   if (AF_INET == s->m_iIPversion)
+   {
+      if (namelen != sizeof(sockaddr_in))
+         throw CUDTException(5, 3, 0);
+   }
+   else
+   {
+      if (namelen != sizeof(sockaddr_in6))
+         throw CUDTException(5, 3, 0);
+   }
+
+   // a socket can "connect" only if it is in INIT or OPENED status
+   if (CUDTSocket::INIT == s->m_Status)
+   {
+      if (!s->m_pUDT->m_bRendezvous)
+      {
+         s->m_pUDT->open();
+         updateMux(s->m_pUDT);
+         s->m_Status = CUDTSocket::OPENED;
+      }
+      else
+         throw CUDTException(5, 8, 0);
+   }
+   else if (CUDTSocket::OPENED != s->m_Status)
+      throw CUDTException(5, 2, 0);
+
+   s->m_pUDT->connect(name);
+   s->m_Status = CUDTSocket::CONNECTED;
+
+   // copy address information of local node
+   s->m_pUDT->m_pSndQueue->m_pChannel->getSockAddr(s->m_pSelfAddr);
+
+   // record peer address
+   if (AF_INET == s->m_iIPversion)
+   {
+      s->m_pPeerAddr = (sockaddr*)(new sockaddr_in);
+      memcpy(s->m_pPeerAddr, name, sizeof(sockaddr_in));
+   }
+   else
+   {
+      s->m_pPeerAddr = (sockaddr*)(new sockaddr_in6);
+      memcpy(s->m_pPeerAddr, name, sizeof(sockaddr_in6));
+   }
+
+   return 0;
+}
+
+int CUDTUnited::close(const UDTSOCKET u)
+{
+   CUDTSocket* s = locate(u);
+
+   // silently drop a request to close an invalid ID, rather than return error
+   if (NULL == s)
+      return 0;
+
+   s->m_pUDT->close();
+
+   // a socket will not be immediated removed when it is closed
+   // in order to prevent other methods from accessing invalid address
+   // a timer is started and the socket will be removed after approximately 1 second
+   s->m_TimeStamp = CTimer::getTime();
+
+   CUDTSocket::UDTSTATUS os = s->m_Status;
+
+   // synchronize with garbage collection.
+   CGuard::enterCS(m_ControlLock);
+
+   s->m_Status = CUDTSocket::CLOSED;
+
+   m_Sockets.erase(s->m_SocketID);
+   m_ClosedSockets[s->m_SocketID] = s;
+
+   if (0 != s->m_ListenSocket)
+   {
+      // if it is an accepted socket, remove it from the listener's queue
+      map<UDTSOCKET, CUDTSocket*>::iterator ls = m_Sockets.find(s->m_ListenSocket);
+      if (ls != m_Sockets.end())
+      {
+         CGuard::enterCS(ls->second->m_AcceptLock);
+         ls->second->m_pAcceptSockets->erase(s->m_SocketID);
+         CGuard::leaveCS(ls->second->m_AcceptLock);
+      }
+   }
+
+   CGuard::leaveCS(m_ControlLock);
+
+   // broadcast all "accept" waiting
+   if (CUDTSocket::LISTENING == os)
+   {
+      #ifndef WIN32
+         pthread_mutex_lock(&(s->m_AcceptLock));
+         pthread_mutex_unlock(&(s->m_AcceptLock));
+         pthread_cond_broadcast(&(s->m_AcceptCond));
+      #else
+         SetEvent(s->m_AcceptCond);
+      #endif
+   }
+
+   CTimer::triggerEvent();
+
+   return 0;
+}
+
+int CUDTUnited::getpeername(const UDTSOCKET u, sockaddr* name, int* namelen)
+{
+   if (CUDTSocket::CONNECTED != getStatus(u))
+      throw CUDTException(2, 2, 0);
+
+   CUDTSocket* s = locate(u);
+
+   if (NULL == s)
+      throw CUDTException(5, 4, 0);
+
+   if (!s->m_pUDT->m_bConnected || s->m_pUDT->m_bBroken)
+      throw CUDTException(2, 2, 0);
+
+   if (AF_INET == s->m_iIPversion)
+      *namelen = sizeof(sockaddr_in);
+   else
+      *namelen = sizeof(sockaddr_in6);
+
+   // copy address information of peer node
+   memcpy(name, s->m_pPeerAddr, *namelen);
+
+   return 0;
+}
+
+int CUDTUnited::getsockname(const UDTSOCKET u, sockaddr* name, int* namelen)
+{
+   CUDTSocket* s = locate(u);
+
+   if (NULL == s)
+      throw CUDTException(5, 4, 0);
+
+   if (CUDTSocket::INIT == s->m_Status)
+      throw CUDTException(2, 2, 0);
+
+   if (AF_INET == s->m_iIPversion)
+      *namelen = sizeof(sockaddr_in);
+   else
+      *namelen = sizeof(sockaddr_in6);
+
+   // copy address information of local node
+   memcpy(name, s->m_pSelfAddr, *namelen);
+
+   return 0;
+}
+
+int CUDTUnited::select(ud_set* readfds, ud_set* writefds, ud_set* exceptfds, const timeval* timeout)
+{
+   uint64_t entertime = CTimer::getTime();
+
+   uint64_t to;
+   if (NULL == timeout)
+      to = 0xFFFFFFFFFFFFFFFFULL;
+   else
+      to = timeout->tv_sec * 1000000 + timeout->tv_usec;
+
+   // initialize results
+   int count = 0;
+   set<UDTSOCKET> rs, ws, es;
+
+   // retrieve related UDT sockets
+   vector<CUDTSocket*> ru, wu, eu;
+   CUDTSocket* s;
+   if (NULL != readfds)
+      for (set<UDTSOCKET>::iterator i1 = readfds->begin(); i1 != readfds->end(); ++ i1)
+      {
+         if (CUDTSocket::BROKEN == getStatus(*i1))
+         {
+            rs.insert(*i1);
+            ++ count;
+         }
+         else if (NULL == (s = locate(*i1)))
+            throw CUDTException(5, 4, 0);
+         else
+            ru.insert(ru.end(), s);
+      }
+   if (NULL != writefds)
+      for (set<UDTSOCKET>::iterator i2 = writefds->begin(); i2 != writefds->end(); ++ i2)
+      {
+         if (CUDTSocket::BROKEN == getStatus(*i2))
+         {
+            ws.insert(*i2);
+            ++ count;
+         }
+         else if (NULL == (s = locate(*i2)))
+            throw CUDTException(5, 4, 0);
+         else
+            wu.insert(wu.end(), s);
+      }
+   if (NULL != exceptfds)
+      for (set<UDTSOCKET>::iterator i3 = exceptfds->begin(); i3 != exceptfds->end(); ++ i3)
+      {
+         if (CUDTSocket::BROKEN == getStatus(*i3))
+         {
+            es.insert(*i3);
+            ++ count;
+         }
+         else if (NULL == (s = locate(*i3)))
+            throw CUDTException(5, 4, 0);
+         else
+            eu.insert(eu.end(), s);
+      }
+
+   do
+   {
+      // query read sockets
+      for (vector<CUDTSocket*>::iterator j1 = ru.begin(); j1 != ru.end(); ++ j1)
+      {
+         s = *j1;
+
+         if ((s->m_pUDT->m_bConnected && (s->m_pUDT->m_pRcvBuffer->getRcvDataSize() > 0) && ((s->m_pUDT->m_iSockType == UDT_STREAM) || (s->m_pUDT->m_pRcvBuffer->getRcvMsgNum() > 0)))
+            || (!s->m_pUDT->m_bListening && (s->m_pUDT->m_bBroken || !s->m_pUDT->m_bConnected))
+            || (s->m_pUDT->m_bListening && (s->m_pQueuedSockets->size() > 0))
+            || (s->m_Status == CUDTSocket::CLOSED))
+         {
+            rs.insert(s->m_SocketID);
+            ++ count;
+         }
+      }
+
+      // query write sockets
+      for (vector<CUDTSocket*>::iterator j2 = wu.begin(); j2 != wu.end(); ++ j2)
+      {
+         s = *j2;
+
+         if ((s->m_pUDT->m_bConnected && (s->m_pUDT->m_pSndBuffer->getCurrBufSize() < s->m_pUDT->m_iSndBufSize))
+            || s->m_pUDT->m_bBroken || !s->m_pUDT->m_bConnected || (s->m_Status == CUDTSocket::CLOSED))
+         {
+            ws.insert(s->m_SocketID);
+            ++ count;
+         }
+      }
+
+      // query exceptions on sockets
+      for (vector<CUDTSocket*>::iterator j3 = eu.begin(); j3 != eu.end(); ++ j3)
+      {
+         // check connection request status, not supported now
+      }
+
+      if (0 < count)
+         break;
+
+      CTimer::waitForEvent();
+   } while (to > CTimer::getTime() - entertime);
+
+   if (NULL != readfds)
+      *readfds = rs;
+
+   if (NULL != writefds)
+      *writefds = ws;
+
+   if (NULL != exceptfds)
+      *exceptfds = es;
+
+   return count;
+}
+
+CUDTSocket* CUDTUnited::locate(const UDTSOCKET u)
+{
+   CGuard cg(m_ControlLock);
+
+   map<UDTSOCKET, CUDTSocket*>::iterator i = m_Sockets.find(u);
+
+   if ( (i == m_Sockets.end()) || (i->second->m_Status == CUDTSocket::CLOSED)) {
+      if (i == m_Sockets.end()) {
+        printf("socket not found\n");
+      } else {
+        printf("socket status = CUDTSocket::CLOSED\n");
+      }
+      return NULL;
+   }
+
+   return i->second;
+}
+
+CUDTSocket* CUDTUnited::locate(const UDTSOCKET u, const sockaddr* peer, const UDTSOCKET& id, const int32_t& isn)
+{
+   CGuard cg(m_ControlLock);
+
+   map<UDTSOCKET, CUDTSocket*>::iterator i = m_Sockets.find(u);
+
+   CGuard ag(i->second->m_AcceptLock);
+
+   // look up the "peer" address in queued sockets set
+   for (set<UDTSOCKET>::iterator j1 = i->second->m_pQueuedSockets->begin(); j1 != i->second->m_pQueuedSockets->end(); ++ j1)
+   {
+      map<UDTSOCKET, CUDTSocket*>::iterator k1 = m_Sockets.find(*j1);
+      // this socket might have been closed and moved m_ClosedSockets
+      if (k1 == m_Sockets.end())
+         continue;
+
+      if (CIPAddress::ipcmp(peer, k1->second->m_pPeerAddr, i->second->m_iIPversion))
+      {
+         if ((id == k1->second->m_PeerID) && (isn == k1->second->m_iISN))
+            return k1->second;
+      }
+   }
+
+   // look up the "peer" address in accept sockets set
+   for (set<UDTSOCKET>::iterator j2 = i->second->m_pAcceptSockets->begin(); j2 != i->second->m_pAcceptSockets->end(); ++ j2)
+   {
+      map<UDTSOCKET, CUDTSocket*>::iterator k2 = m_Sockets.find(*j2);
+      // this socket might have been closed and moved m_ClosedSockets
+      if (k2 == m_Sockets.end())
+         continue;
+
+      if (CIPAddress::ipcmp(peer, k2->second->m_pPeerAddr, i->second->m_iIPversion))
+      {
+         if ((id == k2->second->m_PeerID) && (isn == k2->second->m_iISN))
+            return k2->second;
+      }
+   }
+
+   return NULL;
+}
+
+void CUDTUnited::checkBrokenSockets()
+{
+   CGuard cg(m_ControlLock);
+
+   // set of sockets To Be Closed and To Be Removed
+   set<UDTSOCKET> tbc;
+   set<UDTSOCKET> tbr;
+
+   for (map<UDTSOCKET, CUDTSocket*>::iterator i = m_Sockets.begin(); i != m_Sockets.end(); ++ i)
+   {
+      // check broken connection
+      if (i->second->m_pUDT->m_bBroken)
+      {
+         // if there is still data in the receiver buffer, wait longer
+         if ((i->second->m_pUDT->m_pRcvBuffer->getRcvDataSize() > 0) && (i->second->m_pUDT->m_iBrokenCounter -- > 0))
+            continue;
+
+         //close broken connections and start removal timer
+         i->second->m_Status = CUDTSocket::CLOSED;
+         i->second->m_TimeStamp = CTimer::getTime();
+         tbc.insert(i->first);
+         m_ClosedSockets[i->first] = i->second;
+
+         // remove from listener's queue
+         map<UDTSOCKET, CUDTSocket*>::iterator ls = m_Sockets.find(i->second->m_ListenSocket);
+         if (ls != m_Sockets.end())
+         {
+            CGuard::enterCS(ls->second->m_AcceptLock);
+            ls->second->m_pQueuedSockets->erase(i->second->m_SocketID);
+            ls->second->m_pAcceptSockets->erase(i->second->m_SocketID);
+            CGuard::leaveCS(ls->second->m_AcceptLock);
+         }
+      }
+   }
+
+   for (map<UDTSOCKET, CUDTSocket*>::iterator j = m_ClosedSockets.begin(); j != m_ClosedSockets.end(); ++ j)
+   {
+      // timeout 1 second to destroy a socket AND it has been removed from RcvUList
+      if ((CTimer::getTime() - j->second->m_TimeStamp > 1000000) && ((NULL == j->second->m_pUDT->m_pRNode) || !j->second->m_pUDT->m_pRNode->m_bOnList))
+         tbr.insert(j->first);
+
+      // sockets cannot be removed here because it will invalidate the map iterator
+   }
+
+   // move closed sockets to the ClosedSockets structure
+   for (set<UDTSOCKET>::iterator k = tbc.begin(); k != tbc.end(); ++ k)
+      m_Sockets.erase(*k);
+
+   // remove those timeout sockets
+   for (set<UDTSOCKET>::iterator l = tbr.begin(); l != tbr.end(); ++ l)
+      removeSocket(*l);
+}
+
+void CUDTUnited::removeSocket(const UDTSOCKET u)
+{
+   map<UDTSOCKET, CUDTSocket*>::iterator i = m_ClosedSockets.find(u);
+
+   // invalid socket ID
+   if (i == m_ClosedSockets.end())
+      return;
+
+   // decrease multiplexer reference count, and remove it if necessary
+   int port;
+   if (AF_INET == i->second->m_iIPversion)
+      port = ntohs(((sockaddr_in*)(i->second->m_pSelfAddr))->sin_port);
+   else
+      port = ntohs(((sockaddr_in6*)(i->second->m_pSelfAddr))->sin6_port);
+
+   vector<CMultiplexer>::iterator m;
+   for (m = m_vMultiplexer.begin(); m != m_vMultiplexer.end(); ++ m)
+      if (port == m->m_iPort)
+         break;
+
+   if (NULL != i->second->m_pQueuedSockets)
+   {
+      CGuard::enterCS(i->second->m_AcceptLock);
+
+      // if it is a listener, close all un-accepted sockets in its queue and remove them later
+      set<UDTSOCKET> tbc;
+      for (set<UDTSOCKET>::iterator q = i->second->m_pQueuedSockets->begin(); q != i->second->m_pQueuedSockets->end(); ++ q)
+      {
+         m_Sockets[*q]->m_pUDT->close();
+         m_Sockets[*q]->m_TimeStamp = CTimer::getTime();
+         m_Sockets[*q]->m_Status = CUDTSocket::CLOSED;
+	 tbc.insert(*q);
+         m_ClosedSockets[*q] = m_Sockets[*q];
+      }
+      for (set<UDTSOCKET>::iterator c = tbc.begin(); c != tbc.end(); ++ c)
+         m_Sockets.erase(*c);
+
+      CGuard::leaveCS(i->second->m_AcceptLock);
+   }
+
+   // delete this one
+   i->second->m_pUDT->close();
+   delete m_ClosedSockets[u];
+   m_ClosedSockets.erase(u);
+
+   if (m == m_vMultiplexer.end())
+      return;
+
+   m->m_iRefCount --;
+   if (0 == m->m_iRefCount)
+   {
+      m->m_pChannel->close();
+      delete m->m_pSndQueue;
+      delete m->m_pRcvQueue;
+      delete m->m_pTimer;
+      delete m->m_pChannel;
+      m_vMultiplexer.erase(m);
+   }
+}
+
+void CUDTUnited::setError(CUDTException* e)
+{
+   #ifndef WIN32
+      delete (CUDTException*)pthread_getspecific(m_TLSError);
+      pthread_setspecific(m_TLSError, e);
+   #else
+      CGuard tg(m_TLSLock);
+      delete (CUDTException*)TlsGetValue(m_TLSError);
+      TlsSetValue(m_TLSError, e);
+      m_mTLSRecord[GetCurrentThreadId()] = e;
+   #endif
+}
+
+CUDTException* CUDTUnited::getError()
+{
+   #ifndef WIN32
+      if(NULL == pthread_getspecific(m_TLSError))
+         pthread_setspecific(m_TLSError, new CUDTException);
+      return (CUDTException*)pthread_getspecific(m_TLSError);
+   #else
+      CGuard tg(m_TLSLock);
+      if(NULL == TlsGetValue(m_TLSError))
+      {
+         CUDTException* e = new CUDTException;
+         TlsSetValue(m_TLSError, e);
+         m_mTLSRecord[GetCurrentThreadId()] = e;
+      }
+      return (CUDTException*)TlsGetValue(m_TLSError);
+   #endif
+}
+
+#ifdef WIN32
+void CUDTUnited::checkTLSValue()
+{
+   CGuard tg(m_TLSLock);
+
+   vector<DWORD> tbr;
+   for (map<DWORD, CUDTException*>::iterator i = m_mTLSRecord.begin(); i != m_mTLSRecord.end(); ++ i)
+   {
+      HANDLE h = OpenThread(THREAD_QUERY_INFORMATION, FALSE, i->first);
+      if (NULL == h)
+      {
+         tbr.insert(tbr.end(), i->first);
+         break;
+      }
+      if (WAIT_OBJECT_0 == WaitForSingleObject(h, 0))
+      {
+         delete i->second;
+         tbr.insert(tbr.end(), i->first);
+      }
+      CloseHandle(h);
+   }
+   for (vector<DWORD>::iterator j = tbr.begin(); j != tbr.end(); ++ j)
+      m_mTLSRecord.erase(*j);
+}
+#endif
+
+void CUDTUnited::updateMux(CUDT* u, const sockaddr* addr, const UDPSOCKET* udpsock)
+{
+   CGuard cg(m_ControlLock);
+
+   if ((u->m_bReuseAddr) && (NULL != addr))
+   {
+      int port = (AF_INET == u->m_iIPversion) ? ntohs(((sockaddr_in*)addr)->sin_port) : ntohs(((sockaddr_in6*)addr)->sin6_port);
+
+      // find a reusable address
+      for (vector<CMultiplexer>::iterator i = m_vMultiplexer.begin(); i != m_vMultiplexer.end(); ++ i)
+      {
+         if ((i->m_iIPversion == u->m_iIPversion) && (i->m_iMSS == u->m_iMSS) && i->m_bReusable)
+         {
+            if (i->m_iPort == port)
+            {
+               // reuse the existing multiplexer
+               ++ i->m_iRefCount;
+               u->m_pSndQueue = i->m_pSndQueue;
+               u->m_pRcvQueue = i->m_pRcvQueue;
+               return;
+            }
+         }
+      }
+   }
+
+   // a new multiplexer is needed
+   CMultiplexer m;
+   m.m_iMSS = u->m_iMSS;
+   m.m_iIPversion = u->m_iIPversion;
+   m.m_iRefCount = 1;
+   m.m_bReusable = u->m_bReuseAddr;
+
+   m.m_pChannel = new CChannel(u->m_iIPversion);
+   m.m_pChannel->setSndBufSize(u->m_iUDPSndBufSize);
+   m.m_pChannel->setRcvBufSize(u->m_iUDPRcvBufSize);
+
+   try
+   {
+      if (NULL != udpsock)
+         m.m_pChannel->open(*udpsock);
+      else
+         m.m_pChannel->open(addr);
+   }
+   catch (CUDTException& e)
+   {
+      m.m_pChannel->close();
+      delete m.m_pChannel;
+      throw e;
+   }
+
+   sockaddr* sa = (AF_INET == u->m_iIPversion) ? (sockaddr*) new sockaddr_in : (sockaddr*) new sockaddr_in6;
+   m.m_pChannel->getSockAddr(sa);
+   m.m_iPort = (AF_INET == u->m_iIPversion) ? ntohs(((sockaddr_in*)sa)->sin_port) : ntohs(((sockaddr_in6*)sa)->sin6_port);
+   if (AF_INET == u->m_iIPversion) delete (sockaddr_in*)sa; else delete (sockaddr_in6*)sa;
+
+   m.m_pTimer = new CTimer;
+
+   m.m_pSndQueue = new CSndQueue;
+   m.m_pSndQueue->init(m.m_pChannel, m.m_pTimer);
+   m.m_pRcvQueue = new CRcvQueue;
+   m.m_pRcvQueue->init(32, u->m_iPayloadSize, m.m_iIPversion, 1024, m.m_pChannel, m.m_pTimer);
+
+   m_vMultiplexer.insert(m_vMultiplexer.end(), m);
+
+   u->m_pSndQueue = m.m_pSndQueue;
+   u->m_pRcvQueue = m.m_pRcvQueue;
+}
+
+void CUDTUnited::updateMux(CUDT* u, const CUDTSocket* ls)
+{
+   CGuard cg(m_ControlLock);
+
+   int port = (AF_INET == ls->m_iIPversion) ? ntohs(((sockaddr_in*)ls->m_pSelfAddr)->sin_port) : ntohs(((sockaddr_in6*)ls->m_pSelfAddr)->sin6_port);
+
+   // find the listener's address
+   for (vector<CMultiplexer>::iterator i = m_vMultiplexer.begin(); i != m_vMultiplexer.end(); ++ i)
+   {
+      if (i->m_iPort == port)
+      {
+         // reuse the existing multiplexer
+         ++ i->m_iRefCount;
+         u->m_pSndQueue = i->m_pSndQueue;
+         u->m_pRcvQueue = i->m_pRcvQueue;
+         return;
+      }
+   }
+}
+
+#ifndef WIN32
+   void* CUDTUnited::garbageCollect(void* p)
+#else
+   DWORD WINAPI CUDTUnited::garbageCollect(LPVOID p)
+#endif
+{
+   CUDTUnited* self = (CUDTUnited*)p;
+
+   while (!self->m_bClosing)
+   {
+      self->checkBrokenSockets();
+
+      #ifdef WIN32
+         self->checkTLSValue();
+      #endif
+
+      #ifndef WIN32
+         timeval now;
+         timespec timeout;
+         gettimeofday(&now, 0);
+         timeout.tv_sec = now.tv_sec + 1;
+         timeout.tv_nsec = now.tv_usec * 1000;
+
+         pthread_cond_timedwait(&self->m_GCStopCond, &self->m_GCStopLock, &timeout);
+      #else
+         WaitForSingleObject(self->m_GCStopCond, 1000);
+      #endif
+   }
+
+   // remove sockets and multiplpexers
+   for (map<UDTSOCKET, CUDTSocket*>::iterator i = self->m_Sockets.begin(); i != self->m_Sockets.end(); ++ i)
+   {
+      i->second->m_pUDT->close();
+      i->second->m_Status = CUDTSocket::CLOSED;
+      i->second->m_TimeStamp = 0;
+      self->m_ClosedSockets[i->first] = i->second;
+   }
+     self->m_ClosedSockets = self->m_Sockets;
+     self->m_Sockets.clear();
+   self->checkBrokenSockets();
+for (vector<CMultiplexer>::iterator m = self->m_vMultiplexer.begin(); m != self->m_vMultiplexer.end(); ++ m) {
+	     m->m_pChannel->close();
+	     delete m->m_pSndQueue;
+	     delete m->m_pRcvQueue;
+	     delete m->m_pTimer;
+	     delete m->m_pChannel;
+}
+self->m_vMultiplexer.clear();
+for (map<UDTSOCKET, CUDTSocket*>::iterator c = self->m_ClosedSockets.begin(); c != self->m_ClosedSockets.end(); ++ c) {
+	delete c->second;
+}
+self->m_ClosedSockets.clear();
+
+   #ifndef WIN32
+      return NULL;
+   #else
+      return 0;
+   #endif
+}
+
+////////////////////////////////////////////////////////////////////////////////
+
+int CUDT::startup()
+{
+   return s_UDTUnited.startup();
+}
+
+int CUDT::cleanup()
+{
+   return s_UDTUnited.cleanup();
+}
+
+UDTSOCKET CUDT::socket(int af, int type, int)
+{
+   if (!s_UDTUnited.m_bGCStatus)
+      s_UDTUnited.startup();
+
+   try
+   {
+      return s_UDTUnited.newSocket(af, type);
+   }
+   catch (CUDTException& e)
+   {
+      s_UDTUnited.setError(new CUDTException(e));
+      return INVALID_SOCK;
+   }
+   catch (bad_alloc&)
+   {
+      s_UDTUnited.setError(new CUDTException(3, 2, 0));
+      return INVALID_SOCK;
+   }
+   catch (...)
+   {
+      s_UDTUnited.setError(new CUDTException(-1, 0, 0));
+      return INVALID_SOCK;
+   }
+}
+
+int CUDT::bind(UDTSOCKET u, const sockaddr* name, int namelen)
+{
+   try
+   {
+      return s_UDTUnited.bind(u, name, namelen);
+   }
+   catch (CUDTException& e)
+   {
+      s_UDTUnited.setError(new CUDTException(e));
+      return ERROR;
+   }
+   catch (bad_alloc&)
+   {
+      s_UDTUnited.setError(new CUDTException(3, 2, 0));
+      return ERROR;
+   }
+   catch (...)
+   {
+      s_UDTUnited.setError(new CUDTException(-1, 0, 0));
+      return ERROR;
+   }
+}
+
+int CUDT::bind(UDTSOCKET u, UDPSOCKET udpsock)
+{
+   try
+   {
+      return s_UDTUnited.bind(u, udpsock);
+   }
+   catch (CUDTException& e)
+   {
+      s_UDTUnited.setError(new CUDTException(e));
+      return ERROR;
+   }
+   catch (bad_alloc&)
+   {
+      s_UDTUnited.setError(new CUDTException(3, 2, 0));
+      return ERROR;
+   }
+   catch (...)
+   {
+      s_UDTUnited.setError(new CUDTException(-1, 0, 0));
+      return ERROR;
+   }
+}
+
+int CUDT::listen(UDTSOCKET u, int backlog)
+{
+   try
+   {
+      return s_UDTUnited.listen(u, backlog);
+   }
+   catch (CUDTException& e)
+   {
+      s_UDTUnited.setError(new CUDTException(e));
+      return ERROR;
+   }
+   catch (bad_alloc&)
+   {
+      s_UDTUnited.setError(new CUDTException(3, 2, 0));
+      return ERROR;
+   }
+   catch (...)
+   {
+      s_UDTUnited.setError(new CUDTException(-1, 0, 0));
+      return ERROR;
+   }
+}
+
+UDTSOCKET CUDT::accept(UDTSOCKET u, sockaddr* addr, int* addrlen)
+{
+   try
+   {
+      return s_UDTUnited.accept(u, addr, addrlen);
+   }
+   catch (CUDTException& e)
+   {
+      s_UDTUnited.setError(new CUDTException(e));
+      return INVALID_SOCK;
+   }
+   catch (...)
+   {
+      s_UDTUnited.setError(new CUDTException(-1, 0, 0));
+      return INVALID_SOCK;
+   }
+}
+
+int CUDT::connect(UDTSOCKET u, const sockaddr* name, int namelen)
+{
+   try
+   {
+      return s_UDTUnited.connect(u, name, namelen);
+   }
+   catch (CUDTException e)
+   {
+      s_UDTUnited.setError(new CUDTException(e));
+      return ERROR;
+   }
+   catch (bad_alloc&)
+   {
+      s_UDTUnited.setError(new CUDTException(3, 2, 0));
+      return ERROR;
+   }
+   catch (...)
+   {
+      s_UDTUnited.setError(new CUDTException(-1, 0, 0));
+      return ERROR;
+   }
+}
+
+int CUDT::close(UDTSOCKET u)
+{
+   try
+   {
+      return s_UDTUnited.close(u);
+   }
+   catch (CUDTException e)
+   {
+      s_UDTUnited.setError(new CUDTException(e));
+      return ERROR;
+   }
+   catch (...)
+   {
+      s_UDTUnited.setError(new CUDTException(-1, 0, 0));
+      return ERROR;
+   }
+}
+
+int CUDT::getpeername(UDTSOCKET u, sockaddr* name, int* namelen)
+{
+   try
+   {
+      return s_UDTUnited.getpeername(u, name, namelen);
+   }
+   catch (CUDTException e)
+   {
+      s_UDTUnited.setError(new CUDTException(e));
+      return ERROR;
+   }
+   catch (...)
+   {
+      s_UDTUnited.setError(new CUDTException(-1, 0, 0));
+      return ERROR;
+   }
+}
+
+int CUDT::getsockname(UDTSOCKET u, sockaddr* name, int* namelen)
+{
+   try
+   {
+      return s_UDTUnited.getsockname(u, name, namelen);;
+   }
+   catch (CUDTException e)
+   {
+      s_UDTUnited.setError(new CUDTException(e));
+      return ERROR;
+   }
+   catch (...)
+   {
+      s_UDTUnited.setError(new CUDTException(-1, 0, 0));
+      return ERROR;
+   }
+}
+
+int CUDT::getsockopt(UDTSOCKET u, int, UDTOpt optname, void* optval, int* optlen)
+{
+   try
+   {
+      CUDT* udt = s_UDTUnited.lookup(u);
+      udt->getOpt(optname, optval, *optlen);
+      return 0;
+   }
+   catch (CUDTException e)
+   {
+      s_UDTUnited.setError(new CUDTException(e));
+      return ERROR;
+   }
+   catch (...)
+   {
+      s_UDTUnited.setError(new CUDTException(-1, 0, 0));
+      return ERROR;
+   }
+}
+
+int CUDT::setsockopt(UDTSOCKET u, int, UDTOpt optname, const void* optval, int optlen)
+{
+   try
+   {
+      CUDT* udt = s_UDTUnited.lookup(u);
+      udt->setOpt(optname, optval, optlen);
+      return 0;
+   }
+   catch (CUDTException e)
+   {
+      s_UDTUnited.setError(new CUDTException(e));
+      return ERROR;
+   }
+   catch (...)
+   {
+      s_UDTUnited.setError(new CUDTException(-1, 0, 0));
+      return ERROR;
+   }
+}
+
+int CUDT::send(UDTSOCKET u, const char* buf, int len, int)
+{
+   try
+   {
+      CUDT* udt = s_UDTUnited.lookup(u);
+      return udt->send((char*)buf, len);
+   }
+   catch (CUDTException e)
+   {
+      s_UDTUnited.setError(new CUDTException(e));
+      return ERROR;
+   }
+   catch (bad_alloc&)
+   {
+      s_UDTUnited.setError(new CUDTException(3, 2, 0));
+      return ERROR;
+   }
+   catch (...)
+   {
+      s_UDTUnited.setError(new CUDTException(-1, 0, 0));
+      return ERROR;
+   }
+}
+
+int CUDT::recv(UDTSOCKET u, char* buf, int len, int)
+{
+   try
+   {
+      CUDT* udt = s_UDTUnited.lookup(u);
+      return udt->recv(buf, len);
+   }
+   catch (CUDTException e)
+   {
+      s_UDTUnited.setError(new CUDTException(e));
+      return ERROR;
+   }
+   catch (...)
+   {
+      s_UDTUnited.setError(new CUDTException(-1, 0, 0));
+      return ERROR;
+   }
+}
+
+int CUDT::sendmsg(UDTSOCKET u, const char* buf, int len, int ttl, bool inorder)
+{
+   try
+   {
+      CUDT* udt = s_UDTUnited.lookup(u);
+      return udt->sendmsg((char*)buf, len, ttl, inorder);
+   }
+   catch (CUDTException e)
+   {
+      s_UDTUnited.setError(new CUDTException(e));
+      return ERROR;
+   }
+   catch (bad_alloc&)
+   {
+      s_UDTUnited.setError(new CUDTException(3, 2, 0));
+      return ERROR;
+   }
+   catch (...)
+   {
+      s_UDTUnited.setError(new CUDTException(-1, 0, 0));
+      return ERROR;
+   }
+}
+
+int CUDT::recvmsg(UDTSOCKET u, char* buf, int len)
+{
+   try
+   {
+      CUDT* udt = s_UDTUnited.lookup(u);
+      return udt->recvmsg(buf, len);
+   }
+   catch (CUDTException e)
+   {
+      s_UDTUnited.setError(new CUDTException(e));
+      return ERROR;
+   }
+   catch (...)
+   {
+      s_UDTUnited.setError(new CUDTException(-1, 0, 0));
+      return ERROR;
+   }
+}
+
+int64_t CUDT::sendfile(UDTSOCKET u, ifstream& ifs, const int64_t& offset, const int64_t& size, const int& block)
+{
+   try
+   {
+      CUDT* udt = s_UDTUnited.lookup(u);
+      return udt->sendfile(ifs, offset, size, block);
+   }
+   catch (CUDTException e)
+   {
+      s_UDTUnited.setError(new CUDTException(e));
+      return ERROR;
+   }
+   catch (bad_alloc&)
+   {
+      s_UDTUnited.setError(new CUDTException(3, 2, 0));
+      return ERROR;
+   }
+   catch (...)
+   {
+      s_UDTUnited.setError(new CUDTException(-1, 0, 0));
+      return ERROR;
+   }
+}
+
+int64_t CUDT::recvfile(UDTSOCKET u, ofstream& ofs, const int64_t& offset, const int64_t& size, const int& block)
+{
+   try
+   {
+      CUDT* udt = s_UDTUnited.lookup(u);
+      return udt->recvfile(ofs, offset, size, block);
+   }
+   catch (CUDTException e)
+   {
+      s_UDTUnited.setError(new CUDTException(e));
+      return ERROR;
+   }
+   catch (...)
+   {
+      s_UDTUnited.setError(new CUDTException(-1, 0, 0));
+      return ERROR;
+   }
+}
+
+int CUDT::select(int, ud_set* readfds, ud_set* writefds, ud_set* exceptfds, const timeval* timeout)
+{
+   if ((NULL == readfds) && (NULL == writefds) && (NULL == exceptfds))
+   {
+      s_UDTUnited.setError(new CUDTException(5, 3, 0));
+      return ERROR;
+   }
+
+   try
+   {
+      return s_UDTUnited.select(readfds, writefds, exceptfds, timeout);
+   }
+   catch (CUDTException e)
+   {
+      s_UDTUnited.setError(new CUDTException(e));
+      return ERROR;
+   }
+   catch (bad_alloc&)
+   {
+      s_UDTUnited.setError(new CUDTException(3, 2, 0));
+      return ERROR;
+   }
+   catch (...)
+   {
+      s_UDTUnited.setError(new CUDTException(-1, 0, 0));
+      return ERROR;
+   }
+}
+
+CUDTException& CUDT::getlasterror()
+{
+   return *s_UDTUnited.getError();
+}
+
+int CUDT::perfmon(UDTSOCKET u, CPerfMon* perf, bool clear)
+{
+   try
+   {
+      CUDT* udt = s_UDTUnited.lookup(u);
+      udt->sample(perf, clear);
+      return 0;
+   }
+   catch (CUDTException e)
+   {
+      s_UDTUnited.setError(new CUDTException(e));
+      return ERROR;
+   }
+   catch (...)
+   {
+      s_UDTUnited.setError(new CUDTException(-1, 0, 0));
+      return ERROR;
+   }
+}
+
+CUDT* CUDT::getUDTHandle(UDTSOCKET u)
+{
+   return s_UDTUnited.lookup(u);
+}
+
+////////////////////////////////////////////////////////////////////////////////
+
+namespace UDT
+{
+
+int startup()
+{
+   return CUDT::startup();
+}
+
+int cleanup()
+{
+   return CUDT::cleanup();
+}
+
+UDTSOCKET socket(int af, int type, int protocol)
+{
+   return CUDT::socket(af, type, protocol);
+}
+
+int bind(UDTSOCKET u, const struct sockaddr* name, int namelen)
+{
+   return CUDT::bind(u, name, namelen);
+}
+
+int bind(UDTSOCKET u, UDPSOCKET udpsock)
+{
+   return CUDT::bind(u, udpsock);
+}
+
+int listen(UDTSOCKET u, int backlog)
+{
+   return CUDT::listen(u, backlog);
+}
+
+UDTSOCKET accept(UDTSOCKET u, struct sockaddr* addr, int* addrlen)
+{
+   return CUDT::accept(u, addr, addrlen);
+}
+
+int connect(UDTSOCKET u, const struct sockaddr* name, int namelen)
+{
+   return CUDT::connect(u, name, namelen);
+}
+
+int close(UDTSOCKET u)
+{
+   return CUDT::close(u);
+}
+
+int getpeername(UDTSOCKET u, struct sockaddr* name, int* namelen)
+{
+   return CUDT::getpeername(u, name, namelen);
+}
+
+int getsockname(UDTSOCKET u, struct sockaddr* name, int* namelen)
+{
+   return CUDT::getsockname(u, name, namelen);
+}
+
+int getsockopt(UDTSOCKET u, int level, SOCKOPT optname, void* optval, int* optlen)
+{
+   return CUDT::getsockopt(u, level, optname, optval, optlen);
+}
+
+int setsockopt(UDTSOCKET u, int level, SOCKOPT optname, const void* optval, int optlen)
+{
+   return CUDT::setsockopt(u, level, optname, optval, optlen);
+}
+
+int send(UDTSOCKET u, const char* buf, int len, int flags)
+{
+   return CUDT::send(u, buf, len, flags);
+}
+
+int recv(UDTSOCKET u, char* buf, int len, int flags)
+{
+   return CUDT::recv(u, buf, len, flags);
+}
+
+int sendmsg(UDTSOCKET u, const char* buf, int len, int ttl, bool inorder)
+{
+   return CUDT::sendmsg(u, buf, len, ttl, inorder);
+}
+
+int recvmsg(UDTSOCKET u, char* buf, int len)
+{
+   return CUDT::recvmsg(u, buf, len);
+}
+
+int64_t sendfile(UDTSOCKET u, ifstream& ifs, int64_t offset, int64_t size, int block)
+{
+   return CUDT::sendfile(u, ifs, offset, size, block);
+}
+
+int64_t recvfile(UDTSOCKET u, ofstream& ofs, int64_t offset, int64_t size, int block)
+{
+   return CUDT::recvfile(u, ofs, offset, size, block);
+}
+
+int select(int nfds, UDSET* readfds, UDSET* writefds, UDSET* exceptfds, const struct timeval* timeout)
+{
+   return CUDT::select(nfds, readfds, writefds, exceptfds, timeout);
+}
+
+ERRORINFO& getlasterror()
+{
+   return CUDT::getlasterror();
+}
+
+int perfmon(UDTSOCKET u, TRACEINFO* perf, bool clear)
+{
+   return CUDT::perfmon(u, perf, clear);
+}
+
+}
diff --git a/src/transport/buffer.cpp b/src/transport/buffer.cpp
index 4f0f10a..20dfd12 100644
--- a/src/transport/buffer.cpp
+++ b/src/transport/buffer.cpp
@@ -45,10 +45,12 @@ written by
 using namespace std;
 
 CSndBuffer::CSndBuffer(const int& size, const int& mss):
-m_pBlock(NULL),
-m_pFirstBlock(NULL),
-m_pCurrBlock(NULL),
-m_pLastBlock(NULL),
+m_BufLock(),
+m_pBlock(),
+m_pFirstBlock(),
+m_pCurrBlock(),
+m_pLastBlock(),
+m_pBuffer(),
 m_iNextMsgNo(0),
 m_iSize(size),
 m_iMSS(mss),
@@ -370,7 +372,7 @@ int CRcvBuffer::addData(CUnit* unit, int offset)
 
    if (NULL != m_pUnit[pos])
       return -1;
-   
+
    m_pUnit[pos] = unit;
 
    unit->m_iFlag = 1;
diff --git a/src/transport/ccc.cpp b/src/transport/ccc.cpp
index 6ace995..5838eb6 100644
--- a/src/transport/ccc.cpp
+++ b/src/transport/ccc.cpp
@@ -48,12 +48,20 @@ CCC::CCC():
 m_iSYNInterval(CUDT::m_iSYNInterval),
 m_dPktSndPeriod(1.0),
 m_dCWndSize(16.0),
-m_pcParam(NULL),
+m_iBandwidth(),
+m_dMaxCWndSize(),
+m_iMSS(),
+m_iSndCurrSeqNo(),
+m_iRcvRate(),
+m_iRTT(),
+m_pcParam(),
 m_iPSize(0),
+m_UDT(),
 m_iACKPeriod(0),
 m_iACKInterval(0),
 m_bUserDefinedRTO(false),
-m_iRTO(-1)
+m_iRTO(-1),
+m_PerfInfo()
 {
 }
 
diff --git a/src/transport/ccc.h b/src/transport/ccc.h
index b290d8b..89a1955 100644
--- a/src/transport/ccc.h
+++ b/src/transport/ccc.h
@@ -253,6 +253,10 @@ public:
 class CUDTCC: public CCC
 {
 public:
+   CUDTCC(): m_iRCInterval(), m_LastRCTime(), m_bSlowStart(),
+   m_iLastAck(), m_bLoss(), m_iLastDecSeq(), m_dLastDecPeriod(),
+   m_iNAKCount(), m_iDecRandom(),
+   m_iAvgNAKNum(), m_iDecCount() {}
    virtual void init();
    virtual void onACK(const int32_t&);
    virtual void onLoss(const int32_t*, const int&);
diff --git a/src/transport/channel.cpp b/src/transport/channel.cpp
index 8f7ac8a..45b99fe 100644
--- a/src/transport/channel.cpp
+++ b/src/transport/channel.cpp
@@ -1,335 +1,337 @@
-/*****************************************************************************
-Copyright (c) 2001 - 2008, The Board of Trustees of the University of Illinois.
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-
-* Redistributions of source code must retain the above
-  copyright notice, this list of conditions and the
-  following disclaimer.
-
-* Redistributions in binary form must reproduce the
-  above copyright notice, this list of conditions
-  and the following disclaimer in the documentation
-  and/or other materials provided with the distribution.
-
-* Neither the name of the University of Illinois
-  nor the names of its contributors may be used to
-  endorse or promote products derived from this
-  software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
-THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
-CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
-EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
-PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-****************************************************************************/
-
-/****************************************************************************
-written by
-   Yunhong Gu, last updated 12/08/2008
-*****************************************************************************/
-
-#ifndef WIN32
-   #include <netdb.h>
-   #include <arpa/inet.h>
-   #include <unistd.h>
-   #include <fcntl.h>
-   #include <cstring>
-   #include <cstdio>
-   #include <cerrno>
-#else
-   #include <winsock2.h>
-   #include <ws2tcpip.h>
-#ifdef __MSVC__
-   #include <wspiapi.h>
-#endif
-#endif
-#include "channel.h"
-#include "packet.h"
-
-#ifdef WIN32
-   #define socklen_t int
-#endif
-
-#ifndef WIN32
-   #define NET_ERROR errno
-#else
-   #define NET_ERROR WSAGetLastError()
-#endif
-
-
-CChannel::CChannel():
-m_iIPversion(AF_INET),
-m_iSndBufSize(65536),
-m_iRcvBufSize(65536)
-{
-}
-
-CChannel::CChannel(const int& version):
-m_iIPversion(version),
-m_iSndBufSize(65536),
-m_iRcvBufSize(65536)
-{
-}
-
-CChannel::~CChannel()
-{
-}
-
-void CChannel::open(const sockaddr* addr)
-{
-   // construct an socket
-   m_iSocket = socket(m_iIPversion, SOCK_DGRAM, 0);
-   #ifdef WIN32
-      if (INVALID_SOCKET == m_iSocket)
-   #else
-      if (m_iSocket < 0)
-   #endif 
-     throw CUDTException(1, 0, NET_ERROR);
-
-   if (NULL != addr)
-   {
-      socklen_t namelen = (AF_INET == m_iIPversion) ? sizeof(sockaddr_in) : sizeof(sockaddr_in6);
-
-      if (0 != bind(m_iSocket, addr, namelen))
-         throw CUDTException(1, 3, NET_ERROR);
-   }
-   else
-   {
-      //sendto or WSASendTo will also automatically bind the socket
-      addrinfo hints;
-      addrinfo* res;
-
-      memset(&hints, 0, sizeof(struct addrinfo));
-
-      hints.ai_flags = AI_PASSIVE;
-      hints.ai_family = m_iIPversion;
-      hints.ai_socktype = SOCK_DGRAM;
-
-      if (0 != getaddrinfo(NULL, "0", &hints, &res))
-         throw CUDTException(1, 3, NET_ERROR);
-
-      if (0 != bind(m_iSocket, res->ai_addr, res->ai_addrlen))
-         throw CUDTException(1, 3, NET_ERROR);
-
-      freeaddrinfo(res);
-   }
-
-   setUDPSockOpt();
-}
-
-void CChannel::open(UDPSOCKET udpsock)
-{
-   m_iSocket = udpsock;
-   setUDPSockOpt();
-}
-
-void CChannel::setUDPSockOpt()
-{
-  #if defined(BSD) || defined(OSX)
-	// BSD system will fail setsockopt if the requested buffer size exceeds system maximum value
-     int maxsize = 262144;
-     if (0 != setsockopt(m_iSocket, SOL_SOCKET, SO_RCVBUF, (char*)&m_iRcvBufSize, sizeof(int)))
-	    setsockopt(m_iSocket, SOL_SOCKET, SO_RCVBUF, (char*)&maxsize, sizeof(int));
-     if (0 != setsockopt(m_iSocket, SOL_SOCKET, SO_SNDBUF, (char*)&m_iSndBufSize, sizeof(int))
-     setsockopt(m_iSocket, SOL_SOCKET, SO_SNDBUF, (char*)&maxsize, sizeof(int));#else
-     // for other systems, if requested is greated than maximum, the maximum value will be automactally used 
-	if ((0 != setsockopt(m_iSocket, SOL_SOCKET, SO_RCVBUF, (char *)&m_iRcvBufSize, sizeof(int))) ||
-       (0 != setsockopt(m_iSocket, SOL_SOCKET, SO_SNDBUF, (char *)&m_iSndBufSize, sizeof(int))))
-      throw CUDTException(1, 3, NET_ERROR);
-#endif
-   timeval tv;
-   tv.tv_sec = 0;
-   #if defined (BSD) || defined (OSX)
-      // Known BSD bug as the day I wrote this code.
-      // A small time out value will cause the socket to block forever.
-      tv.tv_usec = 10000;
-   #else
-      tv.tv_usec = 100;
-   #endif
-
-   #ifdef UNIX
-      // Set non-blocking I/O
-      // UNIX does not support SO_RCVTIMEO
-      int opts = fcntl(m_iSocket, F_GETFL);
-      if (-1 == fcntl(m_iSocket, F_SETFL, opts | O_NONBLOCK))
-         throw CUDTException(1, 3, NET_ERROR);
-   #elif WIN32
-      DWORD ot = 1; //milliseconds
-      if (setsockopt(m_iSocket, SOL_SOCKET, SO_RCVTIMEO, (char *)&ot, sizeof(DWORD)) < 0)
-         throw CUDTException(1, 3, NET_ERROR);
-   #else
-      // Set receiving time-out value
-      if (setsockopt(m_iSocket, SOL_SOCKET, SO_RCVTIMEO, (char *)&tv, sizeof(timeval)) < 0)
-         throw CUDTException(1, 3, NET_ERROR);
-   #endif
-}
-
-void CChannel::close() const
-{
-   #ifndef WIN32
-      ::close(m_iSocket);
-   #else
-      closesocket(m_iSocket);
-   #endif
-}
-
-int CChannel::getSndBufSize()
-{
-   socklen_t size = sizeof(socklen_t);
-
-   getsockopt(m_iSocket, SOL_SOCKET, SO_SNDBUF, (char *)&m_iSndBufSize, &size);
-
-   return m_iSndBufSize;
-}
-
-int CChannel::getRcvBufSize()
-{
-   socklen_t size = sizeof(socklen_t);
-
-   getsockopt(m_iSocket, SOL_SOCKET, SO_RCVBUF, (char *)&m_iRcvBufSize, &size);
-
-   return m_iRcvBufSize;
-}
-
-void CChannel::setSndBufSize(const int& size)
-{
-   m_iSndBufSize = size;
-}
-
-void CChannel::setRcvBufSize(const int& size)
-{
-   m_iRcvBufSize = size;
-}
-
-void CChannel::getSockAddr(sockaddr* addr) const
-{
-   socklen_t namelen = (AF_INET == m_iIPversion) ? sizeof(sockaddr_in) : sizeof(sockaddr_in6);
-
-   getsockname(m_iSocket, addr, &namelen);
-}
-
-void CChannel::getPeerAddr(sockaddr* addr) const
-{
-   socklen_t namelen = (AF_INET == m_iIPversion) ? sizeof(sockaddr_in) : sizeof(sockaddr_in6);
-
-   getpeername(m_iSocket, addr, &namelen);
-}
-
-int CChannel::sendto(const sockaddr* addr, CPacket& packet) const
-{
-   // convert control information into network order
-   if (packet.getFlag())
-      for (int i = 0, n = packet.getLength() / 4; i < n; ++ i)
-         *((uint32_t *)packet.m_pcData + i) = htonl(*((uint32_t *)packet.m_pcData + i));
-
-   // convert packet header into network order
-   //for (int j = 0; j < 4; ++ j)
-   //   packet.m_nHeader[j] = htonl(packet.m_nHeader[j]);
-   uint32_t* p = packet.m_nHeader;
-   for (int j = 0; j < 4; ++ j)
-   {
-      *p = htonl(*p);
-      ++ p;
-   }
-
-   #ifndef WIN32
-      msghdr mh;
-      mh.msg_name = (sockaddr*)addr;
-      mh.msg_namelen = (AF_INET == m_iIPversion) ? sizeof(sockaddr_in) : sizeof(sockaddr_in6);
-      mh.msg_iov = (iovec*)packet.m_PacketVector;
-      mh.msg_iovlen = 2;
-      mh.msg_control = NULL;
-      mh.msg_controllen = 0;
-      mh.msg_flags = 0;
-
-      int res = sendmsg(m_iSocket, &mh, 0);
-   #else
-      DWORD size = CPacket::m_iPktHdrSize + packet.getLength();
-      int addrsize = (AF_INET == m_iIPversion) ? sizeof(sockaddr_in) : sizeof(sockaddr_in6);
-      int res = WSASendTo(m_iSocket, (LPWSABUF)packet.m_PacketVector, 2, &size, 0, addr, addrsize, NULL, NULL);
-      res = (0 == res) ? size : -1;
-   #endif
-
-   // convert back into local host order
-   //for (int k = 0; k < 4; ++ k)
-   //   packet.m_nHeader[k] = ntohl(packet.m_nHeader[k]);
-   p = packet.m_nHeader;
-   for (int k = 0; k < 4; ++ k)
-   {
-      *p = ntohl(*p);
-       ++ p;
-   }
-
-   if (packet.getFlag())
-      for (int l = 0, n = packet.getLength() / 4; l < n; ++ l)
-         *((uint32_t *)packet.m_pcData + l) = ntohl(*((uint32_t *)packet.m_pcData + l));
-
-   return res;
-}
-
-int CChannel::recvfrom(sockaddr* addr, CPacket& packet) const
-{
-   #ifndef WIN32
-      msghdr mh;
-      mh.msg_name = addr;
-      mh.msg_namelen = (AF_INET == m_iIPversion) ? sizeof(sockaddr_in) : sizeof(sockaddr_in6);
-      mh.msg_iov = packet.m_PacketVector;
-      mh.msg_iovlen = 2;
-      mh.msg_control = NULL;
-      mh.msg_controllen = 0;
-      mh.msg_flags = 0;
-
-      #ifdef UNIX
-         fd_set set;
-         timeval tv;
-         FD_ZERO(&set);
-         FD_SET(m_iSocket, &set);
-         tv.tv_sec = 0;
-         tv.tv_usec = 10000;
-         select(m_iSocket+1, &set, NULL, &set, &tv);
-      #endif
-
-      int res = recvmsg(m_iSocket, &mh, 0);
-   #else
-      DWORD size = CPacket::m_iPktHdrSize + packet.getLength();
-      DWORD flag = 0;
-      int addrsize = (AF_INET == m_iIPversion) ? sizeof(sockaddr_in) : sizeof(sockaddr_in6);
-
-      int res = WSARecvFrom(m_iSocket, (LPWSABUF)packet.m_PacketVector, 2, &size, &flag, addr, &addrsize, NULL, NULL);
-      res = (0 == res) ? size : -1;
-   #endif
-
-   if (res <= 0)
-   {
-      packet.setLength(-1);
-      return -1;
-   }
-
-   packet.setLength(res - CPacket::m_iPktHdrSize);
-
-   // convert back into local host order
-   //for (int i = 0; i < 4; ++ i)
-   //   packet.m_nHeader[i] = ntohl(packet.m_nHeader[i]);
-   uint32_t* p = packet.m_nHeader;
-   for (int i = 0; i < 4; ++ i)
-   {
-      *p = ntohl(*p);
-      ++ p;
-   }
-
-   if (packet.getFlag())
-      for (int j = 0, n = packet.getLength() / 4; j < n; ++ j)
-         *((uint32_t *)packet.m_pcData + j) = ntohl(*((uint32_t *)packet.m_pcData + j));
-
-   return packet.getLength();
-}
+/*****************************************************************************
+Copyright (c) 2001 - 2008, The Board of Trustees of the University of Illinois.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+
+* Redistributions of source code must retain the above
+  copyright notice, this list of conditions and the
+  following disclaimer.
+
+* Redistributions in binary form must reproduce the
+  above copyright notice, this list of conditions
+  and the following disclaimer in the documentation
+  and/or other materials provided with the distribution.
+
+* Neither the name of the University of Illinois
+  nor the names of its contributors may be used to
+  endorse or promote products derived from this
+  software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+****************************************************************************/
+
+/****************************************************************************
+written by
+   Yunhong Gu, last updated 12/08/2008
+*****************************************************************************/
+
+#ifndef WIN32
+   #include <netdb.h>
+   #include <arpa/inet.h>
+   #include <unistd.h>
+   #include <fcntl.h>
+   #include <cstring>
+   #include <cstdio>
+   #include <cerrno>
+#else
+   #include <winsock2.h>
+   #include <ws2tcpip.h>
+#ifdef __MSVC__
+   #include <wspiapi.h>
+#endif
+#endif
+#include "channel.h"
+#include "packet.h"
+
+#ifdef WIN32
+   #define socklen_t int
+#endif
+
+#ifndef WIN32
+   #define NET_ERROR errno
+#else
+   #define NET_ERROR WSAGetLastError()
+#endif
+
+
+CChannel::CChannel():
+m_iIPversion(AF_INET),
+m_iSocket(),
+m_iSndBufSize(65536),
+m_iRcvBufSize(65536)
+{
+}
+
+CChannel::CChannel(const int& version):
+m_iIPversion(version),
+m_iSocket(),
+m_iSndBufSize(65536),
+m_iRcvBufSize(65536)
+{
+}
+
+CChannel::~CChannel()
+{
+}
+
+void CChannel::open(const sockaddr* addr)
+{
+   // construct an socket
+   m_iSocket = socket(m_iIPversion, SOCK_DGRAM, 0);
+   #ifdef WIN32
+      if (INVALID_SOCKET == m_iSocket)
+   #else
+      if (m_iSocket < 0)
+   #endif
+     throw CUDTException(1, 0, NET_ERROR);
+
+   if (NULL != addr)
+   {
+      socklen_t namelen = (AF_INET == m_iIPversion) ? sizeof(sockaddr_in) : sizeof(sockaddr_in6);
+
+      if (0 != bind(m_iSocket, addr, namelen))
+         throw CUDTException(1, 3, NET_ERROR);
+   }
+   else
+   {
+      //sendto or WSASendTo will also automatically bind the socket
+      addrinfo hints;
+      addrinfo* res;
+
+      memset(&hints, 0, sizeof(struct addrinfo));
+
+      hints.ai_flags = AI_PASSIVE;
+      hints.ai_family = m_iIPversion;
+      hints.ai_socktype = SOCK_DGRAM;
+
+      if (0 != getaddrinfo(NULL, "0", &hints, &res))
+         throw CUDTException(1, 3, NET_ERROR);
+
+      if (0 != bind(m_iSocket, res->ai_addr, res->ai_addrlen))
+         throw CUDTException(1, 3, NET_ERROR);
+
+      freeaddrinfo(res);
+   }
+
+   setUDPSockOpt();
+}
+
+void CChannel::open(UDPSOCKET udpsock)
+{
+   m_iSocket = udpsock;
+   setUDPSockOpt();
+}
+
+void CChannel::setUDPSockOpt()
+{
+  #if defined(BSD) || defined(OSX)
+	// BSD system will fail setsockopt if the requested buffer size exceeds system maximum value
+     int maxsize = 262144;
+     if (0 != setsockopt(m_iSocket, SOL_SOCKET, SO_RCVBUF, (char*)&m_iRcvBufSize, sizeof(int)))
+	    setsockopt(m_iSocket, SOL_SOCKET, SO_RCVBUF, (char*)&maxsize, sizeof(int));
+     if (0 != setsockopt(m_iSocket, SOL_SOCKET, SO_SNDBUF, (char*)&m_iSndBufSize, sizeof(int))
+     setsockopt(m_iSocket, SOL_SOCKET, SO_SNDBUF, (char*)&maxsize, sizeof(int));#else
+     // for other systems, if requested is greated than maximum, the maximum value will be automactally used
+	if ((0 != setsockopt(m_iSocket, SOL_SOCKET, SO_RCVBUF, (char *)&m_iRcvBufSize, sizeof(int))) ||
+       (0 != setsockopt(m_iSocket, SOL_SOCKET, SO_SNDBUF, (char *)&m_iSndBufSize, sizeof(int))))
+      throw CUDTException(1, 3, NET_ERROR);
+#endif
+   timeval tv;
+   tv.tv_sec = 0;
+   #if defined (BSD) || defined (OSX)
+      // Known BSD bug as the day I wrote this code.
+      // A small time out value will cause the socket to block forever.
+      tv.tv_usec = 10000;
+   #else
+      tv.tv_usec = 100;
+   #endif
+
+   #ifdef UNIX
+      // Set non-blocking I/O
+      // UNIX does not support SO_RCVTIMEO
+      int opts = fcntl(m_iSocket, F_GETFL);
+      if (-1 == fcntl(m_iSocket, F_SETFL, opts | O_NONBLOCK))
+         throw CUDTException(1, 3, NET_ERROR);
+   #elif WIN32
+      DWORD ot = 1; //milliseconds
+      if (setsockopt(m_iSocket, SOL_SOCKET, SO_RCVTIMEO, (char *)&ot, sizeof(DWORD)) < 0)
+         throw CUDTException(1, 3, NET_ERROR);
+   #else
+      // Set receiving time-out value
+      if (setsockopt(m_iSocket, SOL_SOCKET, SO_RCVTIMEO, (char *)&tv, sizeof(timeval)) < 0)
+         throw CUDTException(1, 3, NET_ERROR);
+   #endif
+}
+
+void CChannel::close() const
+{
+   #ifndef WIN32
+      ::close(m_iSocket);
+   #else
+      closesocket(m_iSocket);
+   #endif
+}
+
+int CChannel::getSndBufSize()
+{
+   socklen_t size = sizeof(socklen_t);
+
+   getsockopt(m_iSocket, SOL_SOCKET, SO_SNDBUF, (char *)&m_iSndBufSize, &size);
+
+   return m_iSndBufSize;
+}
+
+int CChannel::getRcvBufSize()
+{
+   socklen_t size = sizeof(socklen_t);
+
+   getsockopt(m_iSocket, SOL_SOCKET, SO_RCVBUF, (char *)&m_iRcvBufSize, &size);
+
+   return m_iRcvBufSize;
+}
+
+void CChannel::setSndBufSize(const int& size)
+{
+   m_iSndBufSize = size;
+}
+
+void CChannel::setRcvBufSize(const int& size)
+{
+   m_iRcvBufSize = size;
+}
+
+void CChannel::getSockAddr(sockaddr* addr) const
+{
+   socklen_t namelen = (AF_INET == m_iIPversion) ? sizeof(sockaddr_in) : sizeof(sockaddr_in6);
+
+   getsockname(m_iSocket, addr, &namelen);
+}
+
+void CChannel::getPeerAddr(sockaddr* addr) const
+{
+   socklen_t namelen = (AF_INET == m_iIPversion) ? sizeof(sockaddr_in) : sizeof(sockaddr_in6);
+
+   getpeername(m_iSocket, addr, &namelen);
+}
+
+int CChannel::sendto(const sockaddr* addr, CPacket& packet) const
+{
+   // convert control information into network order
+   if (packet.getFlag())
+      for (int i = 0, n = packet.getLength() / 4; i < n; ++ i)
+         *((uint32_t *)packet.m_pcData + i) = htonl(*((uint32_t *)packet.m_pcData + i));
+
+   // convert packet header into network order
+   //for (int j = 0; j < 4; ++ j)
+   //   packet.m_nHeader[j] = htonl(packet.m_nHeader[j]);
+   uint32_t* p = packet.m_nHeader;
+   for (int j = 0; j < 4; ++ j)
+   {
+      *p = htonl(*p);
+      ++ p;
+   }
+
+   #ifndef WIN32
+      msghdr mh;
+      mh.msg_name = (sockaddr*)addr;
+      mh.msg_namelen = (AF_INET == m_iIPversion) ? sizeof(sockaddr_in) : sizeof(sockaddr_in6);
+      mh.msg_iov = (iovec*)packet.m_PacketVector;
+      mh.msg_iovlen = 2;
+      mh.msg_control = NULL;
+      mh.msg_controllen = 0;
+      mh.msg_flags = 0;
+
+      int res = sendmsg(m_iSocket, &mh, 0);
+   #else
+      DWORD size = CPacket::m_iPktHdrSize + packet.getLength();
+      int addrsize = (AF_INET == m_iIPversion) ? sizeof(sockaddr_in) : sizeof(sockaddr_in6);
+      int res = WSASendTo(m_iSocket, (LPWSABUF)packet.m_PacketVector, 2, &size, 0, addr, addrsize, NULL, NULL);
+      res = (0 == res) ? size : -1;
+   #endif
+
+   // convert back into local host order
+   //for (int k = 0; k < 4; ++ k)
+   //   packet.m_nHeader[k] = ntohl(packet.m_nHeader[k]);
+   p = packet.m_nHeader;
+   for (int k = 0; k < 4; ++ k)
+   {
+      *p = ntohl(*p);
+       ++ p;
+   }
+
+   if (packet.getFlag())
+      for (int l = 0, n = packet.getLength() / 4; l < n; ++ l)
+         *((uint32_t *)packet.m_pcData + l) = ntohl(*((uint32_t *)packet.m_pcData + l));
+
+   return res;
+}
+
+int CChannel::recvfrom(sockaddr* addr, CPacket& packet) const
+{
+   #ifndef WIN32
+      msghdr mh;
+      mh.msg_name = addr;
+      mh.msg_namelen = (AF_INET == m_iIPversion) ? sizeof(sockaddr_in) : sizeof(sockaddr_in6);
+      mh.msg_iov = packet.m_PacketVector;
+      mh.msg_iovlen = 2;
+      mh.msg_control = NULL;
+      mh.msg_controllen = 0;
+      mh.msg_flags = 0;
+
+      #ifdef UNIX
+         fd_set set;
+         timeval tv;
+         FD_ZERO(&set);
+         FD_SET(m_iSocket, &set);
+         tv.tv_sec = 0;
+         tv.tv_usec = 10000;
+         select(m_iSocket+1, &set, NULL, &set, &tv);
+      #endif
+
+      int res = recvmsg(m_iSocket, &mh, 0);
+   #else
+      DWORD size = CPacket::m_iPktHdrSize + packet.getLength();
+      DWORD flag = 0;
+      int addrsize = (AF_INET == m_iIPversion) ? sizeof(sockaddr_in) : sizeof(sockaddr_in6);
+
+      int res = WSARecvFrom(m_iSocket, (LPWSABUF)packet.m_PacketVector, 2, &size, &flag, addr, &addrsize, NULL, NULL);
+      res = (0 == res) ? size : -1;
+   #endif
+
+   if (res <= 0)
+   {
+      packet.setLength(-1);
+      return -1;
+   }
+
+   packet.setLength(res - CPacket::m_iPktHdrSize);
+
+   // convert back into local host order
+   //for (int i = 0; i < 4; ++ i)
+   //   packet.m_nHeader[i] = ntohl(packet.m_nHeader[i]);
+   uint32_t* p = packet.m_nHeader;
+   for (int i = 0; i < 4; ++ i)
+   {
+      *p = ntohl(*p);
+      ++ p;
+   }
+
+   if (packet.getFlag())
+      for (int j = 0, n = packet.getLength() / 4; j < n; ++ j)
+         *((uint32_t *)packet.m_pcData + j) = ntohl(*((uint32_t *)packet.m_pcData + j));
+
+   return packet.getLength();
+}
diff --git a/src/transport/common.cpp b/src/transport/common.cpp
index 009d7cc..8d87f95 100644
--- a/src/transport/common.cpp
+++ b/src/transport/common.cpp
@@ -62,7 +62,7 @@ uint64_t CTimer::s_ullCPUFrequency = CTimer::readCPUFrequency();
    pthread_cond_t CTimer::m_EventCond = CreateEvent(NULL, false, false, NULL);
 #endif
 
-CTimer::CTimer()
+CTimer::CTimer() : m_ullSchedTime(), m_TickCond(), m_TickLock()
 {
    #ifndef WIN32
       pthread_mutex_init(&m_TickLock, NULL);
@@ -281,7 +281,7 @@ void CTimer::waitForEvent()
 //
 // Automatically lock in constructor
 CGuard::CGuard(pthread_mutex_t& lock):
-m_Mutex(lock)
+m_Mutex(lock), m_iLocked()
 {
    #ifndef WIN32
       m_iLocked = pthread_mutex_lock(&m_Mutex);
@@ -324,7 +324,7 @@ void CGuard::leaveCS(pthread_mutex_t& lock)
 //
 CUDTException::CUDTException(int major, int minor, int err):
 m_iMajor(major),
-m_iMinor(minor)
+m_iMinor(minor), m_iErrno(), m_strMsg()
 {
    if (-1 == err)
       #ifndef WIN32
@@ -339,7 +339,7 @@ m_iMinor(minor)
 CUDTException::CUDTException(const CUDTException& e):
 m_iMajor(e.m_iMajor),
 m_iMinor(e.m_iMinor),
-m_iErrno(e.m_iErrno)
+m_iErrno(e.m_iErrno), m_strMsg()
 {
 }
 
diff --git a/src/transport/core.cpp b/src/transport/core.cpp
index e000eb7..7217202 100644
--- a/src/transport/core.cpp
+++ b/src/transport/core.cpp
@@ -80,104 +80,86 @@ const int CUDT::m_iSYNInterval = 10000;
 const int CUDT::m_iSelfClockInterval = 64;
 
 
-CUDT::CUDT()
+CUDT::CUDT() : m_SocketID(), m_iSockType(), m_PeerID(),
+m_iPktSize(), m_iPayloadSize(), m_iMSS(1500), m_bSynSending(true),
+m_bSynRecving(true), m_iFlightFlagSize(25600), m_iSndBufSize(8192),
+m_iRcvBufSize(8192), m_Linger(), m_iUDPSndBufSize(65536), m_iUDPRcvBufSize(),
+m_iIPversion(AF_INET), m_bRendezvous(false), m_iSndTimeOut(-1), m_iRcvTimeOut(-1),
+m_bReuseAddr(true), m_llMaxBW(-1), m_pCCFactory(), m_pCC(), m_pController(),
+m_bListening(false), m_bConnected(false), m_bClosing(false),
+m_bShutdown(false), m_bBroken(false), m_bOpened(false), m_iBrokenCounter(),
+m_iEXPCount(), m_iBandwidth(), m_iRTT(), m_iRTTVar(), m_iDeliveryRate(),
+m_pSndBuffer(), m_pSndLossList(), m_pSndTimeWindow(), m_ullInterval(),
+m_ullTimeDiff(), m_iFlowWindowSize(), m_dCongestionWindow(), m_iSndLastAck(),
+m_iSndLastDataAck(), m_iSndCurrSeqNo(), m_iLastDecSeq(), m_iSndLastAck2(),
+m_ullSndLastAck2Time(), m_iISN(), m_pRcvBuffer(), m_pRcvLossList(), m_pACKWindow(),
+m_pRcvTimeWindow(), m_iRcvLastAck(), m_ullLastAckTime(), m_iRcvLastAckAck(),
+m_iAckSeqNo(), m_iRcvCurrSeqNo(), m_ullLastWarningTime(), m_iPeerISN(),
+m_ConnectionLock(), m_SendBlockCond(), m_SendBlockLock(), m_AckLock(),
+m_RecvDataCond(), m_RecvDataLock(), m_SendLock(), m_RecvLock(), m_StartTime(),
+m_llSentTotal(), m_llRecvTotal(), m_iSndLossTotal(), m_iRcvLossTotal(),
+m_iRetransTotal(), m_iSentACKTotal(), m_iRecvACKTotal(), m_iSentNAKTotal(),
+m_iRecvNAKTotal(), m_llSndDurationTotal(), m_LastSampleTime(), m_llTraceSent(),
+m_llTraceRecv(), m_iTraceSndLoss(), m_iTraceRcvLoss(), m_iTraceRetrans(),
+m_iSentACK(), m_iRecvACK(), m_iSentNAK(), m_iRecvNAK(), m_llSndDuration(),
+m_llSndDurationCounter(), m_ullCPUFrequency(), m_ullNextACKTime(),
+m_ullNextNAKTime(), m_ullNextEXPTime(), m_ullSYNInt(), m_ullACKInt(),
+m_ullNAKInt(), m_ullEXPInt(), m_ullMinEXPInt(), m_iPktCount(),
+m_iLightACKCount(), m_ullTargetTime(), m_pSndQueue(), m_pRcvQueue(),
+m_pPeerAddr(), m_pSNode(), m_pRNode()
+
 {
-   m_pSndBuffer = NULL;
-   m_pRcvBuffer = NULL;
-   m_pSndLossList = NULL;
-   m_pRcvLossList = NULL;
-   m_pACKWindow = NULL;
-   m_pSndTimeWindow = NULL;
-   m_pRcvTimeWindow = NULL;
-
-   m_pSndQueue = NULL;
-   m_pRcvQueue = NULL;
-   m_pPeerAddr = NULL;
-   m_pSNode = NULL;
-   m_pRNode = NULL;
 
    // Initilize mutex and condition variables
    initSynch();
 
-   // Default UDT configurations
-   m_iMSS = 1500;
-   m_bSynSending = true;
-   m_bSynRecving = true;
-   m_iFlightFlagSize = 25600;
-   m_iSndBufSize = 8192;
-   m_iRcvBufSize = 8192;
    m_Linger.l_onoff = 1;
    m_Linger.l_linger = 180;
-   m_iUDPSndBufSize = 65536;
    m_iUDPRcvBufSize = m_iRcvBufSize * m_iMSS;
-   m_iIPversion = AF_INET;
-   m_bRendezvous = false;
-   m_iSndTimeOut = -1;
-   m_iRcvTimeOut = -1;
-   m_bReuseAddr = true;
-   m_llMaxBW = -1;
 
    m_pCCFactory = new CCCFactory<CUDTCC>;
-   m_pCC = NULL;
-   m_pController = NULL;
-
-   // Initial status
-   m_bOpened = false;
-   m_bListening = false;
-   m_bConnected = false;
-   m_bClosing = false;
-   m_bShutdown = false;
-   m_bBroken = false;
 }
 
-CUDT::CUDT(const CUDT& ancestor)
+CUDT::CUDT(const CUDT& ancestor) : m_SocketID(),
+m_iSockType(ancestor.m_iSockType), m_PeerID(),
+m_iPktSize(), m_iPayloadSize(), m_iMSS(ancestor.m_iMSS),
+m_bSynSending(ancestor.m_bSynSending),
+m_bSynRecving(ancestor.m_bSynRecving),
+m_iFlightFlagSize(ancestor.m_iFlightFlagSize),
+m_iSndBufSize(ancestor.m_iSndBufSize),
+m_iRcvBufSize(ancestor.m_iRcvBufSize),
+m_Linger(ancestor.m_Linger), m_iUDPSndBufSize(ancestor.m_iUDPSndBufSize),
+m_iUDPRcvBufSize(ancestor.m_iUDPRcvBufSize),
+m_iIPversion(ancestor.m_iIPversion), m_bRendezvous(ancestor.m_bRendezvous),
+m_iSndTimeOut(ancestor.m_iSndTimeOut), m_iRcvTimeOut(ancestor.m_iRcvTimeOut),
+m_bReuseAddr(true), m_llMaxBW(ancestor.m_llMaxBW),
+m_pCCFactory(ancestor.m_pCCFactory->clone()), m_pCC(),
+m_pController(ancestor.m_pController),
+m_bListening(false), m_bConnected(false), m_bClosing(false),
+m_bShutdown(false), m_bBroken(false), m_bOpened(false), m_iBrokenCounter(),
+m_iEXPCount(), m_iBandwidth(), m_iRTT(), m_iRTTVar(), m_iDeliveryRate(),
+m_pSndBuffer(), m_pSndLossList(), m_pSndTimeWindow(), m_ullInterval(),
+m_ullTimeDiff(), m_iFlowWindowSize(), m_dCongestionWindow(), m_iSndLastAck(),
+m_iSndLastDataAck(), m_iSndCurrSeqNo(), m_iLastDecSeq(), m_iSndLastAck2(),
+m_ullSndLastAck2Time(), m_iISN(), m_pRcvBuffer(), m_pRcvLossList(),
+m_pACKWindow(),
+m_pRcvTimeWindow(), m_iRcvLastAck(), m_ullLastAckTime(), m_iRcvLastAckAck(),
+m_iAckSeqNo(), m_iRcvCurrSeqNo(), m_ullLastWarningTime(), m_iPeerISN(),
+m_ConnectionLock(), m_SendBlockCond(), m_SendBlockLock(), m_AckLock(),
+m_RecvDataCond(), m_RecvDataLock(), m_SendLock(), m_RecvLock(), m_StartTime(),
+m_llSentTotal(), m_llRecvTotal(), m_iSndLossTotal(), m_iRcvLossTotal(),
+m_iRetransTotal(), m_iSentACKTotal(), m_iRecvACKTotal(), m_iSentNAKTotal(),
+m_iRecvNAKTotal(), m_llSndDurationTotal(), m_LastSampleTime(), m_llTraceSent(),
+m_llTraceRecv(), m_iTraceSndLoss(), m_iTraceRcvLoss(), m_iTraceRetrans(),
+m_iSentACK(), m_iRecvACK(), m_iSentNAK(), m_iRecvNAK(), m_llSndDuration(),
+m_llSndDurationCounter(), m_ullCPUFrequency(), m_ullNextACKTime(),
+m_ullNextNAKTime(), m_ullNextEXPTime(), m_ullSYNInt(), m_ullACKInt(),
+m_ullNAKInt(), m_ullEXPInt(), m_ullMinEXPInt(), m_iPktCount(),
+m_iLightACKCount(), m_ullTargetTime(), m_pSndQueue(), m_pRcvQueue(),
+m_pPeerAddr(), m_pSNode(), m_pRNode()
 {
-   m_pSndBuffer = NULL;
-   m_pRcvBuffer = NULL;
-   m_pSndLossList = NULL;
-   m_pRcvLossList = NULL;
-   m_pACKWindow = NULL;
-   m_pSndTimeWindow = NULL;
-   m_pRcvTimeWindow = NULL;
-
-   m_pSndQueue = NULL;
-   m_pRcvQueue = NULL;
-   m_pPeerAddr = NULL;
-   m_pSNode = NULL;
-   m_pRNode = NULL;
-
    // Initilize mutex and condition variables
    initSynch();
-
-   // Default UDT configurations
-   m_iMSS = ancestor.m_iMSS;
-   m_bSynSending = ancestor.m_bSynSending;
-   m_bSynRecving = ancestor.m_bSynRecving;
-   m_iFlightFlagSize = ancestor.m_iFlightFlagSize;
-   m_iSndBufSize = ancestor.m_iSndBufSize;
-   m_iRcvBufSize = ancestor.m_iRcvBufSize;
-   m_Linger = ancestor.m_Linger;
-   m_iUDPSndBufSize = ancestor.m_iUDPSndBufSize;
-   m_iUDPRcvBufSize = ancestor.m_iUDPRcvBufSize;
-   m_iSockType = ancestor.m_iSockType;
-   m_iIPversion = ancestor.m_iIPversion;
-   m_bRendezvous = ancestor.m_bRendezvous;
-   m_iSndTimeOut = ancestor.m_iSndTimeOut;
-   m_iRcvTimeOut = ancestor.m_iRcvTimeOut;
-   m_bReuseAddr = true;	// this must be true, because all accepted sockets shared the same port with the listener
-   m_llMaxBW = ancestor.m_llMaxBW;
-
-   m_pCCFactory = ancestor.m_pCCFactory->clone();
-   m_pCC = NULL;
-   m_pController = ancestor.m_pController;
-
-   // Initial status
-   m_bOpened = false;
-   m_bListening = false;
-   m_bConnected = false;
-   m_bClosing = false;
-   m_bShutdown = false;
-   m_bBroken = false;
 }
 
 CUDT::~CUDT()
@@ -311,13 +293,13 @@ void CUDT::setOpt(UDTOpt optName, const void* optval, const int&)
       m_bRendezvous = *(bool *)optval;
       break;
 
-   case UDT_SNDTIMEO: 
-      m_iSndTimeOut = *(int*)optval; 
-      break; 
-    
-   case UDT_RCVTIMEO: 
-      m_iRcvTimeOut = *(int*)optval; 
-      break; 
+   case UDT_SNDTIMEO:
+      m_iSndTimeOut = *(int*)optval;
+      break;
+
+   case UDT_RCVTIMEO:
+      m_iRcvTimeOut = *(int*)optval;
+      break;
 
    case UDT_REUSEADDR:
       if (m_bOpened)
@@ -330,7 +312,7 @@ void CUDT::setOpt(UDTOpt optName, const void* optval, const int&)
          throw CUDTException(5, 1, 0);
       m_llMaxBW = *(int64_t*)optval;
       break;
-    
+
    default:
       throw CUDTException(5, 0, 0);
    }
@@ -403,15 +385,15 @@ void CUDT::getOpt(UDTOpt optName, void* optval, int& optlen)
       optlen = sizeof(bool);
       break;
 
-   case UDT_SNDTIMEO: 
-      *(int*)optval = m_iSndTimeOut; 
-      optlen = sizeof(int); 
-      break; 
-    
-   case UDT_RCVTIMEO: 
-      *(int*)optval = m_iRcvTimeOut; 
-      optlen = sizeof(int); 
-      break; 
+   case UDT_SNDTIMEO:
+      *(int*)optval = m_iSndTimeOut;
+      optlen = sizeof(int);
+      break;
+
+   case UDT_RCVTIMEO:
+      *(int*)optval = m_iRcvTimeOut;
+      optlen = sizeof(int);
+      break;
 
    case UDT_REUSEADDR:
       *(bool *)optval = m_bReuseAddr;
@@ -467,7 +449,7 @@ void CUDT::open()
 
    // set up the timers
    m_ullSYNInt = m_iSYNInterval * m_ullCPUFrequency;
-   
+
    m_ullACKInt = m_ullSYNInt;
    m_ullNAKInt = (m_iRTT + 4 * m_iRTTVar) * m_ullCPUFrequency;
    m_ullEXPInt = (m_iRTT + 4 * m_iRTTVar) * m_ullCPUFrequency + m_ullSYNInt;
@@ -716,7 +698,7 @@ void CUDT::connect(const sockaddr* peer, CHandShake* hs)
    memcpy(&ci, hs, sizeof(CHandShake));
    initpkt.pack(0, NULL, &ci, sizeof(CHandShake));
 
-   // Uses the smaller MSS between the peers        
+   // Uses the smaller MSS between the peers
    if (ci.m_iMSS > m_iMSS)
       ci.m_iMSS = m_iMSS;
    else
@@ -750,7 +732,7 @@ void CUDT::connect(const sockaddr* peer, CHandShake* hs)
 
    // Save the negotiated configurations.
    memcpy(hs, &ci, sizeof(CHandShake));
-  
+
    m_iPktSize = m_iMSS - 28;
    m_iPayloadSize = m_iPktSize - CPacket::m_iPktHdrSize;
 
@@ -881,19 +863,19 @@ int CUDT::send(const char* data, const int& len)
          // wait here during a blocking sending
          #ifndef WIN32
             pthread_mutex_lock(&m_SendBlockLock);
-            if (m_iSndTimeOut < 0) 
-            { 
+            if (m_iSndTimeOut < 0)
+            {
                while (!m_bBroken && m_bConnected && !m_bClosing && (m_iSndBufSize <= m_pSndBuffer->getCurrBufSize()))
                   pthread_cond_wait(&m_SendBlockCond, &m_SendBlockLock);
             }
             else
             {
                uint64_t exptime = CTimer::getTime() + m_iSndTimeOut * 1000ULL;
-               timespec locktime; 
-    
+               timespec locktime;
+
                locktime.tv_sec = exptime / 1000000;
                locktime.tv_nsec = (exptime % 1000000) * 1000;
-    
+
                pthread_cond_timedwait(&m_SendBlockCond, &m_SendBlockLock, &locktime);
             }
             pthread_mutex_unlock(&m_SendBlockLock);
@@ -903,8 +885,8 @@ int CUDT::send(const char* data, const int& len)
                while (!m_bBroken && m_bConnected && !m_bClosing && (m_iSndBufSize <= m_pSndBuffer->getCurrBufSize()))
                   WaitForSingleObject(m_SendBlockCond, INFINITE);
             }
-            else 
-               WaitForSingleObject(m_SendBlockCond, DWORD(m_iSndTimeOut)); 
+            else
+               WaitForSingleObject(m_SendBlockCond, DWORD(m_iSndTimeOut));
          #endif
 
          // check the connection status
@@ -916,7 +898,7 @@ int CUDT::send(const char* data, const int& len)
    }
 
    if (m_iSndBufSize <= m_pSndBuffer->getCurrBufSize())
-      return 0; 
+      return 0;
 
    int size = (m_iSndBufSize - m_pSndBuffer->getCurrBufSize()) * m_iPayloadSize;
    if (size > len)
@@ -959,21 +941,21 @@ int CUDT::recv(char* data, const int& len)
       {
          #ifndef WIN32
             pthread_mutex_lock(&m_RecvDataLock);
-            if (m_iRcvTimeOut < 0) 
-            { 
+            if (m_iRcvTimeOut < 0)
+            {
                while (!m_bBroken && m_bConnected && !m_bClosing && (0 == m_pRcvBuffer->getRcvDataSize()))
                   pthread_cond_wait(&m_RecvDataCond, &m_RecvDataLock);
             }
             else
             {
-               uint64_t exptime = CTimer::getTime() + m_iRcvTimeOut * 1000ULL; 
-               timespec locktime; 
-    
+               uint64_t exptime = CTimer::getTime() + m_iRcvTimeOut * 1000ULL;
+               timespec locktime;
+
                locktime.tv_sec = exptime / 1000000;
                locktime.tv_nsec = (exptime % 1000000) * 1000;
 
                while (!m_bBroken && m_bConnected && !m_bClosing && (0 == m_pRcvBuffer->getRcvDataSize()))
-                  pthread_cond_timedwait(&m_RecvDataCond, &m_RecvDataLock, &locktime); 
+                  pthread_cond_timedwait(&m_RecvDataCond, &m_RecvDataLock, &locktime);
             }
             pthread_mutex_unlock(&m_RecvDataLock);
          #else
@@ -1080,7 +1062,7 @@ int CUDT::sendmsg(const char* data, const int& len, const int& msttl, const bool
    // insert this socket to the snd list if it is not on the list yet
    m_pSndQueue->m_pSndUList->update(this, false);
 
-   return len;   
+   return len;
 }
 
 int CUDT::recvmsg(char* data, const int& len)
@@ -1139,7 +1121,7 @@ int CUDT::recvmsg(char* data, const int& len)
             if (pthread_cond_timedwait(&m_RecvDataCond, &m_RecvDataLock, &locktime) == ETIMEDOUT)
                timeout = true;
 
-            res = m_pRcvBuffer->readMsg(data, len);           
+            res = m_pRcvBuffer->readMsg(data, len);
          }
          pthread_mutex_unlock(&m_RecvDataLock);
       #else
@@ -1608,7 +1590,7 @@ void CUDT::sendCtrl(const int& pkttype, void* lparam, void* rparam, const int& s
       ctrlpkt.pack(1);
       ctrlpkt.m_iID = m_PeerID;
       m_pSndQueue->sendto(m_pPeerAddr, ctrlpkt);
- 
+
       break;
 
    case 0: //000 - Handshake
@@ -1859,7 +1841,7 @@ void CUDT::processCtrl(CPacket& ctrlpkt)
 
       // Wake up the waiting sender (avoiding deadlock on an infinite sleeping)
       m_pSndLossList->insert(const_cast<int32_t&>(m_iSndLastAck), const_cast<int32_t&>(m_iSndLastAck));
-	  
+
       // the lost packet (retransmission) should be sent out immediately
       m_pSndQueue->m_pSndUList->update(this);
 
@@ -2105,10 +2087,10 @@ int CUDT::processData(CUnit* unit)
       m_iTraceRcvLoss += CSeqNo::seqlen(m_iRcvCurrSeqNo, packet.m_iSeqNo) - 2;
    }
 
-   // This is not a regular fixed size packet...   
-   //an irregular sized packet usually indicates the end of a message, so send an ACK immediately   
-   if (packet.getLength() != m_iPayloadSize)   
-      CTimer::rdtsc(m_ullNextACKTime); 
+   // This is not a regular fixed size packet...
+   //an irregular sized packet usually indicates the end of a message, so send an ACK immediately
+   if (packet.getLength() != m_iPayloadSize)
+      CTimer::rdtsc(m_ullNextACKTime);
 
    // Update the current largest sequence number that has been received.
    // Or it is a retransmitted packet, remove it from receiver loss list.
@@ -2230,7 +2212,7 @@ void CUDT::checkTimers()
           || (m_iEXPCount * ((m_iEXPCount - 1) * (m_iRTT + 4 * m_iRTTVar) / 2 + m_iSYNInterval) > 30000000))
       {
          //
-         // Connection is broken. 
+         // Connection is broken.
          // UDT does not signal any information about this instead of to stop quietly.
          // Apllication will detect this when it calls any UDT methods next time.
          //
diff --git a/src/transport/packet.cpp b/src/transport/packet.cpp
index f7dcc89..999c003 100644
--- a/src/transport/packet.cpp
+++ b/src/transport/packet.cpp
@@ -116,9 +116,9 @@ written by
 //              Control Info: first sequence number of the message
 //                            last seqeunce number of the message
 //      65535: Explained by bits 16 - 31
-//              
+//
 //   bit 16 - 31:
-//      This space is used for future expansion or user defined control packets. 
+//      This space is used for future expansion or user defined control packets.
 //
 //    0                   1                   2                   3
 //    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
@@ -152,7 +152,8 @@ m_iSeqNo((int32_t&)(m_nHeader[0])),
 m_iMsgNo((int32_t&)(m_nHeader[1])),
 m_iTimeStamp((int32_t&)(m_nHeader[2])),
 m_iID((int32_t&)(m_nHeader[3])),
-m_pcData((char*&)(m_PacketVector[1].iov_base))
+m_pcData((char*&)(m_PacketVector[1].iov_base)),
+__pad()
 {
    m_PacketVector[0].iov_base = (char *)m_nHeader;
    m_PacketVector[0].iov_len = CPacket::m_iPktHdrSize;
@@ -185,7 +186,7 @@ void CPacket::pack(const int& pkttype, void* lparam, void* rparam, const int& si
       if (NULL != lparam)
          m_nHeader[1] = *(int32_t *)lparam;
 
-      // data ACK seq. no. 
+      // data ACK seq. no.
       // optional: RTT (microsends), RTT variance (microseconds) advertised flow window size (packets), and estimated link capacity (packets per second)
       m_PacketVector[1].iov_base = (char *)rparam;
       m_PacketVector[1].iov_len = size;
@@ -215,7 +216,7 @@ void CPacket::pack(const int& pkttype, void* lparam, void* rparam, const int& si
       // but "writev" does not allow this
       m_PacketVector[1].iov_base = (char *)&__pad; //NULL;
       m_PacketVector[1].iov_len = 4; //0;
-  
+
       break;
 
    case 1: //0001 - Keep-alive
@@ -242,7 +243,7 @@ void CPacket::pack(const int& pkttype, void* lparam, void* rparam, const int& si
       break;
 
    case 7: //0111 - Message Drop Request
-      // msg id 
+      // msg id
       m_nHeader[1] = *(int32_t *)lparam;
 
       //first seq no, last seq no
diff --git a/src/transport/queue.cpp b/src/transport/queue.cpp
index 837ae3f..a81ffe2 100644
--- a/src/transport/queue.cpp
+++ b/src/transport/queue.cpp
@@ -1,1134 +1,1148 @@
-/*****************************************************************************
-Copyright (c) 2001 - 2008, The Board of Trustees of the University of Illinois.
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-
-* Redistributions of source code must retain the above
-  copyright notice, this list of conditions and the
-  following disclaimer.
-
-* Redistributions in binary form must reproduce the
-  above copyright notice, this list of conditions
-  and the following disclaimer in the documentation
-  and/or other materials provided with the distribution.
-
-* Neither the name of the University of Illinois
-  nor the names of its contributors may be used to
-  endorse or promote products derived from this
-  software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
-THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
-CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
-EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
-PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*****************************************************************************/
-
-/*****************************************************************************
-written by
-   Yunhong Gu, last updated 12/08/2008
-*****************************************************************************/
-
-#ifdef WIN32
-   #include <winsock2.h>
-   #include <ws2tcpip.h>
-   #ifdef __MSVC__
-    #include <wspiapi.h>
-   #endif
-#endif
-
-#include <cstring>
-#include "common.h"
-#include "queue.h"
-#include "core.h"
-
-using namespace std;
-
-CUnitQueue::CUnitQueue():
-m_pQEntry(NULL),
-m_pCurrQueue(NULL),
-m_pLastQueue(NULL),
-m_iSize(0),
-m_iCount(0)
-{
-}
-
-CUnitQueue::~CUnitQueue()
-{
-   CQEntry* p = m_pQEntry;
-
-   while (p != NULL)
-   {
-      delete [] p->m_pUnit;
-      delete [] p->m_pBuffer;
-
-      CQEntry* q = p;
-      if (p == m_pLastQueue)
-         p = NULL;
-      else
-         p = p->m_pNext;
-      delete q;
-   }
-}
-
-int CUnitQueue::init(const int& size, const int& mss, const int& version)
-{
-   CQEntry* tempq = NULL;
-   CUnit* tempu = NULL;
-   char* tempb = NULL;
-
-   try
-   {
-      tempq = new CQEntry;
-      tempu = new CUnit [size];
-      tempb = new char [size * mss];
-   }
-   catch (...)
-   {
-      delete tempq;
-      delete [] tempu;
-      delete [] tempb;
-
-      return -1;
-   }
-
-   for (int i = 0; i < size; ++ i)
-   {
-      tempu[i].m_iFlag = 0;
-      tempu[i].m_Packet.m_pcData = tempb + i * mss;
-   }
-   tempq->m_pUnit = tempu;
-   tempq->m_pBuffer = tempb;
-   tempq->m_iSize = size;
-
-   m_pQEntry = m_pCurrQueue = m_pLastQueue = tempq;
-   m_pQEntry->m_pNext = m_pQEntry;
-
-   m_pAvailUnit = m_pCurrQueue->m_pUnit;
-
-   m_iSize = size;
-   m_iMSS = mss;
-   m_iIPversion = version;
-
-   return 0;
-}
-
-int CUnitQueue::increase()
-{
-   // adjust/correct m_iCount
-   int real_count = 0;
-   CQEntry* p = m_pQEntry;
-   while (p != NULL)
-   {
-      CUnit* u = p->m_pUnit;
-      for (CUnit* end = u + p->m_iSize; u != end; ++ u)
-         if (u->m_iFlag != 0)
-            ++ real_count;
-
-      if (p == m_pLastQueue)
-         p = NULL;
-      else
-         p = p->m_pNext;
-   }
-   m_iCount = real_count;
-   if (double(m_iCount) / m_iSize < 0.9)
-      return -1;
-
-   CQEntry* tempq = NULL;
-   CUnit* tempu = NULL;
-   char* tempb = NULL;
-
-   // all queues have the same size
-   int size = m_pQEntry->m_iSize;
-
-   try
-   {
-      tempq = new CQEntry;
-      tempu = new CUnit [size];
-      tempb = new char [size * m_iMSS];
-   }
-   catch (...)
-   {
-      delete tempq;
-      delete [] tempu;
-      delete [] tempb;
-
-      return -1;
-   }
-
-   for (int i = 0; i < size; ++ i)
-   {
-      tempu[i].m_iFlag = 0;
-      tempu[i].m_Packet.m_pcData = tempb + i * m_iMSS;
-   }
-   tempq->m_pUnit = tempu;
-   tempq->m_pBuffer = tempb;
-   tempq->m_iSize = size;
-
-   m_pLastQueue->m_pNext = tempq;
-   m_pLastQueue = tempq;
-   m_pLastQueue->m_pNext = m_pQEntry;
-
-   m_iSize += size;
-
-   return 0;
-}
-
-int CUnitQueue::shrink()
-{
-   // currently queue cannot be shrunk.
-   return -1;
-}
-
-CUnit* CUnitQueue::getNextAvailUnit()
-{
-   if (m_iCount * 10 > m_iSize * 9)
-      increase();
-
-   if (m_iCount >= m_iSize)
-      return NULL;
-
-   CQEntry* entrance = m_pCurrQueue;
-
-   do
-   {
-      for (CUnit* sentinel = m_pCurrQueue->m_pUnit + m_pCurrQueue->m_iSize - 1; m_pAvailUnit != sentinel; ++ m_pAvailUnit)
-         if (m_pAvailUnit->m_iFlag == 0)
-            return m_pAvailUnit;
-
-      if (m_pCurrQueue->m_pUnit->m_iFlag == 0)
-      {
-         m_pAvailUnit = m_pCurrQueue->m_pUnit;
-         return m_pAvailUnit;
-      }
-
-      m_pCurrQueue = m_pCurrQueue->m_pNext;
-      m_pAvailUnit = m_pCurrQueue->m_pUnit;
-   } while (m_pCurrQueue != entrance);
-
-   increase();
-
-   return NULL;
-}
-
-
-CSndUList::CSndUList()
-{
-   m_iArrayLength = 4096;
-   m_pHeap = new CSNode*[m_iArrayLength];
-   m_iLastEntry = -1;
-
-   #ifndef WIN32
-      pthread_mutex_init(&m_ListLock, NULL);
-   #else
-      m_ListLock = CreateMutex(NULL, false, NULL);
-   #endif
-}
-
-CSndUList::~CSndUList()
-{
-   delete [] m_pHeap;
-
-   #ifndef WIN32
-      pthread_mutex_destroy(&m_ListLock);
-   #else
-      CloseHandle(m_ListLock);
-   #endif
-}
-
-void CSndUList::insert(const int64_t& ts, const CUDT* u)
-{
-   CGuard listguard(m_ListLock);
-
-   // increase the heap array size if necessary
-   if (m_iLastEntry == m_iArrayLength - 1)
-   {
-      CSNode** temp = NULL;
-
-      try
-      {
-         temp = new CSNode*[m_iArrayLength * 2];
-      }
-      catch(...)
-      {
-         return;
-      }
-
-      memcpy(temp, m_pHeap, sizeof(CSNode*) * m_iArrayLength);
-      m_iArrayLength *= 2;
-      delete [] m_pHeap;
-      m_pHeap = temp;
-   }
-
-   insert_(ts, u);
-}
-
-void CSndUList::update(const CUDT* u, const bool& reschedule)
-{
-   CGuard listguard(m_ListLock);
-
-   CSNode* n = u->m_pSNode;
-
-   if (n->m_iHeapLoc >= 0)
-   {
-      if (!reschedule)
-         return;
-
-      if (n->m_iHeapLoc == 0)
-      {
-         n->m_llTimeStamp = 1;
-         m_pTimer->interrupt();
-         return;
-      }
-
-      remove_(u);
-   }
-
-   insert_(1, u);
-}
-
-int CSndUList::pop(sockaddr*& addr, CPacket& pkt)
-{
-   CGuard listguard(m_ListLock);
-
-   if (-1 == m_iLastEntry)
-      return -1;
-
-   CUDT* u = m_pHeap[0]->m_pUDT;
-   remove_(u);
-
-   if (!u->m_bConnected || u->m_bBroken)
-      return -1;
-
-   // pack a packet from the socket
-   uint64_t ts;
-   if (u->packData(pkt, ts) <= 0)
-      return -1;
-
-   addr = u->m_pPeerAddr;
-
-   // insert a new entry, ts is the next processing time
-   if (ts > 0)
-      insert_(ts, u);
-
-   return 1;
-}
-
-void CSndUList::remove(const CUDT* u)
-{
-   CGuard listguard(m_ListLock);
-
-   remove_(u);
-}
-
-uint64_t CSndUList::getNextProcTime()
-{
-   CGuard listguard(m_ListLock);
-
-   if (-1 == m_iLastEntry)
-      return 0;
-
-   return m_pHeap[0]->m_llTimeStamp;
-}
-
-void CSndUList::insert_(const int64_t& ts, const CUDT* u)
-{
-   CSNode* n = u->m_pSNode;
-
-   // do not insert repeated node
-   if (n->m_iHeapLoc >= 0)
-      return;
-
-   m_iLastEntry ++;
-   m_pHeap[m_iLastEntry] = n;
-   n->m_llTimeStamp = ts;
-
-   int q = m_iLastEntry;
-   int p = q;
-   while (p != 0)
-   {
-      p = (q - 1) >> 1;
-      if (m_pHeap[p]->m_llTimeStamp > m_pHeap[q]->m_llTimeStamp)
-      {
-         CSNode* t = m_pHeap[p];
-         m_pHeap[p] = m_pHeap[q];
-         m_pHeap[q] = t;
-         t->m_iHeapLoc = q;
-         q = p;
-      }
-      else
-         break;
-   }
-
-   n->m_iHeapLoc = q;
-
-   // first entry, activate the sending queue
-   if (0 == m_iLastEntry)
-   {
-      #ifndef WIN32
-         pthread_mutex_lock(m_pWindowLock);
-         pthread_cond_signal(m_pWindowCond);
-         pthread_mutex_unlock(m_pWindowLock);
-      #else
-         SetEvent(*m_pWindowCond);
-      #endif
-   }
-}
-
-void CSndUList::remove_(const CUDT* u)
-{
-   CSNode* n = u->m_pSNode;
-
-   if (n->m_iHeapLoc >= 0)
-   {
-      // remove the node from heap
-      m_pHeap[n->m_iHeapLoc] = m_pHeap[m_iLastEntry];
-      m_iLastEntry --;
-      m_pHeap[n->m_iHeapLoc]->m_iHeapLoc = n->m_iHeapLoc;
-
-      int q = n->m_iHeapLoc;
-      int p = q * 2 + 1;
-      while (p <= m_iLastEntry)
-      {
-         if ((p + 1 <= m_iLastEntry) && (m_pHeap[p]->m_llTimeStamp > m_pHeap[p + 1]->m_llTimeStamp))
-            p ++;
-
-         if (m_pHeap[q]->m_llTimeStamp > m_pHeap[p]->m_llTimeStamp)
-         {
-            CSNode* t = m_pHeap[p];
-            m_pHeap[p] = m_pHeap[q];
-            m_pHeap[p]->m_iHeapLoc = p;
-            m_pHeap[q] = t;
-            m_pHeap[q]->m_iHeapLoc = q;
-
-            q = p;
-            p = q * 2 + 1;
-         }
-         else
-            break;
-      }
-
-      n->m_iHeapLoc = -1;
-   }
-}
-
-//
-CSndQueue::CSndQueue():
-m_pSndUList(NULL),
-m_pChannel(NULL),
-m_pTimer(NULL),
-m_bClosing(false)
-{
-   #ifndef WIN32
-      pthread_cond_init(&m_WindowCond, NULL);
-      pthread_mutex_init(&m_WindowLock, NULL);
-   #else
-      m_WindowLock = CreateMutex(NULL, false, NULL);
-      m_WindowCond = CreateEvent(NULL, false, false, NULL);
-      m_ExitCond = CreateEvent(NULL, false, false, NULL);
-   #endif
-}
-
-CSndQueue::~CSndQueue()
-{
-   m_bClosing = true;
-
-   #ifndef WIN32
-      pthread_mutex_lock(&m_WindowLock);
-      pthread_cond_signal(&m_WindowCond);
-      pthread_mutex_unlock(&m_WindowLock);
-      if (0 != m_WorkerThread)
-         pthread_join(m_WorkerThread, NULL);
-      pthread_cond_destroy(&m_WindowCond);
-      pthread_mutex_destroy(&m_WindowLock);
-   #else
-      SetEvent(m_WindowCond);
-      if (NULL != m_WorkerThread)
-         WaitForSingleObject(m_ExitCond, INFINITE);
-      CloseHandle(m_WorkerThread);
-      CloseHandle(m_WindowLock);
-      CloseHandle(m_WindowCond);
-   #endif
-
-   delete m_pSndUList;
-}
-
-void CSndQueue::init(const CChannel* c, const CTimer* t)
-{
-   m_pChannel = (CChannel*)c;
-   m_pTimer = (CTimer*)t;
-   m_pSndUList = new CSndUList;
-   m_pSndUList->m_pWindowLock = &m_WindowLock;
-   m_pSndUList->m_pWindowCond = &m_WindowCond;
-   m_pSndUList->m_pTimer = m_pTimer;
-
-   #ifndef WIN32
-      if (0 != pthread_create(&m_WorkerThread, NULL, CSndQueue::worker, this))
-      {
-         m_WorkerThread = 0;
-         throw CUDTException(3, 1);
-      }
-   #else
-      DWORD threadID;
-      m_WorkerThread = CreateThread(NULL, 0, CSndQueue::worker, this, 0, &threadID);
-      if (NULL == m_WorkerThread)
-         throw CUDTException(3, 1);
-   #endif
-}
-
-#ifndef WIN32
-   void* CSndQueue::worker(void* param)
-#else
-   DWORD WINAPI CSndQueue::worker(LPVOID param)
-#endif
-{
-   CSndQueue* self = (CSndQueue*)param;
-
-   CPacket pkt;
-
-   while (!self->m_bClosing)
-   {
-      uint64_t ts = self->m_pSndUList->getNextProcTime();
-
-      if (ts > 0)
-      {
-         // wait until next processing time of the first socket on the list
-         uint64_t currtime;
-         CTimer::rdtsc(currtime);
-         if (currtime < ts)
-            self->m_pTimer->sleepto(ts);
-
-         // it is time to process it, pop it out/remove from the list
-         sockaddr* addr;
-         CPacket pkt;
-         if (self->m_pSndUList->pop(addr, pkt) < 0)
-            continue;
-
-         self->m_pChannel->sendto(addr, pkt);
-      }
-      else
-      {
-         // wait here if there is no sockets with data to be sent
-         #ifndef WIN32
-            pthread_mutex_lock(&self->m_WindowLock);
-            if (!self->m_bClosing && (self->m_pSndUList->m_iLastEntry < 0))
-               pthread_cond_wait(&self->m_WindowCond, &self->m_WindowLock);
-            pthread_mutex_unlock(&self->m_WindowLock);
-         #else
-            WaitForSingleObject(self->m_WindowCond, INFINITE);
-         #endif
-      }
-   }
-
-   #ifndef WIN32
-      return NULL;
-   #else
-      SetEvent(self->m_ExitCond);
-      return 0;
-   #endif
-}
-
-int CSndQueue::sendto(const sockaddr* addr, CPacket& packet)
-{
-   // send out the packet immediately (high priority), this is a control packet
-   m_pChannel->sendto(addr, packet);
-
-   return packet.getLength();
-}
-
-
-//
-CRcvUList::CRcvUList():
-m_pUList(NULL),
-m_pLast(NULL)
-{
-}
-
-CRcvUList::~CRcvUList()
-{
-}
-
-void CRcvUList::insert(const CUDT* u)
-{
-   CRNode* n = u->m_pRNode;
-   CTimer::rdtsc(n->m_llTimeStamp);
-
-   n->m_bOnList = true;
-
-   if (NULL == m_pUList)
-   {
-      // empty list, insert as the single node
-      n->m_pPrev = n->m_pNext = NULL;
-      m_pLast = m_pUList = n;
-
-      return;
-   }
-
-   // always insert at the end for RcvUList
-   n->m_pPrev = m_pLast;
-   n->m_pNext = NULL;
-   m_pLast->m_pNext = n;
-   m_pLast = n;
-}
-
-void CRcvUList::remove(const CUDT* u)
-{
-   CRNode* n = u->m_pRNode;
-
-   if (!n->m_bOnList)
-      return;
-
-   if (NULL == n->m_pPrev)
-   {
-      // n is the first node
-      m_pUList = n->m_pNext;
-      if (NULL == m_pUList)
-         m_pLast = NULL;
-      else
-         m_pUList->m_pPrev = NULL;
-   }
-   else
-   {
-      n->m_pPrev->m_pNext = n->m_pNext;
-      if (NULL == n->m_pNext)
-      {
-         // n is the last node
-         m_pLast = n->m_pPrev;
-      }
-      else
-         n->m_pNext->m_pPrev = n->m_pPrev;
-   }
-
-   n->m_pNext = n->m_pPrev = NULL;
-
-   n->m_bOnList = false;
-}
-
-void CRcvUList::update(const CUDT* u)
-{
-   CRNode* n = u->m_pRNode;
-
-   if (!n->m_bOnList)
-      return;
-
-   CTimer::rdtsc(n->m_llTimeStamp);
-
-   // if n is the last node, do not need to change
-   if (NULL == n->m_pNext)
-      return;
-
-   if (NULL == n->m_pPrev)
-   {
-      m_pUList = n->m_pNext;
-      m_pUList->m_pPrev = NULL;
-   }
-   else
-   {
-      n->m_pPrev->m_pNext = n->m_pNext;
-      n->m_pNext->m_pPrev = n->m_pPrev;
-   }
-
-   n->m_pPrev = m_pLast;
-   n->m_pNext = NULL;
-   m_pLast->m_pNext = n;
-   m_pLast = n;
-}
-
-//
-CHash::CHash():
-m_pBucket(NULL),
-m_iHashSize(0)
-{
-}
-
-CHash::~CHash()
-{
-   for (int i = 0; i < m_iHashSize; ++ i)
-   {
-      CBucket* b = m_pBucket[i];
-      while (NULL != b)
-      {
-         CBucket* n = b->m_pNext;
-         delete b;
-         b = n;
-      }
-   }
-
-   delete [] m_pBucket;
-}
-
-void CHash::init(const int& size)
-{
-   m_pBucket = new CBucket* [size];
-
-   for (int i = 0; i < size; ++ i)
-      m_pBucket[i] = NULL;
-
-   m_iHashSize = size;
-}
-
-CUDT* CHash::lookup(const int32_t& id)
-{
-   // simple hash function (% hash table size); suitable for socket descriptors
-   CBucket* b = m_pBucket[id % m_iHashSize];
-
-   while (NULL != b)
-   {
-      if (id == b->m_iID)
-         return b->m_pUDT;
-      b = b->m_pNext;
-   }
-
-   return NULL;
-}
-
-void CHash::insert(const int32_t& id, const CUDT* u)
-{
-   CBucket* b = m_pBucket[id % m_iHashSize];
-
-   CBucket* n = new CBucket;
-   n->m_iID = id;
-   n->m_pUDT = (CUDT*)u;
-   n->m_pNext = b;
-
-   m_pBucket[id % m_iHashSize] = n;
-}
-
-void CHash::remove(const int32_t& id)
-{
-   CBucket* b = m_pBucket[id % m_iHashSize];
-   CBucket* p = NULL;
-
-   while (NULL != b)
-   {
-      if (id == b->m_iID)
-      {
-         if (NULL == p)
-            m_pBucket[id % m_iHashSize] = b->m_pNext;
-         else
-            p->m_pNext = b->m_pNext;
-
-         delete b;
-
-         return;
-      }
-
-      p = b;
-      b = b->m_pNext;
-   }
-}
-
-
-//
-CRendezvousQueue::CRendezvousQueue()
-{
-   #ifndef WIN32
-      pthread_mutex_init(&m_RIDVectorLock, NULL);
-   #else
-      m_RIDVectorLock = CreateMutex(NULL, false, NULL);
-   #endif
-
-   m_vRendezvousID.clear();
-}
-
-CRendezvousQueue::~CRendezvousQueue()
-{
-   #ifndef WIN32
-      pthread_mutex_destroy(&m_RIDVectorLock);
-   #else
-      CloseHandle(m_RIDVectorLock);
-   #endif
-
-   for (vector<CRL>::iterator i = m_vRendezvousID.begin(); i != m_vRendezvousID.end(); ++ i)
-   {
-      if (AF_INET == i->m_iIPversion)
-         delete (sockaddr_in*)i->m_pPeerAddr;
-      else
-         delete (sockaddr_in6*)i->m_pPeerAddr;
-   }
-
-   m_vRendezvousID.clear();
-}
-
-void CRendezvousQueue::insert(const UDTSOCKET& id, const int& ipv, const sockaddr* addr)
-{
-   CGuard vg(m_RIDVectorLock);
-
-   CRL r;
-   r.m_iID = id;
-   r.m_iIPversion = ipv;
-   r.m_pPeerAddr = (AF_INET == ipv) ? (sockaddr*)new sockaddr_in : (sockaddr*)new sockaddr_in6;
-   memcpy(r.m_pPeerAddr, addr, (AF_INET == ipv) ? sizeof(sockaddr_in) : sizeof(sockaddr_in6));
-
-   m_vRendezvousID.insert(m_vRendezvousID.end(), r);
-}
-
-void CRendezvousQueue::remove(const UDTSOCKET& id)
-{
-   CGuard vg(m_RIDVectorLock);
-
-   for (vector<CRL>::iterator i = m_vRendezvousID.begin(); i != m_vRendezvousID.end(); ++ i)
-      if (i->m_iID == id)
-      {
-         if (AF_INET == i->m_iIPversion)
-            delete (sockaddr_in*)i->m_pPeerAddr;
-         else
-            delete (sockaddr_in6*)i->m_pPeerAddr;
-
-         m_vRendezvousID.erase(i);
-
-         return;
-      }
-}
-
-bool CRendezvousQueue::retrieve(const sockaddr* addr, UDTSOCKET& id)
-{
-   CGuard vg(m_RIDVectorLock);
-
-   for (vector<CRL>::iterator i = m_vRendezvousID.begin(); i != m_vRendezvousID.end(); ++ i)
-   {
-      if (CIPAddress::ipcmp(addr, i->m_pPeerAddr, i->m_iIPversion) && ((0 == id) || (id == i->m_iID)))
-      {
-         id = i->m_iID;
-         return true;
-      }
-   }
-
-   return false;
-}
-
-
-//
-CRcvQueue::CRcvQueue():
-m_pRcvUList(NULL),
-m_pHash(NULL),
-m_pChannel(NULL),
-m_pTimer(NULL),
-m_bClosing(false),
-m_pListener(NULL),
-m_pRendezvousQueue(NULL)
-{
-   #ifndef WIN32
-      pthread_mutex_init(&m_PassLock, NULL);
-      pthread_cond_init(&m_PassCond, NULL);
-      pthread_mutex_init(&m_LSLock, NULL);
-      pthread_mutex_init(&m_IDLock, NULL);
-   #else
-      m_PassLock = CreateMutex(NULL, false, NULL);
-      m_PassCond = CreateEvent(NULL, false, false, NULL);
-      m_LSLock = CreateMutex(NULL, false, NULL);
-      m_IDLock = CreateMutex(NULL, false, NULL);
-      m_ExitCond = CreateEvent(NULL, false, false, NULL);
-   #endif
-
-   m_vNewEntry.clear();
-   m_mBuffer.clear();
-}
-
-CRcvQueue::~CRcvQueue()
-{
-   m_bClosing = true;
-
-   #ifndef WIN32
-      if (0 != m_WorkerThread)
-         pthread_join(m_WorkerThread, NULL);
-      pthread_mutex_destroy(&m_PassLock);
-      pthread_cond_destroy(&m_PassCond);
-      pthread_mutex_destroy(&m_LSLock);
-      pthread_mutex_destroy(&m_IDLock);
-   #else
-      if (NULL != m_WorkerThread)
-         WaitForSingleObject(m_ExitCond, INFINITE);
-      CloseHandle(m_WorkerThread);
-      CloseHandle(m_PassLock);
-      CloseHandle(m_PassCond);
-      CloseHandle(m_LSLock);
-      CloseHandle(m_IDLock);
-   #endif
-
-   delete m_pRcvUList;
-   delete m_pHash;
-   delete m_pRendezvousQueue;
-
-   for (map<int32_t, CPacket*>::iterator i = m_mBuffer.begin(); i != m_mBuffer.end(); ++ i)
-   {
-      delete [] i->second->m_pcData;
-      delete i->second;
-   }
-}
-
-void CRcvQueue::init(const int& qsize, const int& payload, const int& version, const int& hsize, const CChannel* cc, const CTimer* t)
-{
-   m_iPayloadSize = payload;
-
-   m_UnitQueue.init(qsize, payload, version);
-
-   m_pHash = new CHash;
-   m_pHash->init(hsize);
-
-   m_pChannel = (CChannel*)cc;
-   m_pTimer = (CTimer*)t;
-
-   m_pRcvUList = new CRcvUList;
-   m_pRendezvousQueue = new CRendezvousQueue;
-
-   #ifndef WIN32
-      if (0 != pthread_create(&m_WorkerThread, NULL, CRcvQueue::worker, this))
-      {
-         m_WorkerThread = 0;
-         throw CUDTException(3, 1);
-      }
-   #else
-      DWORD threadID;
-      m_WorkerThread = CreateThread(NULL, 0, CRcvQueue::worker, this, 0, &threadID);
-      if (NULL == m_WorkerThread)
-         throw CUDTException(3, 1);
-   #endif
-}
-
-#ifndef WIN32
-   void* CRcvQueue::worker(void* param)
-#else
-   DWORD WINAPI CRcvQueue::worker(LPVOID param)
-#endif
-{
-   CRcvQueue* self = (CRcvQueue*)param;
-
-   sockaddr* addr = (AF_INET == self->m_UnitQueue.m_iIPversion) ? (sockaddr*) new sockaddr_in : (sockaddr*) new sockaddr_in6;
-   CUDT* u = NULL;
-   int32_t id;
-
-   while (!self->m_bClosing)
-   {
-      #ifdef NO_BUSY_WAITING
-         self->m_pTimer->tick();
-      #endif
-
-      // check waiting list, if new socket, insert it to the list
-      if (self->ifNewEntry())
-      {
-         CUDT* ne = self->getNewEntry();
-         if (NULL != ne)
-         {
-            self->m_pRcvUList->insert(ne);
-            self->m_pHash->insert(ne->m_SocketID, ne);
-         }
-      }
-
-      // find next available slot for incoming packet
-      CUnit* unit = self->m_UnitQueue.getNextAvailUnit();
-      if (NULL == unit)
-      {
-         // no space, skip this packet
-         CUnit temp;
-         temp.m_Packet.m_pcData = new char[self->m_iPayloadSize];
-         self->m_pChannel->recvfrom(addr, temp.m_Packet);
-         delete [] temp.m_Packet.m_pcData;
-         goto TIMER_CHECK;
-      }
-
-      unit->m_Packet.setLength(self->m_iPayloadSize);
-
-      // reading next incoming packet
-      if (self->m_pChannel->recvfrom(addr, unit->m_Packet) <= 0)
-         goto TIMER_CHECK;
-
-      id = unit->m_Packet.m_iID;
-
-      // ID 0 is for connection request, which should be passed to the listening socket or rendezvous sockets
-      if (0 == id)
-      {
-         if (NULL != self->m_pListener)
-            ((CUDT*)self->m_pListener)->listen(addr, unit->m_Packet);
-         else if (self->m_pRendezvousQueue->retrieve(addr, id))
-            self->storePkt(id, unit->m_Packet.clone());
-      }
-      else if (id > 0)
-      {
-         if (NULL != (u = self->m_pHash->lookup(id)))
-         {
-            if (CIPAddress::ipcmp(addr, u->m_pPeerAddr, u->m_iIPversion))
-            {
-               if (u->m_bConnected && !u->m_bBroken && !u->m_bClosing)
-               {
-                  if (0 == unit->m_Packet.getFlag())
-                     u->processData(unit);
-                  else
-                     u->processCtrl(unit->m_Packet);
-
-                  u->checkTimers();
-                  self->m_pRcvUList->update(u);
-               }
-            }
-         }
-         else if (self->m_pRendezvousQueue->retrieve(addr, id))
-            self->storePkt(id, unit->m_Packet.clone());
-      }
-
-TIMER_CHECK:
-      // take care of the timing event for all UDT sockets
-
-      CRNode* ul = self->m_pRcvUList->m_pUList;
-      uint64_t currtime;
-      CTimer::rdtsc(currtime);
-      uint64_t ctime = currtime - 100000 * CTimer::getCPUFrequency();
-
-      while ((NULL != ul) && (ul->m_llTimeStamp < ctime))
-      {
-         CUDT* u = ul->m_pUDT;
-
-         if (u->m_bConnected && !u->m_bBroken && !u->m_bClosing)
-         {
-            u->checkTimers();
-            self->m_pRcvUList->update(u);
-         }
-         else
-         {
-            // the socket must be removed from Hash table first, then RcvUList
-            self->m_pHash->remove(u->m_SocketID);
-            self->m_pRcvUList->remove(u);
-         }
-
-         ul = self->m_pRcvUList->m_pUList;
-      }
-   }
-
-   if (AF_INET == self->m_UnitQueue.m_iIPversion)
-      delete (sockaddr_in*)addr;
-   else
-      delete (sockaddr_in6*)addr;
-
-   #ifndef WIN32
-      return NULL;
-   #else
-      SetEvent(self->m_ExitCond);
-      return 0;
-   #endif
-}
-
-int CRcvQueue::recvfrom(const int32_t& id, CPacket& packet)
-{
-   CGuard bufferlock(m_PassLock);
-
-   map<int32_t, CPacket*>::iterator i = m_mBuffer.find(id);
-
-   if (i == m_mBuffer.end())
-   {
-      #ifndef WIN32
-         uint64_t now = CTimer::getTime();
-         timespec timeout;
-
-         timeout.tv_sec = now / 1000000 + 1;
-         timeout.tv_nsec = (now % 1000000) * 1000;
-
-         pthread_cond_timedwait(&m_PassCond, &m_PassLock, &timeout);
-      #else
-         ReleaseMutex(m_PassLock);
-         WaitForSingleObject(m_PassCond, 1000);
-         WaitForSingleObject(m_PassLock, INFINITE);
-      #endif
-
-      i = m_mBuffer.find(id);
-      if (i == m_mBuffer.end())
-      {
-         packet.setLength(-1);
-         return -1;
-      }
-   }
-
-   if (packet.getLength() < i->second->getLength())
-   {
-      packet.setLength(-1);
-      return -1;
-   }
-
-   memcpy(packet.m_nHeader, i->second->m_nHeader, CPacket::m_iPktHdrSize);
-   memcpy(packet.m_pcData, i->second->m_pcData, i->second->getLength());
-   packet.setLength(i->second->getLength());
-
-   delete [] i->second->m_pcData;
-   delete i->second;
-   m_mBuffer.erase(i);
-
-   return packet.getLength();
-}
-
-int CRcvQueue::setListener(const CUDT* u)
-{
-   CGuard lslock(m_LSLock);
-
-   if (NULL != m_pListener)
-      return -1;
-
-   m_pListener = (CUDT*)u;
-   return 1;
-}
-
-void CRcvQueue::removeListener(const CUDT* u)
-{
-   CGuard lslock(m_LSLock);
-
-   if (u == m_pListener)
-      m_pListener = NULL;
-}
-
-void CRcvQueue::setNewEntry(CUDT* u)
-{
-   CGuard listguard(m_IDLock);
-   m_vNewEntry.insert(m_vNewEntry.end(), u);
-}
-
-bool CRcvQueue::ifNewEntry()
-{
-   return !(m_vNewEntry.empty());
-}
-
-CUDT* CRcvQueue::getNewEntry()
-{
-   CGuard listguard(m_IDLock);
-
-   if (m_vNewEntry.empty())
-      return NULL;
-
-   CUDT* u = (CUDT*)*(m_vNewEntry.begin());
-   m_vNewEntry.erase(m_vNewEntry.begin());
-
-   return u;
-}
-
-void CRcvQueue::storePkt(const int32_t& id, CPacket* pkt)
-{
-   #ifndef WIN32
-      pthread_mutex_lock(&m_PassLock);
-   #else
-      WaitForSingleObject(m_PassLock, INFINITE);
-   #endif
-
-   map<int32_t, CPacket*>::iterator i = m_mBuffer.find(id);
-
-   if (i == m_mBuffer.end())
-      m_mBuffer[id] = pkt;
-   else
-   {
-      delete [] i->second->m_pcData;
-      delete i->second;
-      i->second = pkt;
-   }
-
-   #ifndef WIN32
-      pthread_mutex_unlock(&m_PassLock);
-      pthread_cond_signal(&m_PassCond);
-   #else
-      ReleaseMutex(m_PassLock);
-      SetEvent(m_PassCond);
-   #endif
-}
+/*****************************************************************************
+Copyright (c) 2001 - 2008, The Board of Trustees of the University of Illinois.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+
+* Redistributions of source code must retain the above
+  copyright notice, this list of conditions and the
+  following disclaimer.
+
+* Redistributions in binary form must reproduce the
+  above copyright notice, this list of conditions
+  and the following disclaimer in the documentation
+  and/or other materials provided with the distribution.
+
+* Neither the name of the University of Illinois
+  nor the names of its contributors may be used to
+  endorse or promote products derived from this
+  software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*****************************************************************************/
+
+/*****************************************************************************
+written by
+   Yunhong Gu, last updated 12/08/2008
+*****************************************************************************/
+
+#ifdef WIN32
+   #include <winsock2.h>
+   #include <ws2tcpip.h>
+   #ifdef __MSVC__
+    #include <wspiapi.h>
+   #endif
+#endif
+
+#include <cstring>
+#include "common.h"
+#include "queue.h"
+#include "core.h"
+
+using namespace std;
+
+CUnitQueue::CUnitQueue():
+m_pQEntry(NULL),
+m_pCurrQueue(NULL),
+m_pLastQueue(NULL),m_pAvailUnit(),
+m_iSize(0),
+m_iCount(0), m_iMSS(), m_iIPversion()
+{
+}
+
+CUnitQueue::~CUnitQueue()
+{
+   CQEntry* p = m_pQEntry;
+
+   while (p != NULL)
+   {
+      delete [] p->m_pUnit;
+      delete [] p->m_pBuffer;
+
+      CQEntry* q = p;
+      if (p == m_pLastQueue)
+         p = NULL;
+      else
+         p = p->m_pNext;
+      delete q;
+   }
+}
+
+int CUnitQueue::init(const int& size, const int& mss, const int& version)
+{
+   CQEntry* tempq = NULL;
+   CUnit* tempu = NULL;
+   char* tempb = NULL;
+
+   try
+   {
+      tempq = new CQEntry;
+      tempu = new CUnit [size];
+      tempb = new char [size * mss];
+   }
+   catch (...)
+   {
+      delete tempq;
+      delete [] tempu;
+      delete [] tempb;
+
+      return -1;
+   }
+
+   for (int i = 0; i < size; ++ i)
+   {
+      tempu[i].m_iFlag = 0;
+      tempu[i].m_Packet.m_pcData = tempb + i * mss;
+   }
+   tempq->m_pUnit = tempu;
+   tempq->m_pBuffer = tempb;
+   tempq->m_iSize = size;
+
+   m_pQEntry = m_pCurrQueue = m_pLastQueue = tempq;
+   m_pQEntry->m_pNext = m_pQEntry;
+
+   m_pAvailUnit = m_pCurrQueue->m_pUnit;
+
+   m_iSize = size;
+   m_iMSS = mss;
+   m_iIPversion = version;
+
+   return 0;
+}
+
+int CUnitQueue::increase()
+{
+   // adjust/correct m_iCount
+   int real_count = 0;
+   CQEntry* p = m_pQEntry;
+   while (p != NULL)
+   {
+      CUnit* u = p->m_pUnit;
+      for (CUnit* end = u + p->m_iSize; u != end; ++ u)
+         if (u->m_iFlag != 0)
+            ++ real_count;
+
+      if (p == m_pLastQueue)
+         p = NULL;
+      else
+         p = p->m_pNext;
+   }
+   m_iCount = real_count;
+   if (double(m_iCount) / m_iSize < 0.9)
+      return -1;
+
+   CQEntry* tempq = NULL;
+   CUnit* tempu = NULL;
+   char* tempb = NULL;
+
+   // all queues have the same size
+   int size = m_pQEntry->m_iSize;
+
+   try
+   {
+      tempq = new CQEntry;
+      tempu = new CUnit [size];
+      tempb = new char [size * m_iMSS];
+   }
+   catch (...)
+   {
+      delete tempq;
+      delete [] tempu;
+      delete [] tempb;
+
+      return -1;
+   }
+
+   for (int i = 0; i < size; ++ i)
+   {
+      tempu[i].m_iFlag = 0;
+      tempu[i].m_Packet.m_pcData = tempb + i * m_iMSS;
+   }
+   tempq->m_pUnit = tempu;
+   tempq->m_pBuffer = tempb;
+   tempq->m_iSize = size;
+
+   m_pLastQueue->m_pNext = tempq;
+   m_pLastQueue = tempq;
+   m_pLastQueue->m_pNext = m_pQEntry;
+
+   m_iSize += size;
+
+   return 0;
+}
+
+int CUnitQueue::shrink()
+{
+   // currently queue cannot be shrunk.
+   return -1;
+}
+
+CUnit* CUnitQueue::getNextAvailUnit()
+{
+   if (m_iCount * 10 > m_iSize * 9)
+      increase();
+
+   if (m_iCount >= m_iSize)
+      return NULL;
+
+   CQEntry* entrance = m_pCurrQueue;
+
+   do
+   {
+      for (CUnit* sentinel = m_pCurrQueue->m_pUnit + m_pCurrQueue->m_iSize - 1; m_pAvailUnit != sentinel; ++ m_pAvailUnit)
+         if (m_pAvailUnit->m_iFlag == 0)
+            return m_pAvailUnit;
+
+      if (m_pCurrQueue->m_pUnit->m_iFlag == 0)
+      {
+         m_pAvailUnit = m_pCurrQueue->m_pUnit;
+         return m_pAvailUnit;
+      }
+
+      m_pCurrQueue = m_pCurrQueue->m_pNext;
+      m_pAvailUnit = m_pCurrQueue->m_pUnit;
+   } while (m_pCurrQueue != entrance);
+
+   increase();
+
+   return NULL;
+}
+
+
+CSndUList::CSndUList() : m_pHeap(), m_iArrayLength(4096), m_iLastEntry(-1),
+m_ListLock(), m_pWindowLock(), m_pWindowCond(), m_pTimer()
+{
+
+   m_pHeap = new CSNode*[m_iArrayLength];
+
+   #ifndef WIN32
+      pthread_mutex_init(&m_ListLock, NULL);
+   #else
+      m_ListLock = CreateMutex(NULL, false, NULL);
+   #endif
+}
+
+CSndUList::~CSndUList()
+{
+   delete [] m_pHeap;
+
+   #ifndef WIN32
+      pthread_mutex_destroy(&m_ListLock);
+   #else
+      CloseHandle(m_ListLock);
+   #endif
+}
+
+void CSndUList::insert(const int64_t& ts, const CUDT* u)
+{
+   CGuard listguard(m_ListLock);
+
+   // increase the heap array size if necessary
+   if (m_iLastEntry == m_iArrayLength - 1)
+   {
+      CSNode** temp = NULL;
+
+      try
+      {
+         temp = new CSNode*[m_iArrayLength * 2];
+      }
+      catch(...)
+      {
+         return;
+      }
+
+      memcpy(temp, m_pHeap, sizeof(CSNode*) * m_iArrayLength);
+      m_iArrayLength *= 2;
+      delete [] m_pHeap;
+      m_pHeap = temp;
+   }
+
+   insert_(ts, u);
+}
+
+void CSndUList::update(const CUDT* u, const bool& reschedule)
+{
+   CGuard listguard(m_ListLock);
+
+   CSNode* n = u->m_pSNode;
+
+   if (n->m_iHeapLoc >= 0)
+   {
+      if (!reschedule)
+         return;
+
+      if (n->m_iHeapLoc == 0)
+      {
+         n->m_llTimeStamp = 1;
+         m_pTimer->interrupt();
+         return;
+      }
+
+      remove_(u);
+   }
+
+   insert_(1, u);
+}
+
+int CSndUList::pop(sockaddr*& addr, CPacket& pkt)
+{
+   CGuard listguard(m_ListLock);
+
+   if (-1 == m_iLastEntry)
+      return -1;
+
+   CUDT* u = m_pHeap[0]->m_pUDT;
+   remove_(u);
+
+   if (!u->m_bConnected || u->m_bBroken)
+      return -1;
+
+   // pack a packet from the socket
+   uint64_t ts;
+   if (u->packData(pkt, ts) <= 0)
+      return -1;
+
+   addr = u->m_pPeerAddr;
+
+   // insert a new entry, ts is the next processing time
+   if (ts > 0)
+      insert_(ts, u);
+
+   return 1;
+}
+
+void CSndUList::remove(const CUDT* u)
+{
+   CGuard listguard(m_ListLock);
+
+   remove_(u);
+}
+
+uint64_t CSndUList::getNextProcTime()
+{
+   CGuard listguard(m_ListLock);
+
+   if (-1 == m_iLastEntry)
+      return 0;
+
+   return m_pHeap[0]->m_llTimeStamp;
+}
+
+void CSndUList::insert_(const int64_t& ts, const CUDT* u)
+{
+   CSNode* n = u->m_pSNode;
+
+   // do not insert repeated node
+   if (n->m_iHeapLoc >= 0)
+      return;
+
+   m_iLastEntry ++;
+   m_pHeap[m_iLastEntry] = n;
+   n->m_llTimeStamp = ts;
+
+   int q = m_iLastEntry;
+   int p = q;
+   while (p != 0)
+   {
+      p = (q - 1) >> 1;
+      if (m_pHeap[p]->m_llTimeStamp > m_pHeap[q]->m_llTimeStamp)
+      {
+         CSNode* t = m_pHeap[p];
+         m_pHeap[p] = m_pHeap[q];
+         m_pHeap[q] = t;
+         t->m_iHeapLoc = q;
+         q = p;
+      }
+      else
+         break;
+   }
+
+   n->m_iHeapLoc = q;
+
+   // first entry, activate the sending queue
+   if (0 == m_iLastEntry)
+   {
+      #ifndef WIN32
+         pthread_mutex_lock(m_pWindowLock);
+         pthread_cond_signal(m_pWindowCond);
+         pthread_mutex_unlock(m_pWindowLock);
+      #else
+         SetEvent(*m_pWindowCond);
+      #endif
+   }
+}
+
+void CSndUList::remove_(const CUDT* u)
+{
+   CSNode* n = u->m_pSNode;
+
+   if (n->m_iHeapLoc >= 0)
+   {
+      // remove the node from heap
+      m_pHeap[n->m_iHeapLoc] = m_pHeap[m_iLastEntry];
+      m_iLastEntry --;
+      m_pHeap[n->m_iHeapLoc]->m_iHeapLoc = n->m_iHeapLoc;
+
+      int q = n->m_iHeapLoc;
+      int p = q * 2 + 1;
+      while (p <= m_iLastEntry)
+      {
+         if ((p + 1 <= m_iLastEntry) && (m_pHeap[p]->m_llTimeStamp > m_pHeap[p + 1]->m_llTimeStamp))
+            p ++;
+
+         if (m_pHeap[q]->m_llTimeStamp > m_pHeap[p]->m_llTimeStamp)
+         {
+            CSNode* t = m_pHeap[p];
+            m_pHeap[p] = m_pHeap[q];
+            m_pHeap[p]->m_iHeapLoc = p;
+            m_pHeap[q] = t;
+            m_pHeap[q]->m_iHeapLoc = q;
+
+            q = p;
+            p = q * 2 + 1;
+         }
+         else
+            break;
+      }
+
+      n->m_iHeapLoc = -1;
+   }
+}
+
+//
+CSndQueue::CSndQueue():
+m_WorkerThread(),
+m_pSndUList(),
+m_pChannel(),
+m_pTimer(),
+m_WindowLock(),
+m_WindowCond(),
+m_bClosing(false),
+m_ExitCond()
+{
+   #ifndef WIN32
+      pthread_cond_init(&m_WindowCond, NULL);
+      pthread_mutex_init(&m_WindowLock, NULL);
+   #else
+      m_WindowLock = CreateMutex(NULL, false, NULL);
+      m_WindowCond = CreateEvent(NULL, false, false, NULL);
+      m_ExitCond = CreateEvent(NULL, false, false, NULL);
+   #endif
+}
+
+CSndQueue::~CSndQueue()
+{
+   m_bClosing = true;
+
+   #ifndef WIN32
+      pthread_mutex_lock(&m_WindowLock);
+      pthread_cond_signal(&m_WindowCond);
+      pthread_mutex_unlock(&m_WindowLock);
+      if (0 != m_WorkerThread)
+         pthread_join(m_WorkerThread, NULL);
+      pthread_cond_destroy(&m_WindowCond);
+      pthread_mutex_destroy(&m_WindowLock);
+   #else
+      SetEvent(m_WindowCond);
+      if (NULL != m_WorkerThread)
+         WaitForSingleObject(m_ExitCond, INFINITE);
+      CloseHandle(m_WorkerThread);
+      CloseHandle(m_WindowLock);
+      CloseHandle(m_WindowCond);
+   #endif
+
+   delete m_pSndUList;
+}
+
+void CSndQueue::init(const CChannel* c, const CTimer* t)
+{
+   m_pChannel = (CChannel*)c;
+   m_pTimer = (CTimer*)t;
+   m_pSndUList = new CSndUList;
+   m_pSndUList->m_pWindowLock = &m_WindowLock;
+   m_pSndUList->m_pWindowCond = &m_WindowCond;
+   m_pSndUList->m_pTimer = m_pTimer;
+
+   #ifndef WIN32
+      if (0 != pthread_create(&m_WorkerThread, NULL, CSndQueue::worker, this))
+      {
+         m_WorkerThread = 0;
+         throw CUDTException(3, 1);
+      }
+   #else
+      DWORD threadID;
+      m_WorkerThread = CreateThread(NULL, 0, CSndQueue::worker, this, 0, &threadID);
+      if (NULL == m_WorkerThread)
+         throw CUDTException(3, 1);
+   #endif
+}
+
+#ifndef WIN32
+   void* CSndQueue::worker(void* param)
+#else
+   DWORD WINAPI CSndQueue::worker(LPVOID param)
+#endif
+{
+   CSndQueue* self = (CSndQueue*)param;
+
+   CPacket pkt;
+
+   while (!self->m_bClosing)
+   {
+      uint64_t ts = self->m_pSndUList->getNextProcTime();
+
+      if (ts > 0)
+      {
+         // wait until next processing time of the first socket on the list
+         uint64_t currtime;
+         CTimer::rdtsc(currtime);
+         if (currtime < ts)
+            self->m_pTimer->sleepto(ts);
+
+         // it is time to process it, pop it out/remove from the list
+         sockaddr* addr;
+         CPacket pkt;
+         if (self->m_pSndUList->pop(addr, pkt) < 0)
+            continue;
+
+         self->m_pChannel->sendto(addr, pkt);
+      }
+      else
+      {
+         // wait here if there is no sockets with data to be sent
+         #ifndef WIN32
+            pthread_mutex_lock(&self->m_WindowLock);
+            if (!self->m_bClosing && (self->m_pSndUList->m_iLastEntry < 0))
+               pthread_cond_wait(&self->m_WindowCond, &self->m_WindowLock);
+            pthread_mutex_unlock(&self->m_WindowLock);
+         #else
+            WaitForSingleObject(self->m_WindowCond, INFINITE);
+         #endif
+      }
+   }
+
+   #ifndef WIN32
+      return NULL;
+   #else
+      SetEvent(self->m_ExitCond);
+      return 0;
+   #endif
+}
+
+int CSndQueue::sendto(const sockaddr* addr, CPacket& packet)
+{
+   // send out the packet immediately (high priority), this is a control packet
+   m_pChannel->sendto(addr, packet);
+
+   return packet.getLength();
+}
+
+
+//
+CRcvUList::CRcvUList():
+m_pUList(NULL),
+m_pLast(NULL)
+{
+}
+
+CRcvUList::~CRcvUList()
+{
+}
+
+void CRcvUList::insert(const CUDT* u)
+{
+   CRNode* n = u->m_pRNode;
+   CTimer::rdtsc(n->m_llTimeStamp);
+
+   n->m_bOnList = true;
+
+   if (NULL == m_pUList)
+   {
+      // empty list, insert as the single node
+      n->m_pPrev = n->m_pNext = NULL;
+      m_pLast = m_pUList = n;
+
+      return;
+   }
+
+   // always insert at the end for RcvUList
+   n->m_pPrev = m_pLast;
+   n->m_pNext = NULL;
+   m_pLast->m_pNext = n;
+   m_pLast = n;
+}
+
+void CRcvUList::remove(const CUDT* u)
+{
+   CRNode* n = u->m_pRNode;
+
+   if (!n->m_bOnList)
+      return;
+
+   if (NULL == n->m_pPrev)
+   {
+      // n is the first node
+      m_pUList = n->m_pNext;
+      if (NULL == m_pUList)
+         m_pLast = NULL;
+      else
+         m_pUList->m_pPrev = NULL;
+   }
+   else
+   {
+      n->m_pPrev->m_pNext = n->m_pNext;
+      if (NULL == n->m_pNext)
+      {
+         // n is the last node
+         m_pLast = n->m_pPrev;
+      }
+      else
+         n->m_pNext->m_pPrev = n->m_pPrev;
+   }
+
+   n->m_pNext = n->m_pPrev = NULL;
+
+   n->m_bOnList = false;
+}
+
+void CRcvUList::update(const CUDT* u)
+{
+   CRNode* n = u->m_pRNode;
+
+   if (!n->m_bOnList)
+      return;
+
+   CTimer::rdtsc(n->m_llTimeStamp);
+
+   // if n is the last node, do not need to change
+   if (NULL == n->m_pNext)
+      return;
+
+   if (NULL == n->m_pPrev)
+   {
+      m_pUList = n->m_pNext;
+      m_pUList->m_pPrev = NULL;
+   }
+   else
+   {
+      n->m_pPrev->m_pNext = n->m_pNext;
+      n->m_pNext->m_pPrev = n->m_pPrev;
+   }
+
+   n->m_pPrev = m_pLast;
+   n->m_pNext = NULL;
+   m_pLast->m_pNext = n;
+   m_pLast = n;
+}
+
+//
+CHash::CHash():
+m_pBucket(NULL),
+m_iHashSize(0)
+{
+}
+
+CHash::~CHash()
+{
+   for (int i = 0; i < m_iHashSize; ++ i)
+   {
+      CBucket* b = m_pBucket[i];
+      while (NULL != b)
+      {
+         CBucket* n = b->m_pNext;
+         delete b;
+         b = n;
+      }
+   }
+
+   delete [] m_pBucket;
+}
+
+void CHash::init(const int& size)
+{
+   m_pBucket = new CBucket* [size];
+
+   for (int i = 0; i < size; ++ i)
+      m_pBucket[i] = NULL;
+
+   m_iHashSize = size;
+}
+
+CUDT* CHash::lookup(const int32_t& id)
+{
+   // simple hash function (% hash table size); suitable for socket descriptors
+   CBucket* b = m_pBucket[id % m_iHashSize];
+
+   while (NULL != b)
+   {
+      if (id == b->m_iID)
+         return b->m_pUDT;
+      b = b->m_pNext;
+   }
+
+   return NULL;
+}
+
+void CHash::insert(const int32_t& id, const CUDT* u)
+{
+   CBucket* b = m_pBucket[id % m_iHashSize];
+
+   CBucket* n = new CBucket;
+   n->m_iID = id;
+   n->m_pUDT = (CUDT*)u;
+   n->m_pNext = b;
+
+   m_pBucket[id % m_iHashSize] = n;
+}
+
+void CHash::remove(const int32_t& id)
+{
+   CBucket* b = m_pBucket[id % m_iHashSize];
+   CBucket* p = NULL;
+
+   while (NULL != b)
+   {
+      if (id == b->m_iID)
+      {
+         if (NULL == p)
+            m_pBucket[id % m_iHashSize] = b->m_pNext;
+         else
+            p->m_pNext = b->m_pNext;
+
+         delete b;
+
+         return;
+      }
+
+      p = b;
+      b = b->m_pNext;
+   }
+}
+
+
+//
+CRendezvousQueue::CRendezvousQueue() : m_vRendezvousID(), m_RIDVectorLock()
+{
+   #ifndef WIN32
+      pthread_mutex_init(&m_RIDVectorLock, NULL);
+   #else
+      m_RIDVectorLock = CreateMutex(NULL, false, NULL);
+   #endif
+
+   m_vRendezvousID.clear();
+}
+
+CRendezvousQueue::~CRendezvousQueue()
+{
+   #ifndef WIN32
+      pthread_mutex_destroy(&m_RIDVectorLock);
+   #else
+      CloseHandle(m_RIDVectorLock);
+   #endif
+
+   for (vector<CRL>::iterator i = m_vRendezvousID.begin(); i != m_vRendezvousID.end(); ++ i)
+   {
+      if (AF_INET == i->m_iIPversion)
+         delete (sockaddr_in*)i->m_pPeerAddr;
+      else
+         delete (sockaddr_in6*)i->m_pPeerAddr;
+   }
+
+   m_vRendezvousID.clear();
+}
+
+void CRendezvousQueue::insert(const UDTSOCKET& id, const int& ipv, const sockaddr* addr)
+{
+   CGuard vg(m_RIDVectorLock);
+
+   CRL r;
+   r.m_iID = id;
+   r.m_iIPversion = ipv;
+   r.m_pPeerAddr = (AF_INET == ipv) ? (sockaddr*)new sockaddr_in : (sockaddr*)new sockaddr_in6;
+   memcpy(r.m_pPeerAddr, addr, (AF_INET == ipv) ? sizeof(sockaddr_in) : sizeof(sockaddr_in6));
+
+   m_vRendezvousID.insert(m_vRendezvousID.end(), r);
+}
+
+void CRendezvousQueue::remove(const UDTSOCKET& id)
+{
+   CGuard vg(m_RIDVectorLock);
+
+   for (vector<CRL>::iterator i = m_vRendezvousID.begin(); i != m_vRendezvousID.end(); ++ i)
+      if (i->m_iID == id)
+      {
+         if (AF_INET == i->m_iIPversion)
+            delete (sockaddr_in*)i->m_pPeerAddr;
+         else
+            delete (sockaddr_in6*)i->m_pPeerAddr;
+
+         m_vRendezvousID.erase(i);
+
+         return;
+      }
+}
+
+bool CRendezvousQueue::retrieve(const sockaddr* addr, UDTSOCKET& id)
+{
+   CGuard vg(m_RIDVectorLock);
+
+   for (vector<CRL>::iterator i = m_vRendezvousID.begin(); i != m_vRendezvousID.end(); ++ i)
+   {
+      if (CIPAddress::ipcmp(addr, i->m_pPeerAddr, i->m_iIPversion) && ((0 == id) || (id == i->m_iID)))
+      {
+         id = i->m_iID;
+         return true;
+      }
+   }
+
+   return false;
+}
+
+
+//
+CRcvQueue::CRcvQueue():
+m_WorkerThread(),
+m_UnitQueue(),
+m_pRcvUList(),
+m_pHash(),
+m_pChannel(),
+m_pTimer(),
+m_iPayloadSize(),
+m_bClosing(false),
+m_ExitCond(),
+m_LSLock(),
+m_pListener(),
+m_pRendezvousQueue(),
+m_vNewEntry(),
+m_IDLock(),
+m_mBuffer(),
+m_PassLock(),
+m_PassCond()
+{
+   #ifndef WIN32
+      pthread_mutex_init(&m_PassLock, NULL);
+      pthread_cond_init(&m_PassCond, NULL);
+      pthread_mutex_init(&m_LSLock, NULL);
+      pthread_mutex_init(&m_IDLock, NULL);
+   #else
+      m_PassLock = CreateMutex(NULL, false, NULL);
+      m_PassCond = CreateEvent(NULL, false, false, NULL);
+      m_LSLock = CreateMutex(NULL, false, NULL);
+      m_IDLock = CreateMutex(NULL, false, NULL);
+      m_ExitCond = CreateEvent(NULL, false, false, NULL);
+   #endif
+
+   m_vNewEntry.clear();
+   m_mBuffer.clear();
+}
+
+CRcvQueue::~CRcvQueue()
+{
+   m_bClosing = true;
+
+   #ifndef WIN32
+      if (0 != m_WorkerThread)
+         pthread_join(m_WorkerThread, NULL);
+      pthread_mutex_destroy(&m_PassLock);
+      pthread_cond_destroy(&m_PassCond);
+      pthread_mutex_destroy(&m_LSLock);
+      pthread_mutex_destroy(&m_IDLock);
+   #else
+      if (NULL != m_WorkerThread)
+         WaitForSingleObject(m_ExitCond, INFINITE);
+      CloseHandle(m_WorkerThread);
+      CloseHandle(m_PassLock);
+      CloseHandle(m_PassCond);
+      CloseHandle(m_LSLock);
+      CloseHandle(m_IDLock);
+   #endif
+
+   delete m_pRcvUList;
+   delete m_pHash;
+   delete m_pRendezvousQueue;
+
+   for (map<int32_t, CPacket*>::iterator i = m_mBuffer.begin(); i != m_mBuffer.end(); ++ i)
+   {
+      delete [] i->second->m_pcData;
+      delete i->second;
+   }
+}
+
+void CRcvQueue::init(const int& qsize, const int& payload, const int& version, const int& hsize, const CChannel* cc, const CTimer* t)
+{
+   m_iPayloadSize = payload;
+
+   m_UnitQueue.init(qsize, payload, version);
+
+   m_pHash = new CHash;
+   m_pHash->init(hsize);
+
+   m_pChannel = (CChannel*)cc;
+   m_pTimer = (CTimer*)t;
+
+   m_pRcvUList = new CRcvUList;
+   m_pRendezvousQueue = new CRendezvousQueue;
+
+   #ifndef WIN32
+      if (0 != pthread_create(&m_WorkerThread, NULL, CRcvQueue::worker, this))
+      {
+         m_WorkerThread = 0;
+         throw CUDTException(3, 1);
+      }
+   #else
+      DWORD threadID;
+      m_WorkerThread = CreateThread(NULL, 0, CRcvQueue::worker, this, 0, &threadID);
+      if (NULL == m_WorkerThread)
+         throw CUDTException(3, 1);
+   #endif
+}
+
+#ifndef WIN32
+   void* CRcvQueue::worker(void* param)
+#else
+   DWORD WINAPI CRcvQueue::worker(LPVOID param)
+#endif
+{
+   CRcvQueue* self = (CRcvQueue*)param;
+
+   sockaddr* addr = (AF_INET == self->m_UnitQueue.m_iIPversion) ? (sockaddr*) new sockaddr_in : (sockaddr*) new sockaddr_in6;
+   CUDT* u = NULL;
+   int32_t id;
+
+   while (!self->m_bClosing)
+   {
+      #ifdef NO_BUSY_WAITING
+         self->m_pTimer->tick();
+      #endif
+
+      // check waiting list, if new socket, insert it to the list
+      if (self->ifNewEntry())
+      {
+         CUDT* ne = self->getNewEntry();
+         if (NULL != ne)
+         {
+            self->m_pRcvUList->insert(ne);
+            self->m_pHash->insert(ne->m_SocketID, ne);
+         }
+      }
+
+      // find next available slot for incoming packet
+      CUnit* unit = self->m_UnitQueue.getNextAvailUnit();
+      if (NULL == unit)
+      {
+         // no space, skip this packet
+         CUnit temp;
+         temp.m_Packet.m_pcData = new char[self->m_iPayloadSize];
+         self->m_pChannel->recvfrom(addr, temp.m_Packet);
+         delete [] temp.m_Packet.m_pcData;
+         goto TIMER_CHECK;
+      }
+
+      unit->m_Packet.setLength(self->m_iPayloadSize);
+
+      // reading next incoming packet
+      if (self->m_pChannel->recvfrom(addr, unit->m_Packet) <= 0)
+         goto TIMER_CHECK;
+
+      id = unit->m_Packet.m_iID;
+
+      // ID 0 is for connection request, which should be passed to the listening socket or rendezvous sockets
+      if (0 == id)
+      {
+         if (NULL != self->m_pListener)
+            ((CUDT*)self->m_pListener)->listen(addr, unit->m_Packet);
+         else if (self->m_pRendezvousQueue->retrieve(addr, id))
+            self->storePkt(id, unit->m_Packet.clone());
+      }
+      else if (id > 0)
+      {
+         if (NULL != (u = self->m_pHash->lookup(id)))
+         {
+            if (CIPAddress::ipcmp(addr, u->m_pPeerAddr, u->m_iIPversion))
+            {
+               if (u->m_bConnected && !u->m_bBroken && !u->m_bClosing)
+               {
+                  if (0 == unit->m_Packet.getFlag())
+                     u->processData(unit);
+                  else
+                     u->processCtrl(unit->m_Packet);
+
+                  u->checkTimers();
+                  self->m_pRcvUList->update(u);
+               }
+            }
+         }
+         else if (self->m_pRendezvousQueue->retrieve(addr, id))
+            self->storePkt(id, unit->m_Packet.clone());
+      }
+
+TIMER_CHECK:
+      // take care of the timing event for all UDT sockets
+
+      CRNode* ul = self->m_pRcvUList->m_pUList;
+      uint64_t currtime;
+      CTimer::rdtsc(currtime);
+      uint64_t ctime = currtime - 100000 * CTimer::getCPUFrequency();
+
+      while ((NULL != ul) && (ul->m_llTimeStamp < ctime))
+      {
+         CUDT* u = ul->m_pUDT;
+
+         if (u->m_bConnected && !u->m_bBroken && !u->m_bClosing)
+         {
+            u->checkTimers();
+            self->m_pRcvUList->update(u);
+         }
+         else
+         {
+            // the socket must be removed from Hash table first, then RcvUList
+            self->m_pHash->remove(u->m_SocketID);
+            self->m_pRcvUList->remove(u);
+         }
+
+         ul = self->m_pRcvUList->m_pUList;
+      }
+   }
+
+   if (AF_INET == self->m_UnitQueue.m_iIPversion)
+      delete (sockaddr_in*)addr;
+   else
+      delete (sockaddr_in6*)addr;
+
+   #ifndef WIN32
+      return NULL;
+   #else
+      SetEvent(self->m_ExitCond);
+      return 0;
+   #endif
+}
+
+int CRcvQueue::recvfrom(const int32_t& id, CPacket& packet)
+{
+   CGuard bufferlock(m_PassLock);
+
+   map<int32_t, CPacket*>::iterator i = m_mBuffer.find(id);
+
+   if (i == m_mBuffer.end())
+   {
+      #ifndef WIN32
+         uint64_t now = CTimer::getTime();
+         timespec timeout;
+
+         timeout.tv_sec = now / 1000000 + 1;
+         timeout.tv_nsec = (now % 1000000) * 1000;
+
+         pthread_cond_timedwait(&m_PassCond, &m_PassLock, &timeout);
+      #else
+         ReleaseMutex(m_PassLock);
+         WaitForSingleObject(m_PassCond, 1000);
+         WaitForSingleObject(m_PassLock, INFINITE);
+      #endif
+
+      i = m_mBuffer.find(id);
+      if (i == m_mBuffer.end())
+      {
+         packet.setLength(-1);
+         return -1;
+      }
+   }
+
+   if (packet.getLength() < i->second->getLength())
+   {
+      packet.setLength(-1);
+      return -1;
+   }
+
+   memcpy(packet.m_nHeader, i->second->m_nHeader, CPacket::m_iPktHdrSize);
+   memcpy(packet.m_pcData, i->second->m_pcData, i->second->getLength());
+   packet.setLength(i->second->getLength());
+
+   delete [] i->second->m_pcData;
+   delete i->second;
+   m_mBuffer.erase(i);
+
+   return packet.getLength();
+}
+
+int CRcvQueue::setListener(const CUDT* u)
+{
+   CGuard lslock(m_LSLock);
+
+   if (NULL != m_pListener)
+      return -1;
+
+   m_pListener = (CUDT*)u;
+   return 1;
+}
+
+void CRcvQueue::removeListener(const CUDT* u)
+{
+   CGuard lslock(m_LSLock);
+
+   if (u == m_pListener)
+      m_pListener = NULL;
+}
+
+void CRcvQueue::setNewEntry(CUDT* u)
+{
+   CGuard listguard(m_IDLock);
+   m_vNewEntry.insert(m_vNewEntry.end(), u);
+}
+
+bool CRcvQueue::ifNewEntry()
+{
+   return !(m_vNewEntry.empty());
+}
+
+CUDT* CRcvQueue::getNewEntry()
+{
+   CGuard listguard(m_IDLock);
+
+   if (m_vNewEntry.empty())
+      return NULL;
+
+   CUDT* u = (CUDT*)*(m_vNewEntry.begin());
+   m_vNewEntry.erase(m_vNewEntry.begin());
+
+   return u;
+}
+
+void CRcvQueue::storePkt(const int32_t& id, CPacket* pkt)
+{
+   #ifndef WIN32
+      pthread_mutex_lock(&m_PassLock);
+   #else
+      WaitForSingleObject(m_PassLock, INFINITE);
+   #endif
+
+   map<int32_t, CPacket*>::iterator i = m_mBuffer.find(id);
+
+   if (i == m_mBuffer.end())
+      m_mBuffer[id] = pkt;
+   else
+   {
+      delete [] i->second->m_pcData;
+      delete i->second;
+      i->second = pkt;
+   }
+
+   #ifndef WIN32
+      pthread_mutex_unlock(&m_PassLock);
+      pthread_cond_signal(&m_PassCond);
+   #else
+      ReleaseMutex(m_PassLock);
+      SetEvent(m_PassCond);
+   #endif
+}
diff --git a/src/transport/queue.h b/src/transport/queue.h
index e2644fd..2dc7d12 100644
--- a/src/transport/queue.h
+++ b/src/transport/queue.h
@@ -52,6 +52,7 @@ class CUDT;
 
 struct CUnit
 {
+   CUnit() : m_Packet(), m_iFlag() {}
    CPacket m_Packet;		// packet
    int m_iFlag;			// 0: free, 1: occupied, 2: msg read but not freed (out-of-order), 3: msg dropped
 };
diff --git a/src/transport/transportapi.cc b/src/transport/transportapi.cc
index 51e23be..0094f82 100644
--- a/src/transport/transportapi.cc
+++ b/src/transport/transportapi.cc
@@ -185,7 +185,7 @@ int Transport::Send(const std::string &remote_ip,
   }
   if (UDT::ERROR == UDT::connect(skt, reinterpret_cast<sockaddr*>(&peer_addr),
       sizeof(peer_addr))) {  // Try direct connect first
-    printf("UDT::directly connect error, try rendezvous.\n");
+    printf("UDT::direct connect error, try rendezvous.\n");
     // Let's try Rendezvous
     // get rendezvous ip/port from PdRoutingtable
     base::PDRoutingTableTuple tuple;
diff --git a/src/transport/window.cpp b/src/transport/window.cpp
index f5f5f9f..6e7a685 100644
--- a/src/transport/window.cpp
+++ b/src/transport/window.cpp
@@ -153,9 +153,9 @@ int CACKWindow::acknowledge(const int32_t& seq, int32_t& ack)
 
 CPktTimeWindow::CPktTimeWindow():
 m_iAWSize(16),
-m_piPktWindow(NULL),
-m_iPWSize(16),
-m_piProbeWindow(NULL)
+m_piPktWindow(), m_iPktWindowPtr(), m_iPWSize(16), m_piProbeWindow(),
+m_iProbeWindowPtr(), m_iLastSentTime(), m_iMinPktSndInt(),
+m_LastArrTime(), m_CurrArrTime(), m_ProbeTime()
 {
    m_piPktWindow = new int[m_iAWSize];
    m_piProbeWindow = new int[m_iPWSize];
@@ -176,10 +176,10 @@ m_piProbeWindow(NULL)
 }
 
 CPktTimeWindow::CPktTimeWindow(const int& asize, const int& psize):
-m_iAWSize(asize),
-m_piPktWindow(NULL),
-m_iPWSize(psize),
-m_piProbeWindow(NULL)
+m_iAWSize(asize),m_piPktWindow(), m_iPktWindowPtr(),
+m_iPWSize(psize), m_piProbeWindow(),
+m_iProbeWindowPtr(), m_iLastSentTime(), m_iMinPktSndInt(),
+m_LastArrTime(), m_CurrArrTime(), m_ProbeTime()
 {
    m_piPktWindow = new int[m_iAWSize];
    m_piProbeWindow = new int[m_iPWSize];
-- 
1.5.6.3

