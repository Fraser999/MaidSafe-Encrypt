#LyX 1.6.7 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass IEEEtran
\use_default_options false
\language british
\inputencoding default
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_author "David Irvine"
\pdf_keywords "Security "
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder true
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry false
\use_amsmath 0
\use_esint 0
\cite_engine basic
\use_bibtopic true
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 2
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
Self encrypting data
\end_layout

\begin_layout Author
David Irvine, email: david.irvine@maidsafe.net, LifeStuff David
\end_layout

\begin_layout Right Address
maidsafe.net limited (registered in Scotland Sc 297540)
\end_layout

\begin_layout Date
September, 2010
\end_layout

\begin_layout Abstract
This paper presents a system of encryption that requires no user intervention
 or passwords.
 The resultant data item then has to be saved or stored somewhere as in
 all methods.
 The encryption here is focussed on creating cypher-text (encrypted) objects
 that are extremely strong and closer to perfect in terms of reversibility
 as opposed to known encryption cyphers available today.
 This paper focusses on symmetric encryption, but does not attempt to create
 a new cypher, instead focusses on enhancing modern use of this technology
 to produce highly secure data and to do so in many situations and implementatio
ns.
 
\end_layout

\begin_layout Keywords
security, freedom, privacy, encryption
\end_layout

\begin_layout MarkBoth
maidsafe.net limited company confidential Version 0.1
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}{
\end_layout

\end_inset

...
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList table

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList algorithm

\end_inset


\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Section
Introduction
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Don't panic the section numbering may look different in
\end_layout

\begin_layout Plain Layout
LyX but LaTeX uses the correct Roman numerals and
\end_layout

\begin_layout Plain Layout
Alpha for section counters.
\end_layout

\begin_layout Plain Layout
It's just that LyX doesn't handle counters other than arabic
\end_layout

\begin_layout Plain Layout
numerals.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
PARstart{E}{ncryption}
\end_layout

\end_inset

 has been a goal of man since before the times of the Romans and Ceaser
 cyphers (simple replacement cyphers) through Enigma machine cyphers to
 modern day complex matrix manipulations present in abundance in computer
 enhanced algorithms.
 This paper takes such algorithms and adds some features in addition to
 direct encryption that clearly shows significant improvements in our use
 of encryption.
 
\end_layout

\begin_layout Subsection
The Issues Addressed by this Paper
\end_layout

\begin_layout Standard
The issue with today's encryption of data is in just that, we encrypt data,
 as a whole.
 This reduces immediately the potential set of possible inputs, i.e.
 if we are chasing somebodies bank balance, we may expect the output to
 be roughly the size of a bank statement and guess what? it is! In another
 convention or proposition, a whole piece of data encrypted with a single
 algorithm would only require the algorithm to be broken.
 Almost all encryption cyphers appear to be reduced in effectiveness as
 we understand the mathematics better and have more powerful computers,
 this is unlikely to reduce in the future.
 One may believe then the answer is encrypt bits of files, although this
 would require many passwords or algorithms, like putting more locks on
 a door to make it more secure, it does give people a headache to think
 they may have to remember multiple passwords for each file.
 This is unlikely to be a successful manoeuvre.
\end_layout

\begin_layout Subsection
Conventions Used
\end_layout

\begin_layout Standard
This paper does not require all the operations listed below, but lists these
 for example implementations, which are outlined later.
\end_layout

\begin_layout Standard
Hash = Hash function such as SHA or MD5 etc.
 
\end_layout

\begin_layout Standard
Symm = Symmetrical encryption such as AES, 3DES etc.
 
\end_layout

\begin_layout Standard
PBKDF2 = Password-Based Key Derivation Function or similar
\end_layout

\begin_layout Subsection
Symmetric encryption
\end_layout

\begin_layout Standard
This paper will use symmetric encryption as a term to cover all algorithms
 (to some extent) and therefore will use a key and initialisation vector
 and plain-text input data.
 There will be no mention of MAC or similar additions to the algorithms
 in the hope that the reader would not attempt to implement a poorly stated
 or incorrect algorithm.
 
\end_layout

\begin_layout Subsection
Cryptographically secure hash
\begin_inset CommandInset label
LatexCommand label
name "sub:Cryptographically-secure-hash"

\end_inset


\end_layout

\begin_layout Standard
A hash function can be thought of as a digital fingerprint.
 Just as a fingerprint of a person is supposed to be unique, then a digital
 hash function is also supposedly unique.
 We have all heard of two people with identical fingerprints (but perhaps
 have never met any !) and in the digital world it can be possible to get
 two pieces of data with the same hash result.
 This is referred to as a collision and reduces the security of the hash
 algorithm.
 The more secure the algorithm then the likelihood of a collision (or two
 people having the same fingerprint) is reduced.
 It is very similar to taking more points of reference on an actual fingerprint
 to reduce collisions in that area of science also.
 This is an area where both systems share a similarity in the increasing
 complexity of measurement and recording of data points of reference.
\end_layout

\begin_layout Standard
In cryptographically secure hashing the data is analysed and a fixed length
 key is produced, this key is called the hash of the data.
 Again similarly with human fingerprinting a hash cannot reveal data just
 as a fingerprint cannot reveal a person (i.e.
 you cannot recreate the person from the print) and you cannot recreate
 the data from the hash, otherwise it would be a miraculous compression
 scheme indeed.
 
\end_layout

\begin_layout Standard
Early hash algorithms are considered broken, such as md4, md5 and even early
 SHA schemes, this is a bad representation as they are not broken, they
 simply can allow too many collisions and larger descriptors (key lengths)
 and more efficient algorithms are almost always required.
 
\end_layout

\begin_layout Standard
Therefore a hash is merely a best attempt to distinguish a piece of data
 by a fixed length string representation of the contents of the data and
 of only that data
\begin_inset Foot
status open

\begin_layout Plain Layout
you can see where the problem exists as the logical conclusion is a key
 longer than any known piece of uncompress-able data, to ensure no collisions
\end_layout

\end_inset

, it is really as simple as that.
 
\end_layout

\begin_layout Section

\lang english
Implementation
\end_layout

\begin_layout Subsection

\lang english
Overview
\begin_inset CommandInset label
LatexCommand label
name "sub:Overvew"

\end_inset


\end_layout

\begin_layout Enumerate

\lang english
Take file and get hash of this.
\end_layout

\begin_layout Enumerate

\lang english
Split into several chunks of various sizes.
\end_layout

\begin_layout Enumerate

\lang english
Take hash of each chunk.
\end_layout

\begin_layout Enumerate

\lang english
Create another chunk by concatenating the hash of the file.
\end_layout

\begin_layout Enumerate

\lang english
XOR (or an equivalent logical operation) the chunks together as in a one
 time pad.
\end_layout

\begin_layout Enumerate

\lang english
Take the hash from (3) and use the hash of chunk +1 as the key, use the
 hash of chunk +2 as the IV (yes this will force each file to the exact
 same output).
\end_layout

\begin_layout Enumerate

\lang english
Rename each with the hash of the new content and save these hashes.
 
\end_layout

\begin_layout Standard
For multiple files this is a recursive process which will in itself create
 a large file 
\end_layout

\begin_layout Subsection
File Chunking 
\end_layout

\begin_layout Definition
\align left

\lang english
\begin_inset Formula $f{\scriptscriptstyle c}\equiv file\: content,\: f{\scriptscriptstyle m}\equiv file\: metadata,\: hf\equiv H(f_{c})$
\end_inset


\end_layout

\begin_layout Enumerate

\lang english
Take 
\begin_inset Formula $hf$
\end_inset

 and create a structure, which we will refer to as a data map.
 
\end_layout

\begin_layout Enumerate
Take the size of the file 
\begin_inset Formula $(f.size())$
\end_inset

 and calculate number of chunks 
\begin_inset Formula $n$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Number of chunks is a setting and depends on implementation, you may wish
 a max number of chunks, or maximum chunk size, this decision and code is
 left to the reader.
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Create chunks by taking the first 
\begin_inset Formula $n$
\end_inset

 bytes of 
\begin_inset Formula $hf$
\end_inset

 and randomise the chunk sizes to remove the possibility of gathering a
 set of similar chunks and associating these with a piece of data.
 This process must allow chunks to be of varying sizes in a manner not calculabl
e (this is why the hash is used).
 Many algorithms can be employed at this stage.
\end_layout

\begin_layout Standard

\lang english
The chunks are created with random size to ensure the set required to recreate
 the file is as large as the number of available chunks in any data store.
\end_layout

\begin_layout Subsection
Obfuscation Step
\end_layout

\begin_layout Standard
Repeatedly rehash the file hash, 
\end_layout

\begin_layout Example
for (std::str length=
\begin_inset Formula $H(hf)$
\end_inset

; length.size() < file.size(); length+=
\begin_inset Formula $H(length)$
\end_inset

).
 
\end_layout

\begin_layout Standard
This is the XOR (
\begin_inset Formula $\bigoplus$
\end_inset

) chunk.
 The process is now a repeated XOR
\begin_inset Foot
status open

\begin_layout Plain Layout
In this case we have selected XOR to represent a logical operation to obfuscate
 the data, this is not restrictive in any way and may be replaced by other
 operations to enhance the operation.
\end_layout

\end_inset

operation.
\end_layout

\begin_layout Example
\align left

\lang english
\begin_inset Formula $(XORchunk\bigoplus c_{1})\equiv c_{1x},(c{\scriptscriptstyle 1}\bigoplus c{\scriptscriptstyle 2})\equiv c_{2x}\ldots(C_{n}\bigoplus c{\scriptscriptstyle 1})\equiv c_{nx}$
\end_inset

 (rotational operation)
\end_layout

\begin_layout Subsection
Encryption Step
\end_layout

\begin_layout Standard
In the encryption stage we require two separate non deterministic pieces
 of data, the encryption key (or password) and the Initialisation Vector
 (IV).
 To ensure all data encrypts to the same end result we determine the IV
 from what can be considered non deterministic data
\begin_inset Foot
status open

\begin_layout Plain Layout
This is an area of debate as to whether this is non deterministic data,
 in this case the argument is that the only way to determine the data is
 to have the original data in the first place, therefore there is no need
 to determine keys as it would be fruitless.
 This is somewhat of a philosophical debate and likely to be the topic of
 a few furled eyebrows over a few drams in a few bars for a few years to
 come.
\end_layout

\end_inset

, that being the hash of one of the chunks.
 
\end_layout

\begin_layout Definition
Encrypt with key and IV is shown as 
\begin_inset Formula $Enc_{[key][IV]}(data)$
\end_inset

in the following example.
 It is assumed the key size is the hash size and the IV is derived from
 the first portion of the hash of the appropriate chunk hash.
\end_layout

\begin_layout Example
\begin_inset Formula $ENC_{[C_{n+1}][C_{n+2}]}(c_{n})\equiv C_{xen}$
\end_inset


\end_layout

\begin_layout Example
Therefore we have the final stage of the data represented as chunks of highly
 obfuscated chunks.
 We than take the hash of each chunk again 
\begin_inset Formula $H(C_{xen})$
\end_inset

 and rename each chunk by the hash of it's content.
\end_layout

\begin_layout Subsection
Data Map
\end_layout

\begin_layout Standard
In the previous sections we discovered the process of self encrypting data,
 however, it did leave several as of yet unanswered questions.
 How do we reverse this process to retrieve the plain-text form the cypher
 text chunks.
 The answer is data maps.
 
\end_layout

\begin_layout Standard
In the 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Overvew"

\end_inset

steps 1,3 & 7 we collected important data.
 This data alone is enough to reverse this process and this is stored in
 a structure we refer to as a data map.
 This is described in the following table.
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $fh$
\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $H(c_{1})$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $H(c_{xe1})$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $H(c_{2})$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $H(c_{xe2})$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\ldots$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\ldots$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $H(c_{n})$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $H(c_{xen})$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\emph on
Data Map structure
\end_layout

\begin_layout Standard
With this structure the names of all the chunks are in the right hand column
 and all passwords and IV's are stored in the left hand column.
 The file hash in the top row identifies the data element and acts as the
 unique key for this file.
 Reversing the process is now obvious.
\end_layout

\begin_layout Enumerate
Retrieve the chunks as described in right hand column.
\end_layout

\begin_layout Enumerate
Reverse the encryption stage.
 
\end_layout

\begin_layout Enumerate
Create a the XOR chunk again.
\end_layout

\begin_layout Enumerate
Reverse the obfuscation stage.
\end_layout

\begin_layout Enumerate
Concatenate the results.
\end_layout

\begin_layout Standard
This is the complete encrypt / decrypt process for each file.
\end_layout

\begin_layout Subsection
Data Atlas or recursive data maps
\end_layout

\begin_layout Standard
Encrypting multiple files is now a repeated method of a single file.
 This can be carried out very easily by re-cursing though a directory structure,
 creating chunks and storing them somewhere and gathering together lots
 of Data Maps 
\begin_inset Formula $(dm)$
\end_inset

.
 We can concatenate all these into a new piece of data we call the Data
 Atlas 
\begin_inset Formula $(da)$
\end_inset

.
 Therefore 
\begin_inset Formula $dm_{1}+dm_{2}+\ldots dm_{c}\equiv da$
\end_inset

.
 This data atlas is itself now a large piece of data and is fed into the
 process once more.
 This produces a single data map and more chunks.
 These chunks are stored somewhere and the single remaining data atlas is
 the key to all the data.
 This is the data map of the data atlas and is a crucial piece of information
 which must be secured by encrypting it, storing it safely somewhere or
 some other mechanism of the readers choice.
 In the maidsafe network this is the encrypted content of the TMID packet
 as described in 
\begin_inset CommandInset citation
LatexCommand cite
key "1"

\end_inset

.
\end_layout

\begin_layout Section
Conclusions
\end_layout

\begin_layout Standard
This process allows for multiple data elements to be encrypted in a very
 powerful fashion.
 Indeed there may be some debate as to whether the encryption or obfuscation
 stages cannot be left out (well at least one of them).
 It is decided this is not a bottleneck in such a system as data can be
 processed at speeds in excess of current networking capabilities in many
 cases.
 This is open to further research for differing situations though.
 
\end_layout

\begin_layout Standard
An important issue here is that all data (with the exception of the dm of
 the da) is encrypted using no user information or input.
 This means that if the container for all the chunks is a single container
 then duplicate files will produce the exact same chunks and the storage
 system can automatically remove duplicate information.
 It is estimated the savings in such a system would be greater than 95%.
\end_layout

\begin_layout Standard
Also interesting is the fact that the encryption may be seen as a 'step
 to far', never the less it does indicate that any break in an encryption
 cypher will not reveal any data to an attacker.
 This is a valuable and important point.
 
\end_layout

\begin_layout Standard
It is hoped the research in this field will continue and measures of number
 of chunks verses data map size etc.
 would reveal differing results for differing situations.
 
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
label "1"
key "1"

\end_inset

David Irvine, maidsafe - a new network paradigm.
 david.irvine@maidsafe.net
\end_layout

\begin_layout Standard
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Change this paragraphs style to 'Standard' to enable
\end_layout

\begin_layout Plain Layout
BibTeX bibliography generation.
\end_layout

\begin_layout Plain Layout
Remember though that your final submission is supposed to have
\end_layout

\begin_layout Plain Layout
all the bibliography entries embedded in the latex file.
 This means
\end_layout

\begin_layout Plain Layout
you eventually have to copy the .bbl file into the latex file and
\end_layout

\begin_layout Plain Layout
remove the bibtex lines.
\end_layout

\end_inset


\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "your_biblio_file"
options "IEEEbib"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout BiographyNoPhoto
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{
\end_layout

\end_inset

David Irvine
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset

 is a Scottish Engineer and innovator who has spent the last 12 years researchin
g ways to make computers function in a more efficient manner.
\end_layout

\begin_layout BiographyNoPhoto
He is an Inventor listed on more than 20 patent submissions and was Designer
 / Project Manager of one of the World's largest private networks (Saudi
 Aramco, over $300M).
 He is an experienced Project Manager and has been involved in start up
 businesses since 1995 and has provided business consultancy to corporates
 and SMEs in many sectors.
\end_layout

\begin_layout BiographyNoPhoto
He has presented technology at Google (Seattle), British Computer Society
 (Christmas Lecture) and many others.
\end_layout

\begin_layout BiographyNoPhoto
He has spent many years as a lifeboat Helmsman and is a keen sailor when
 time permits.
\end_layout

\end_body
\end_document
