#LyX 1.6.7 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass IEEEtran
\use_default_options false
\language british
\inputencoding default
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_title "Self Encrypting Data"
\pdf_author "David Irvine"
\pdf_subject "Encryption"
\pdf_keywords "security, freedom, privacy, encryption"
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder true
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry false
\use_amsmath 0
\use_esint 0
\cite_engine basic
\use_bibtopic true
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 2
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
Self Encrypting Data
\end_layout

\begin_layout Author
David Irvine, email: david.irvine@maidsafe.net, LifeStuff: David
\end_layout

\begin_layout Right Address
maidsafe.net limited (registered in Scotland Sc 297540)
\end_layout

\begin_layout Date
September, 2010
\end_layout

\begin_layout Abstract
This paper presents a system of encryption that requires no user intervention
 or passwords.
 The resultant data item then has to be saved or stored somewhere as in
 all methods.
 The encryption here is aimed at creating cipher-text (encrypted) objects
 that are extremely strong and closer to perfect in terms of reversibility,
 as opposed to known encryption ciphers available today.
 This paper focuses on symmetric encryption, but does not introduce a new
 cipher.
 Instead the paper describes a method of enhancing the use of this technology
 to produce highly secure data and, to do so in many situations and implementati
ons.
 
\end_layout

\begin_layout Keywords
security, freedom, privacy, encryption
\end_layout

\begin_layout MarkBoth
maidsafe.net limited company confidential Version 0.1
\begin_inset ERT
status open

\begin_layout Plain Layout

}{
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
PARstart{E}{ncryption}
\end_layout

\end_inset

 has been a goal of man since before the times of the Romans, and Caesar
 Ciphers (simple replacement ciphers) through Enigma machine ciphers to
 modern day complex matrix manipulations are present in abundance in computer
 enhanced algorithms.
 This paper describes a way to use such algorithms in addition to direct
 encryption that clearly shows significant improvements in our use of encryption.
 
\end_layout

\begin_layout Subsection
The Issues Addressed by this Paper
\end_layout

\begin_layout Standard
The issue with today's encryption of data is in just that; we encrypt data,
 as a whole.
 This reduces the potential set of possible inputs, i.e.
 if we are chasing somebody's bank balance, we may expect the output to
 be roughly the size of a bank statement, and guess what? It is! Furthermore,
 the security of a whole piece of data encrypted with a single algorithm
 depends upon just that single algorithm not getting broken.
 Almost all encryption ciphers appear to reduce in effectiveness as we understan
d the mathematics better and create more powerful computers.
 One may believe then, that the answer is to encrypt bits of files.
 However, this would require many passwords or algorithms; like putting
 more locks on a door to make it more secure, it gives people a headache
 to think that they may have to remember multiple passwords for each file.
 This is unlikely to be a successful manoeuvre.
\end_layout

\begin_layout Subsection
Conventions Used
\end_layout

\begin_layout Standard
This paper does not require all the operations listed below, but lists these
 for example implementations, which are outlined later.
\end_layout

\begin_layout Standard
Hash = Hash function such as SHA, MD5, etc.
 
\end_layout

\begin_layout Standard
Symm = Symmetrical encryption such as AES, 3DES, etc.
 
\end_layout

\begin_layout Standard
PBKDF2 = Password-Based Key Derivation Function or similar
\end_layout

\begin_layout Subsection
Symmetric Encryption
\end_layout

\begin_layout Standard
This paper will use symmetric encryption as a term to cover all algorithms
 (to some extent) and therefore will use a key and initialisation vector
 and plain-text input data.
 There will be no mention of MAC or similar additions to the algorithms
 in the hope that the reader would not attempt to implement a poorly stated
 or incorrect algorithm.
 
\end_layout

\begin_layout Subsection
Cryptographically Secure Hash
\begin_inset CommandInset label
LatexCommand label
name "sub:Cryptographically-secure-hash"

\end_inset


\end_layout

\begin_layout Standard
A hash function can be thought of as a digital fingerprint.
 Just as a fingerprint of a person is supposed to be unique, then a digital
 hash function is also supposedly unique.
 We have all heard of two people with identical fingerprints (but perhaps
 have never met any!) and in the digital world it can be possible to get
 two pieces of data with the same hash result.
 This is referred to as a collision and reduces the security of the hash
 algorithm.
 The more secure the algorithm, then the likelihood of a collision is reduced.
 It is very similar to taking more points of reference on an actual fingerprint
 to reduce collisions in that area of science also.
 This is an area where both systems share a similarity in the increasing
 complexity of measurement and recording of data points of reference.
\end_layout

\begin_layout Standard
In cryptographically secure hashing, the data is analysed and a fixed length
 key called the hash of the data is produced.
 Again similarly to human fingerprinting a hash cannot reveal data just
 as a fingerprint cannot reveal a person (i.e.
 you cannot recreate the person from the print) and you cannot recreate
 the data from the hash.
 
\end_layout

\begin_layout Standard
Early hash algorithms such as MD4, MD5 and even early SHA are considered
 broken, in the sense that they simply allow too many collisions to occur.
 Hence larger descriptors (keylengths) and more efficient algorithms are
 almost always required.
\begin_inset Foot
status open

\begin_layout Plain Layout
you can see where the problem exists as the logical conclusion is a key
 longer than any known piece of uncompress-able data, to ensure no collisions
\end_layout

\end_inset


\end_layout

\begin_layout Section
Implementation
\end_layout

\begin_layout Subsection
Overview
\begin_inset CommandInset label
LatexCommand label
name "sub:Overvew"

\end_inset


\end_layout

\begin_layout Enumerate
Get hash of whole file.
\end_layout

\begin_layout Enumerate
Split into several chunks of various sizes.
\end_layout

\begin_layout Enumerate
Take hash of each chunk.
\end_layout

\begin_layout Enumerate
Create another chunk by concatenating the hashes of other chunks.
\end_layout

\begin_layout Enumerate
XOR (or an equivalent logical operation) the chunks together as in a one
 time pad.
\end_layout

\begin_layout Enumerate
Take the hash from (3) and use the hash of chunk + 1 as the key, use the
 hash of chunk + 2 as the IV.
\end_layout

\begin_layout Enumerate
Rename each with the hash of the new content and save these hashes.
 
\end_layout

\begin_layout Subsection
File Chunking 
\end_layout

\begin_layout Definition
\align left
\begin_inset Formula $\mathsf{f_{c}}$
\end_inset

 ≡ file content; 
\begin_inset Formula $\mathsf{f_{m}}$
\end_inset

≡ file metadata; 
\begin_inset Formula $\mathsf{hf}$
\end_inset

 ≡ 
\begin_inset Formula $\mathsf{H(f_{c})}$
\end_inset

.
\end_layout

\begin_layout Enumerate
Take 
\begin_inset Formula $\mathsf{hf}$
\end_inset

 and create a structure, which we will refer to as a data map.
 
\end_layout

\begin_layout Enumerate
Take the size of the file 
\begin_inset Formula $\mathsf{(f.size())}$
\end_inset

 and calculate number 
\begin_inset Formula $\mathsf{n}$
\end_inset

 of chunks
\begin_inset Foot
status open

\begin_layout Plain Layout
Number of chunks is a setting and depends on implementation, you may wish
 a max number of chunks, or maximum chunk size, this decision and code is
 left to the reader.
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
Create chunks by taking the first 
\begin_inset Formula $\mathsf{n}$
\end_inset

 bytes of 
\begin_inset Formula $\mathsf{hf}$
\end_inset

 and randomise the chunk sizes to remove the possibility of gathering a
 set of similar chunks and associating these with a piece of data.
 This process must allow chunks to be of varying sizes in a manner not calculabl
e without the original file (this is why the hash is used).
 Many algorithms can be employed at this stage.
\end_layout

\begin_layout Standard
The chunks are created with random size to ensure the set required to recreate
 the file is as large as the number of available chunks in any data store.
\end_layout

\begin_layout Subsection
Obfuscation Step
\end_layout

\begin_layout Standard
In the obfuscation step, we pollute each chunk with data from other chunks.
\end_layout

\begin_layout Example
For 
\begin_inset Formula $\mathsf{c_{n}}$
\end_inset

, create an identically-sized data chunk by repeatedly rehashing the hash
 of chunk n + 2 and appending the result, i.e.
 
\begin_inset Formula $\mathsf{H(c_{n+2})+H(H(c_{n+2}))+H(H(H(c_{n+2})))+...}$
\end_inset


\end_layout

\begin_layout Standard
This is called the XOR chunk 
\begin_inset Formula $\mathsf{n}$
\end_inset

 (
\begin_inset Formula $\mathsf{c_{XORn}}$
\end_inset

) and is unsurprisingly XORed (
\begin_inset Formula $\bigoplus$
\end_inset

) with chunk 
\begin_inset Formula $\mathsf{n}$
\end_inset

.
\begin_inset Foot
status open

\begin_layout Plain Layout
In this case we have selected XOR to represent a logical operation to obfuscate
 the data, this is not restrictive in any way and may be replaced by other
 obfuscation methods.
\end_layout

\end_inset


\end_layout

\begin_layout Example
\align left
\begin_inset Formula $\mathsf{c_{XOR1}\bigoplus c_{1}\equiv c_{x1}}$
\end_inset

, 
\begin_inset Formula $\mathsf{c_{XOR2}\bigoplus c_{2}\equiv c_{x2}}$
\end_inset

, etc.
\end_layout

\begin_layout Subsection
Encryption Step
\end_layout

\begin_layout Standard
In the encryption stage, we require two separate non deterministic pieces
 of data, the encryption key (or password) and the Initialisation Vector
 (IV).
 To ensure all data encrypts to the same end result we determine the IV
 from what can be considered non deterministic data
\begin_inset Foot
status open

\begin_layout Plain Layout
This is an area of debate as to whether this is non deterministic data,
 in this case the argument is that the only way to determine the data is
 to have the original data in the first place, therefore there is no need
 to determine keys as it would be fruitless.
 This is somewhat of a philosophical debate and likely to be the topic of
 a few furled eyebrows over a few drams in a few bars for a few years to
 come.
\end_layout

\end_inset

, that being the hash of one of the chunks.
 
\end_layout

\begin_layout Definition
Encrypt with key and IV is shown as 
\begin_inset Formula $\mathsf{Enc_{[key][IV]}(data)}$
\end_inset

in the following example.
 It is assumed the key and the IV for chunk 
\begin_inset Formula $\mathsf{n}$
\end_inset

 are derived from separate portions of the hash of chunk 
\begin_inset Formula $\mathsf{n+1}$
\end_inset

.
\end_layout

\begin_layout Example
\begin_inset Formula $\mathsf{Enc{}_{[H(c_{n+1})][H(c_{n+1})]}(c_{xn})\equiv c_{xen}}$
\end_inset


\end_layout

\begin_layout Example
Therefore we have the final stage of the data represented as chunks of highly
 obfuscated chunks.
 We than take the hash of each chunk again 
\begin_inset Formula $\mathsf{H(c_{xen})}$
\end_inset

 and rename each chunk with the hash of its content.
\end_layout

\begin_layout Subsection
Data Map
\end_layout

\begin_layout Standard
In the previous sections, we described the process of self encrypting data.
 However, it did leave an important question unanswered.
 How do we reverse this process to retrieve the plain-text from the cipher-text
 chunks? The answer is data maps.
 
\end_layout

\begin_layout Standard
In the 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Overvew"

\end_inset

 steps 1, 3 & 7 we collected important data.
 This data alone is enough to reverse the encryption process and this is
 stored in a structure we refer to as a data map.
 This is described in the following table.
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\mathsf{fh}$
\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\mathsf{H(c_{1})}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\mathsf{H(c_{xe1})}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\mathsf{H(c_{2})}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\mathsf{H(c_{xe2})}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\ldots$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\ldots$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\mathsf{H(c_{n})}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\mathsf{H(c_{xen})}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\emph on
 Data Map structure
\end_layout

\begin_layout Standard
With this structure the names of all the chunks are in the right hand column
 and all passwords and IV's (which are derived from the original chunk hashes)
 are stored in the left hand column.
 The file hash in the top row identifies the data element and acts as the
 unique key for this file.
 Reversing the process is now obvious.
\end_layout

\begin_layout Enumerate
Retrieve the chunks listed in right hand column.
\end_layout

\begin_layout Enumerate
Decrypt each.
 
\end_layout

\begin_layout Enumerate
Create each XOR chunk again.
\end_layout

\begin_layout Enumerate
Reverse the obfuscation stage.
\end_layout

\begin_layout Enumerate
Concatenate the results.
\end_layout

\begin_layout Standard
This is the complete encrypt / decrypt process for each file.
\end_layout

\begin_layout Subsection
Data Atlas or Recursive Data Maps
\end_layout

\begin_layout Standard
The data maps 
\begin_inset Formula $\mathsf{(dm)}$
\end_inset

 from multiple files can be concatenated into a new structure we call the
 Data Atlas 
\begin_inset Formula $\mathsf{(da)}$
\end_inset

.
 Therefore 
\begin_inset Formula $\mathsf{dm_{1}+dm_{2}+\ldots dm_{c}\equiv da}$
\end_inset

.
 This data atlas is itself now a large piece of data and is fed into the
 self-encryption process once more.
 This produces a single data map and more chunks.
 These chunks are stored somewhere and the single remaining data map is
 the key to all the data.
\end_layout

\begin_layout Section
Conclusions
\end_layout

\begin_layout Standard
This process allows for multiple data elements to be encrypted in a very
 powerful fashion.
 Indeed there may be some debate as to whether the encryption or obfuscation
 stages cannot be left out (well, at least one of them).
 It is decided this is not a bottleneck in such a system, as data can be
 processed at speeds in excess of current networking capabilities in many
 cases.
 This is open to further research for differing situations though.
 
\end_layout

\begin_layout Standard
An important issue here is that all data is encrypted using no user information
 or input.
 This means that if the container for all the chunks is a single container
 then duplicate files will produce the exact same chunks and the storage
 system can automatically remove duplicate information.
 It is estimated the savings in such a system would be greater than 95%.
\end_layout

\begin_layout Standard
Also interesting is the fact that the encryption may be seen as a 
\begin_inset Quotes eld
\end_inset

step too far
\begin_inset Quotes erd
\end_inset

; nevertheless it does indicate that any break in an encryption cipher will
 not reveal any data to an attacker.
 This is a valuable and important point.
 
\end_layout

\begin_layout Standard
It is hoped the research in this field will continue and measures of number
 of chunks versus data map size, etc.
 would reveal interesting scope for optimisations and improvements.
 
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
label "1"
key "1"

\end_inset

David Irvine, maidsafe: A new networking paradigm, david.irvine@maidsafe.net
\end_layout

\begin_layout Standard
\begin_inset Note Comment
status open

\begin_layout Plain Layout
\begin_inset Note Note
status open

\begin_layout Plain Layout
Change this paragraphs style to 'Standard' to enable
\end_layout

\begin_layout Plain Layout
BibTeX bibliography generation.
\end_layout

\begin_layout Plain Layout
Remember though that your final submission is supposed to have
\end_layout

\begin_layout Plain Layout
all the bibliography entries embedded in the latex file.
 This means
\end_layout

\begin_layout Plain Layout
you eventually have to copy the .bbl file into the latex file and
\end_layout

\begin_layout Plain Layout
remove the bibtex lines.
\end_layout

\end_inset


\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "your_biblio_file"
options "IEEEbib"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout BiographyNoPhoto
\begin_inset ERT
status open

\begin_layout Plain Layout

{
\end_layout

\end_inset

David Irvine
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset

 is a Scottish Engineer and innovator who has spent the last 12 years researchin
g ways to make computers function in a more efficient manner.
\end_layout

\begin_layout BiographyNoPhoto
He is an Inventor listed on more than 20 patent submissions and was Designer
 / Project Manager of one of the World's largest private networks (Saudi
 Aramco, over $300M).
 He is an experienced Project Manager and has been involved in start up
 businesses since 1995 and has provided business consultancy to corporates
 and SMEs in many sectors.
\end_layout

\begin_layout BiographyNoPhoto
He has presented technology at Google (Seattle), British Computer Society
 (Christmas Lecture) and many others.
\end_layout

\begin_layout BiographyNoPhoto
He has spent many years as a lifeboat Helmsman and is a keen sailor when
 time permits.
\end_layout

\end_body
\end_document
