<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<diagram>
<source><![CDATA[#![Store Existing Chunk]
client:client "Client"
watch:vault "Watch List Holders x16"
c_account:vault "Client A/C Holders x16"
f_account:vault "First Storing Client A/C Holders x16"
ref:vault "Reference List Holders x16"

client:Ack =ref. Kademlia FIND_VALUE
*2 c_account

Watch List comprises:
  * list of PMIDs of current 4 paying clients
  * further list of reserve watchers
  * count of total watchers
  * checksum of current watchers
  * chunk size
  * minimum rank required of chunk holders.

   First client pays 4 times and is held as a repeated
entry.  As second, third and fourth payers are added,
they each replace an instance of the first and
effectively recompense the first payer.  This list
remains unchanged until one of them deletes himself.
  Reserve watchers list is a FIFO queue who pay
maidsafe initially, but once a current payer deletes
himself are used to replace him and so effectively
take over paying the storing vault.
   If no replacement watchers are available when a
current payer deletes himself, he is not recompensed
until the count and checksum are exactly zero, at
which time all 4 get repaid.
*2
client:client. Check rank if exists.&
*1 client
TODO: If >= 5 nodes listed as chunk holders,
remove lowest rank vault and send him a
CACHE_CHUNK message.
*1

*3 client
TODO: If chunk exists at lower rank,
we must promote which will be store
and delete lower ranked chunks.
*3

client:client. Wait till online.&

*4 client
For each Watch List Holder...
*4

client:>watch. ADD_TO_WATCH_LIST_REQUEST
[c:Condition IF Watchlist has < 4 current payers]
(2)watch:Ack/Nack =c_account. AMEND_ACCOUNT_REQUEST (Space Taken Inc)&
watch:>client.Ack/Nack &
watch:Ack/Nack =f_account. AMEND_ACCOUNT_REQUEST (Space Taken Dec)&
[/c]
[c:Condition IF Watchlist has >= 4 current payers]
(2)watch:Ack/Nack =c_account. AMEND_ACCOUNT_REQUEST (Space Taken Inc)&
watch:>client.Ack/Nack &
[/c]]]></source>
<configuration>
<property name="actorWidth" value="25"/>
<property name="arrowSize" value="6"/>
<property name="colorizeThreads" value="true"/>
<property name="destructorWidth" value="30"/>
<property family="Dialog" name="font" size="12" style="0"/>
<property name="fragmentMargin" value="8"/>
<property name="fragmentPadding" value="10"/>
<property name="fragmentTextPadding" value="3"/>
<property name="glue" value="0"/>
<property name="headHeight" value="35"/>
<property name="headLabelPadding" value="5"/>
<property name="headWidth" value="100"/>
<property name="initialSpace" value="10"/>
<property name="leftMargin" value="5"/>
<property name="lineWrap" value="true"/>
<property name="lowerMargin" value="5"/>
<property name="mainLifelineWidth" value="8"/>
<property name="messageLabelSpace" value="3"/>
<property name="messagePadding" value="6"/>
<property name="noteMargin" value="6"/>
<property name="notePadding" value="6"/>
<property name="opaqueMessageText" value="false"/>
<property name="returnArrowVisible" value="true"/>
<property name="rightMargin" value="5"/>
<property name="selfMessageHorizontalSpace" value="15"/>
<property name="separatorBottomMargin" value="8"/>
<property name="separatorTopMargin" value="15"/>
<property name="spaceBeforeActivation" value="2"/>
<property name="spaceBeforeAnswerToSelf" value="10"/>
<property name="spaceBeforeConstruction" value="6"/>
<property name="spaceBeforeSelfMessage" value="7"/>
<property name="subLifelineWidth" value="6"/>
<property name="threadNumbersVisible" value="false"/>
<property name="threaded" value="true"/>
<property name="upperMargin" value="5"/>
<property name="verticallySplit" value="false"/>
</configuration>
</diagram>
