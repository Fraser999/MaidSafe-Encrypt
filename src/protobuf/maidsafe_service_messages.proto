// Maidsafe rpc arguments and responses
// data_type is defined in  maidsafe/maidsafe.h as the enum ValueType
// In comments throughout, where a client is requesting a store to a vault, the
// requester provides the pmid of (one of) his vault(s) - known as "client's
// PMID" and the recipient's is known as "vault's PMID".

import "packet.proto";

package maidsafe;

message SignedSize {
  required uint64 data_size = 1;
  required bytes signature = 2;  // data_size (as a string) signed
  required bytes pmid = 3;  // client's or Chunk Info holder's PMID (for Store
                            // Chunk or DeleteChunk respectively)
  required bytes public_key = 4;
  required bytes public_key_signature = 5;
}

message StoreContract {
  message InnerContract {
    required uint32 result = 1;  // whether the vault will store the chunk
    required SignedSize signed_size = 2;
  }
  required InnerContract inner_contract = 1;
  required bytes signature = 2;  // Signature of serialised inner_contract
  required bytes pmid = 3;  // vault's PMID
  required bytes public_key = 4;
  required bytes public_key_signature = 5;
}

message StorePrepRequest {
  required bytes chunkname = 1;
  required SignedSize signed_size = 2;
  required bytes request_signature = 3;
}

message StorePrepResponse {
  required StoreContract store_contract = 1;
  required bytes response_signature = 2;  // serialised store_contract signed
                                          // with vault's PMID
}

message StoreChunkRequest {
  required bytes chunkname = 1;
  required bytes data = 2;
  required bytes pmid = 3;  // client's PMID
  required bytes public_key = 4;
  required bytes public_key_signature = 5;
  required bytes request_signature = 6;
  required int32 data_type = 7;
  optional uint32 offset = 8;
  optional uint32 chunklet_size = 9;
}

message StoreChunkResponse {
  required uint32 result = 1;
  optional bytes pmid = 2;  // vault's PMID
}

message AddToWatchListRequest {
  required bytes chunkname = 1;
  required SignedSize signed_size = 2;
  required bytes request_signature = 3;  // Signed using client's PMID key (PMID
                                         // details included in signed_size
}

message AddToWatchListResponse {
  required uint32 result = 1;
  optional bytes pmid = 2;  // Chunk Info holder's PMID
  optional uint32 upload_count = 3;
}

message RemoveFromWatchListRequest {
  required bytes chunkname = 1;
  required bytes pmid = 2;  // client's PMID
  required bytes public_key = 3;
  required bytes public_key_signature = 4;
  required bytes request_signature = 5;
}

message RemoveFromWatchListResponse {
  required uint32 result = 1;
  optional bytes pmid = 2;  // Chunk Info holder's PMID
}

message AddToReferenceListRequest {
  required bytes chunkname = 1;
  required StoreContract store_contract = 2;
  required bytes request_signature = 3;  // Signed using vault's PMID key (PMID
                                         // details included in store_contract)
}

message AddToReferenceListResponse {
  required uint32 result = 1;
  optional bytes pmid = 2;
}

message RemoveFromReferenceListRequest {
  required bytes chunkname = 1;
  required bytes pmid = 2;  // vault's PMID
  required bytes public_key = 3;
  required bytes public_key_signature = 4;
  required bytes request_signature = 5;
}

message RemoveFromReferenceListResponse {
  required uint32 result = 1;
  optional bytes pmid = 2;
}

message AmendAccountRequest {
  enum Amendment {
    kSpaceOffered = 0;  // total (used & unused) vault space available to net
    kSpaceGivenInc = 1;  // called when vault stores a chunk for someone
    kSpaceGivenDec = 2;  // called when vault deletes a chunk
    kSpaceTakenInc = 3;  // called when client uploads a chunk to net
    kSpaceTakenDec = 4;  // called when client deletes a chunk he's previously
                         // uploaded
  }
  required Amendment amendment_type = 1;
  required bytes account_pmid = 2;  // PMID of account to be amended
  required SignedSize signed_size = 3;
  optional bytes chunkname = 4;  // required if type is not kSpaceOffered to
                                 // assert that sender is valid ChunkInfo holder
}

message AmendAccountResponse {
  required uint32 result = 1;
  optional bytes pmid = 2;  // account holder's PMID
}

message AccountStatusRequest {
  required bytes account_pmid = 1;  // PMID of account being queried
  optional uint64 space_requested = 2;
  optional bytes public_key = 3;
  optional bytes public_key_signature = 4;
  optional bytes request_signature = 5;
}

message AccountStatusResponse {
  required uint32 result = 1;
  required bytes pmid = 2;
  optional uint64 space_offered = 3;
  optional uint64 space_given = 4;
  optional uint64 space_taken = 5;
}

message CheckChunkRequest {
  required bytes chunkname = 1;
}

message CheckChunkResponse {
  required uint32 result = 1;
  required bytes pmid = 2;
}

message GetChunkRequest {
  required bytes chunkname = 1;
  optional bytes serialised_cacher_contact = 2;
}

message GetChunkResponse {
  required uint32 result = 1;
  optional bytes content = 2;
  optional bytes pmid = 3;
}

message DeleteChunkRequest {
  required bytes chunkname = 1;
  required SignedSize signed_size = 2;
  required bytes request_signature = 3;  // signed by Chunk Info holder's PMID
  required int32 data_type = 4;
}

message DeleteChunkResponse {
  required uint32 result = 1;
  optional bytes pmid = 2;
}

message ValidityCheckRequest {
  required bytes chunkname = 1;
  required bytes random_data = 2;
}

message ValidityCheckResponse {
  required uint32 result = 1;
  optional bytes hash_content = 2;
  required bytes pmid = 3;
}

message SwapChunkRequest {
  required int32 request_type = 1;
  required bytes chunkname1 = 2;
  optional bytes chunkcontent1 = 3;
  optional int32 size1 = 4;
  optional bytes chunkname2 = 5;
}

message SwapChunkResponse {
  required int32 request_type = 1;
  required uint32 result = 2;
  optional bytes chunkname1 = 3;
  optional bytes chunkcontent1 = 4;
  optional int32 size1 = 5;
  optional bytes chunkname2 = 6;
  optional bytes chunkcontent2 = 7;
  optional int32 size2 = 8;
  required bytes pmid = 9;
}

message CacheChunkRequest {
  required bytes chunkname = 1;
  required bytes chunkcontent = 2;
  required bytes pmid = 3;
  required bytes public_key = 4;
  required bytes public_key_signature = 5;
  required bytes request_signature = 6;
}

message CacheChunkResponse {
  required uint32 result = 1;
}

message VaultCommunication {
  optional bytes chunkstore = 1;
  optional uint64 offered_space = 2;
  optional uint64 free_space = 3;
  optional bytes ip = 4;
  optional uint32 port = 5;
  required uint32 timestamp = 6;
}

message VaultStatusRequest {
  required bytes encrypted_request = 1;  // Serialised encrypted
                                         // VaultCommunication
}

message VaultStatusResponse {
  required uint32 result = 1;
  optional bytes encrypted_response = 2;  // Serialised encrypted
                                          // VaultCommunication
}

enum OwnLocalVaultResult {
  OWNED_SUCCESS = 0;
  VAULT_ALREADY_OWNED = 1;
  VAULT_IS_DOWN = 2;
  INVALID_RSA_KEYS = 3;
  NOT_ENOUGH_SPACE = 4;
  NO_SPACE_ALLOCATED = 5;
  INVALID_PORT = 6;
  FAILED_TO_START_VAULT = 7;
  INVALID_OWNREQUEST = 8;
  INVALID_PMID_NAME = 9;
}

message SetLocalVaultOwnedRequest {
  required bytes public_key = 1;
  required bytes private_key = 2;
  required bytes signed_public_key = 3;
  required bytes vault_dir = 4;
  required uint32 port = 5;
  required uint64 space = 6;
}

message SetLocalVaultOwnedResponse {
  required OwnLocalVaultResult result = 1;
  optional bytes pmid_name = 2;
}

enum VaultStatus {
  NOT_OWNED = 0;
  OWNED = 1;
  DOWN = 2;
  ISOWNRPC_CANCELLED = 3;
}

message LocalVaultOwnedRequest {}

message LocalVaultOwnedResponse {
  required VaultStatus status = 1;
}

// Buffer Packet Ops

message CreateBPRequest {
  required bytes bufferpacket_name = 1;
  required bytes data = 2;
  required bytes pmid = 3;
  required bytes public_key = 4;
  required bytes signed_public_key = 5;
  required bytes signed_request = 6;
}

message CreateBPResponse {
  required uint32 result = 1;
  optional bytes pmid_id = 2;
  optional bytes public_key = 3;
  optional bytes signed_public_key = 4;
}

message ModifyBPInfoRequest {
  required bytes bufferpacket_name = 1;
  required bytes data = 2;
  required bytes pmid = 3;
  required bytes public_key = 4;
  required bytes signed_public_key = 5;
  required bytes signed_request = 6;
}

message ModifyBPInfoResponse {
  required uint32 result = 1;
  optional bytes pmid_id = 2;
  optional bytes public_key = 3;
  optional bytes signed_public_key = 4;
}

message GetBPMessagesRequest {
  required bytes bufferpacket_name = 1;
  required bytes public_key = 2;
  required bytes pmid = 3;
  required bytes signed_public_key = 4;
  required bytes signed_request = 5;
}

message GetBPMessagesResponse {
  required uint32 result = 1;
  repeated bytes messages = 2;
  optional bytes pmid_id = 3;
  optional bytes public_key = 4;
  optional bytes signed_public_key = 5;
}

message AddBPMessageRequest {
  required bytes bufferpacket_name = 1;
  required bytes data = 2;
  required bytes pmid = 3;
  required bytes public_key = 4;
  required bytes signed_public_key = 5;
  required bytes signed_request = 6;
}

message AddBPMessageResponse {
  required uint32 result = 1;
  optional bytes pmid_id = 2;
  optional bytes public_key = 3;
  optional bytes signed_public_key = 4;
}

message ContactInfoRequest {
  required bytes bufferpacket_name = 1;
  required bytes id = 2;
  required bytes pmid = 3;
  required bytes public_key = 4;
  required bytes public_key_signature = 5;
  required bytes request_signature = 6;
}

message ContactInfoResponse {
  required uint32 result = 1;
  optional bytes pmid_id = 2;
  optional bytes public_key = 3;
  optional bytes public_key_signature = 4;
  optional EndPoint ep = 5;
  optional PersonalDetails pd = 6;
  optional uint32 status = 7;
}
