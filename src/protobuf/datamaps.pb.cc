// Generated by the protocol buffer compiler.  DO NOT EDIT!

#include "datamaps.pb.h"
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format_inl.h>

namespace maidsafe {

namespace {

const ::google::protobuf::Descriptor* Key_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Key_reflection_ = NULL;
const ::google::protobuf::Descriptor* DataMap_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DataMap_reflection_ = NULL;
const ::google::protobuf::Descriptor* MetaDataMap_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MetaDataMap_reflection_ = NULL;
const ::google::protobuf::Descriptor* Chunk_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Chunk_reflection_ = NULL;
const ::google::protobuf::Descriptor* DataAtlas_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DataAtlas_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* itemtype_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* PacketType_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_datamaps_2eproto() {
  protobuf_AddDesc_datamaps_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "datamaps.proto");
  GOOGLE_CHECK(file != NULL);
  Key_descriptor_ = file->message_type(0);
  static const int Key_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Key, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Key, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Key, private_key_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Key, public_key_),
  };
  Key_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Key_descriptor_,
      Key::default_instance_,
      Key_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Key, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Key, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Key));
  DataMap_descriptor_ = file->message_type(1);
  static const int DataMap_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataMap, file_hash_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataMap, se_version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataMap, chunk_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataMap, encrypted_chunk_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataMap, chunk_size_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataMap, compression_on_),
  };
  DataMap_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      DataMap_descriptor_,
      DataMap::default_instance_,
      DataMap_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataMap, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataMap, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(DataMap));
  MetaDataMap_descriptor_ = file->message_type(2);
  static const int MetaDataMap_offsets_[11] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MetaDataMap, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MetaDataMap, display_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MetaDataMap, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MetaDataMap, file_hash_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MetaDataMap, stats_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MetaDataMap, tag_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MetaDataMap, file_size_high_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MetaDataMap, file_size_low_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MetaDataMap, creation_time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MetaDataMap, last_modified_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MetaDataMap, last_access_),
  };
  MetaDataMap_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MetaDataMap_descriptor_,
      MetaDataMap::default_instance_,
      MetaDataMap_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MetaDataMap, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MetaDataMap, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MetaDataMap));
  Chunk_descriptor_ = file->message_type(3);
  static const int Chunk_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Chunk, compression_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Chunk, chunklet_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Chunk, pre_compression_chunklet_size_),
  };
  Chunk_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Chunk_descriptor_,
      Chunk::default_instance_,
      Chunk_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Chunk, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Chunk, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Chunk));
  DataAtlas_descriptor_ = file->message_type(4);
  static const int DataAtlas_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataAtlas, root_db_key_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataAtlas, keys_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataAtlas, mdms_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataAtlas, dms_),
  };
  DataAtlas_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      DataAtlas_descriptor_,
      DataAtlas::default_instance_,
      DataAtlas_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataAtlas, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataAtlas, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(DataAtlas));
  itemtype_descriptor_ = file->enum_type(0);
  PacketType_descriptor_ = file->enum_type(1);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_datamaps_2eproto);
}

void protobuf_RegisterTypes() {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Key_descriptor_, &Key::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    DataMap_descriptor_, &DataMap::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MetaDataMap_descriptor_, &MetaDataMap::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Chunk_descriptor_, &Chunk::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    DataAtlas_descriptor_, &DataAtlas::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_datamaps_2eproto() {
  delete Key::default_instance_;
  delete Key_reflection_;
  delete DataMap::default_instance_;
  delete DataMap_reflection_;
  delete MetaDataMap::default_instance_;
  delete MetaDataMap_reflection_;
  delete Chunk::default_instance_;
  delete Chunk_reflection_;
  delete DataAtlas::default_instance_;
  delete DataAtlas_reflection_;
}

void protobuf_AddDesc_datamaps_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\016datamaps.proto\022\010maidsafe\"^\n\003Key\022\n\n\002id\030"
    "\001 \002(\014\022\"\n\004type\030\002 \002(\0162\024.maidsafe.PacketTyp"
    "e\022\023\n\013private_key\030\003 \002(\014\022\022\n\npublic_key\030\004 \002"
    "(\014\"\225\001\n\007DataMap\022\021\n\tfile_hash\030\001 \002(\014\022\022\n\nse_"
    "version\030\002 \001(\014\022\022\n\nchunk_name\030\003 \003(\014\022\034\n\024enc"
    "rypted_chunk_name\030\004 \003(\014\022\022\n\nchunk_size\030\005 "
    "\003(\004\022\035\n\016compression_on\030\006 \001(\010:\005false\"\362\001\n\013M"
    "etaDataMap\022\n\n\002id\030\001 \002(\005\022\024\n\014display_name\030\002"
    " \002(\014\022 \n\004type\030\003 \002(\0162\022.maidsafe.itemtype\022\021"
    "\n\tfile_hash\030\004 \003(\014\022\r\n\005stats\030\005 \001(\014\022\013\n\003tag\030"
    "\006 \001(\014\022\026\n\016file_size_high\030\007 \001(\005\022\025\n\rfile_si"
    "ze_low\030\010 \001(\005\022\025\n\rcreation_time\030\t \001(\005\022\025\n\rl"
    "ast_modified\030\n \001(\005\022\023\n\013last_access\030\013 \001(\005\""
    "Z\n\005Chunk\022\030\n\020compression_type\030\001 \001(\014\022\020\n\010ch"
    "unklet\030\002 \003(\014\022%\n\035pre_compression_chunklet"
    "_size\030\003 \003(\005\"\202\001\n\tDataAtlas\022\023\n\013root_db_key"
    "\030\001 \001(\014\022\033\n\004keys\030\002 \003(\0132\r.maidsafe.Key\022#\n\004m"
    "dms\030\003 \003(\0132\025.maidsafe.MetaDataMap\022\036\n\003dms\030"
    "\004 \003(\0132\021.maidsafe.DataMap*\240\001\n\010itemtype\022\020\n"
    "\014REGULAR_FILE\020\000\022\016\n\nSMALL_FILE\020\001\022\016\n\nEMPTY"
    "_FILE\020\002\022\017\n\013LOCKED_FILE\020\003\022\r\n\tDIRECTORY\020\004\022"
    "\023\n\017EMPTY_DIRECTORY\020\005\022\010\n\004LINK\020\006\022\026\n\022NOT_FO"
    "R_PROCESSING\020\007\022\013\n\007UNKNOWN\020\010*Y\n\nPacketTyp"
    "e\022\t\n\005ANMID\020\000\022\n\n\006ANTMID\020\001\022\n\n\006ANSMID\020\002\022\010\n\004"
    "MAID\020\003\022\010\n\004PMID\020\004\022\n\n\006ANMPID\020\005\022\010\n\004MPID\020\006", 998);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "datamaps.proto", &protobuf_RegisterTypes);
  Key::default_instance_ = new Key();
  DataMap::default_instance_ = new DataMap();
  MetaDataMap::default_instance_ = new MetaDataMap();
  Chunk::default_instance_ = new Chunk();
  DataAtlas::default_instance_ = new DataAtlas();
  Key::default_instance_->InitAsDefaultInstance();
  DataMap::default_instance_->InitAsDefaultInstance();
  MetaDataMap::default_instance_->InitAsDefaultInstance();
  Chunk::default_instance_->InitAsDefaultInstance();
  DataAtlas::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_datamaps_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_datamaps_2eproto {
  StaticDescriptorInitializer_datamaps_2eproto() {
    protobuf_AddDesc_datamaps_2eproto();
  }
} static_descriptor_initializer_datamaps_2eproto_;

const ::google::protobuf::EnumDescriptor* itemtype_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return itemtype_descriptor_;
}
bool itemtype_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* PacketType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PacketType_descriptor_;
}
bool PacketType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}


// ===================================================================

const ::std::string Key::_default_id_;
const ::std::string Key::_default_private_key_;
const ::std::string Key::_default_public_key_;
#ifndef _MSC_VER
const int Key::kIdFieldNumber;
const int Key::kTypeFieldNumber;
const int Key::kPrivateKeyFieldNumber;
const int Key::kPublicKeyFieldNumber;
#endif  // !_MSC_VER

Key::Key()
  : ::google::protobuf::Message(),
    _unknown_fields_(),
    _cached_size_(0),
    id_(const_cast< ::std::string*>(&_default_id_)),
    type_(0),
    private_key_(const_cast< ::std::string*>(&_default_private_key_)),
    public_key_(const_cast< ::std::string*>(&_default_public_key_)) {
  SharedCtor();
}

void Key::InitAsDefaultInstance() {}

Key::Key(const Key& from)
  : ::google::protobuf::Message(),
    _unknown_fields_(),
    _cached_size_(0),
    id_(const_cast< ::std::string*>(&_default_id_)),
    type_(0),
    private_key_(const_cast< ::std::string*>(&_default_private_key_)),
    public_key_(const_cast< ::std::string*>(&_default_public_key_)) {
  SharedCtor();
  MergeFrom(from);
}

void Key::SharedCtor() {
  _cached_size_ = 0;
  id_ = const_cast< ::std::string*>(&_default_id_);
  type_ = 0;
  private_key_ = const_cast< ::std::string*>(&_default_private_key_);
  public_key_ = const_cast< ::std::string*>(&_default_public_key_);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Key::~Key() {
  SharedDtor();
}

void Key::SharedDtor() {
  if (id_ != &_default_id_) {
    delete id_;
  }
  if (private_key_ != &_default_private_key_) {
    delete private_key_;
  }
  if (public_key_ != &_default_public_key_) {
    delete public_key_;
  }
  if (this != default_instance_) {
  }
}

const ::google::protobuf::Descriptor* Key::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Key_descriptor_;
}

const Key& Key::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_datamaps_2eproto();  return *default_instance_;
}

Key* Key::default_instance_ = NULL;

Key* Key::New() const {
  return new Key;
}

void Key::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (id_ != &_default_id_) {
        id_->clear();
      }
    }
    type_ = 0;
    if (_has_bit(2)) {
      if (private_key_ != &_default_private_key_) {
        private_key_->clear();
      }
    }
    if (_has_bit(3)) {
      if (public_key_ != &_default_public_key_) {
        public_key_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Key::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormat::GetTagFieldNumber(tag)) {
      // required bytes id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormat::ReadBytes(input, mutable_id()));
        if (input->ExpectTag(16)) goto parse_type;
        break;
      }
      
      // required .maidsafe.PacketType type = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_type:
        int value;
        DO_(::google::protobuf::internal::WireFormat::ReadEnum(input, &value));
        if (maidsafe::PacketType_IsValid(value)) {
          set_type(static_cast< maidsafe::PacketType >(value));
        } else {
          mutable_unknown_fields()->AddVarint(2, value);
        }
        if (input->ExpectTag(26)) goto parse_private_key;
        break;
      }
      
      // required bytes private_key = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_private_key:
        DO_(::google::protobuf::internal::WireFormat::ReadBytes(input, mutable_private_key()));
        if (input->ExpectTag(34)) goto parse_public_key;
        break;
      }
      
      // required bytes public_key = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_public_key:
        DO_(::google::protobuf::internal::WireFormat::ReadBytes(input, mutable_public_key()));
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormat::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Key::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    Key::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // required bytes id = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::WriteBytes(1, this->id(), output);
  }
  
  // required .maidsafe.PacketType type = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::WriteEnum(2, this->type(), output);
  }
  
  // required bytes private_key = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormat::WriteBytes(3, this->private_key(), output);
  }
  
  // required bytes public_key = 4;
  if (_has_bit(3)) {
    ::google::protobuf::internal::WireFormat::WriteBytes(4, this->public_key(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Key::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required bytes id = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormat::WriteBytesToArray(1, this->id(), target);
  }
  
  // required .maidsafe.PacketType type = 2;
  if (_has_bit(1)) {
    target = ::google::protobuf::internal::WireFormat::WriteEnumToArray(2, this->type(), target);
  }
  
  // required bytes private_key = 3;
  if (_has_bit(2)) {
    target = ::google::protobuf::internal::WireFormat::WriteBytesToArray(3, this->private_key(), target);
  }
  
  // required bytes public_key = 4;
  if (_has_bit(3)) {
    target = ::google::protobuf::internal::WireFormat::WriteBytesToArray(4, this->public_key(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Key::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::BytesSize(this->id());
    }
    
    // required .maidsafe.PacketType type = 2;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::EnumSize(this->type());
    }
    
    // required bytes private_key = 3;
    if (has_private_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::BytesSize(this->private_key());
    }
    
    // required bytes public_key = 4;
    if (has_public_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::BytesSize(this->public_key());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void Key::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Key* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Key*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Key::MergeFrom(const Key& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_id(from.id());
    }
    if (from._has_bit(1)) {
      set_type(from.type());
    }
    if (from._has_bit(2)) {
      set_private_key(from.private_key());
    }
    if (from._has_bit(3)) {
      set_public_key(from.public_key());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Key::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Key::CopyFrom(const Key& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Key::Swap(Key* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(type_, other->type_);
    std::swap(private_key_, other->private_key_);
    std::swap(public_key_, other->public_key_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

bool Key::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;
  
  return true;
}

const ::google::protobuf::Descriptor* Key::GetDescriptor() const {
  return descriptor();
}

const ::google::protobuf::Reflection* Key::GetReflection() const {
  protobuf_AssignDescriptorsOnce();
  return Key_reflection_;
}

// ===================================================================

const ::std::string DataMap::_default_file_hash_;
const ::std::string DataMap::_default_se_version_;
#ifndef _MSC_VER
const int DataMap::kFileHashFieldNumber;
const int DataMap::kSeVersionFieldNumber;
const int DataMap::kChunkNameFieldNumber;
const int DataMap::kEncryptedChunkNameFieldNumber;
const int DataMap::kChunkSizeFieldNumber;
const int DataMap::kCompressionOnFieldNumber;
#endif  // !_MSC_VER

DataMap::DataMap()
  : ::google::protobuf::Message(),
    _unknown_fields_(),
    _cached_size_(0),
    file_hash_(const_cast< ::std::string*>(&_default_file_hash_)),
    se_version_(const_cast< ::std::string*>(&_default_se_version_)),
    chunk_name_(),
    encrypted_chunk_name_(),
    chunk_size_(),
    compression_on_(false) {
  SharedCtor();
}

void DataMap::InitAsDefaultInstance() {}

DataMap::DataMap(const DataMap& from)
  : ::google::protobuf::Message(),
    _unknown_fields_(),
    _cached_size_(0),
    file_hash_(const_cast< ::std::string*>(&_default_file_hash_)),
    se_version_(const_cast< ::std::string*>(&_default_se_version_)),
    chunk_name_(),
    encrypted_chunk_name_(),
    chunk_size_(),
    compression_on_(false) {
  SharedCtor();
  MergeFrom(from);
}

void DataMap::SharedCtor() {
  _cached_size_ = 0;
  file_hash_ = const_cast< ::std::string*>(&_default_file_hash_);
  se_version_ = const_cast< ::std::string*>(&_default_se_version_);
  compression_on_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DataMap::~DataMap() {
  SharedDtor();
}

void DataMap::SharedDtor() {
  if (file_hash_ != &_default_file_hash_) {
    delete file_hash_;
  }
  if (se_version_ != &_default_se_version_) {
    delete se_version_;
  }
  if (this != default_instance_) {
  }
}

const ::google::protobuf::Descriptor* DataMap::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DataMap_descriptor_;
}

const DataMap& DataMap::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_datamaps_2eproto();  return *default_instance_;
}

DataMap* DataMap::default_instance_ = NULL;

DataMap* DataMap::New() const {
  return new DataMap;
}

void DataMap::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (file_hash_ != &_default_file_hash_) {
        file_hash_->clear();
      }
    }
    if (_has_bit(1)) {
      if (se_version_ != &_default_se_version_) {
        se_version_->clear();
      }
    }
    compression_on_ = false;
  }
  chunk_name_.Clear();
  encrypted_chunk_name_.Clear();
  chunk_size_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool DataMap::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormat::GetTagFieldNumber(tag)) {
      // required bytes file_hash = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormat::ReadBytes(input, mutable_file_hash()));
        if (input->ExpectTag(18)) goto parse_se_version;
        break;
      }
      
      // optional bytes se_version = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_se_version:
        DO_(::google::protobuf::internal::WireFormat::ReadBytes(input, mutable_se_version()));
        if (input->ExpectTag(26)) goto parse_chunk_name;
        break;
      }
      
      // repeated bytes chunk_name = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_chunk_name:
        DO_(::google::protobuf::internal::WireFormat::ReadBytes(
             input, add_chunk_name()));
        if (input->ExpectTag(26)) goto parse_chunk_name;
        if (input->ExpectTag(34)) goto parse_encrypted_chunk_name;
        break;
      }
      
      // repeated bytes encrypted_chunk_name = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_encrypted_chunk_name:
        DO_(::google::protobuf::internal::WireFormat::ReadBytes(
             input, add_encrypted_chunk_name()));
        if (input->ExpectTag(34)) goto parse_encrypted_chunk_name;
        if (input->ExpectTag(40)) goto parse_chunk_size;
        break;
      }
      
      // repeated uint64 chunk_size = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_chunk_size:
        ::google::protobuf::uint64 value;
        DO_(::google::protobuf::internal::WireFormat::ReadUInt64(input, &value));
        add_chunk_size(value);
        if (input->ExpectTag(40)) goto parse_chunk_size;
        if (input->ExpectTag(48)) goto parse_compression_on;
        break;
      }
      
      // optional bool compression_on = 6 [default = false];
      case 6: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_compression_on:
        DO_(::google::protobuf::internal::WireFormat::ReadBool(
              input, &compression_on_));
        _set_bit(5);
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormat::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DataMap::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    DataMap::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // required bytes file_hash = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::WriteBytes(1, this->file_hash(), output);
  }
  
  // optional bytes se_version = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::WriteBytes(2, this->se_version(), output);
  }
  
  // repeated bytes chunk_name = 3;
  for (int i = 0; i < this->chunk_name_size(); i++) {
    ::google::protobuf::internal::WireFormat::WriteBytes(3, this->chunk_name(i), output);
  }
  
  // repeated bytes encrypted_chunk_name = 4;
  for (int i = 0; i < this->encrypted_chunk_name_size(); i++) {
    ::google::protobuf::internal::WireFormat::WriteBytes(4, this->encrypted_chunk_name(i), output);
  }
  
  // repeated uint64 chunk_size = 5;
  for (int i = 0; i < this->chunk_size_size(); i++) {
    ::google::protobuf::internal::WireFormat::WriteUInt64(5, this->chunk_size(i), output);
  }
  
  // optional bool compression_on = 6 [default = false];
  if (_has_bit(5)) {
    ::google::protobuf::internal::WireFormat::WriteBool(6, this->compression_on(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* DataMap::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required bytes file_hash = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormat::WriteBytesToArray(1, this->file_hash(), target);
  }
  
  // optional bytes se_version = 2;
  if (_has_bit(1)) {
    target = ::google::protobuf::internal::WireFormat::WriteBytesToArray(2, this->se_version(), target);
  }
  
  // repeated bytes chunk_name = 3;
  for (int i = 0; i < this->chunk_name_size(); i++) {
    target = ::google::protobuf::internal::WireFormat::WriteBytesToArray(3, this->chunk_name(i), target);
  }
  
  // repeated bytes encrypted_chunk_name = 4;
  for (int i = 0; i < this->encrypted_chunk_name_size(); i++) {
    target = ::google::protobuf::internal::WireFormat::WriteBytesToArray(4, this->encrypted_chunk_name(i), target);
  }
  
  // repeated uint64 chunk_size = 5;
  for (int i = 0; i < this->chunk_size_size(); i++) {
    target = ::google::protobuf::internal::WireFormat::WriteUInt64ToArray(5, this->chunk_size(i), target);
  }
  
  // optional bool compression_on = 6 [default = false];
  if (_has_bit(5)) {
    target = ::google::protobuf::internal::WireFormat::WriteBoolToArray(6, this->compression_on(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int DataMap::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes file_hash = 1;
    if (has_file_hash()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::BytesSize(this->file_hash());
    }
    
    // optional bytes se_version = 2;
    if (has_se_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::BytesSize(this->se_version());
    }
    
    // optional bool compression_on = 6 [default = false];
    if (has_compression_on()) {
      total_size += 1 + 1;
    }
    
  }
  // repeated bytes chunk_name = 3;
  total_size += 1 * this->chunk_name_size();
  for (int i = 0; i < this->chunk_name_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormat::BytesSize(
      this->chunk_name(i));
  }
  
  // repeated bytes encrypted_chunk_name = 4;
  total_size += 1 * this->encrypted_chunk_name_size();
  for (int i = 0; i < this->encrypted_chunk_name_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormat::BytesSize(
      this->encrypted_chunk_name(i));
  }
  
  // repeated uint64 chunk_size = 5;
  {
    int data_size = 0;
    for (int i = 0; i < this->chunk_size_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormat::UInt64Size(
        this->chunk_size(i));
    }
    total_size += 1 * this->chunk_size_size() + data_size;
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void DataMap::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const DataMap* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const DataMap*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DataMap::MergeFrom(const DataMap& from) {
  GOOGLE_CHECK_NE(&from, this);
  chunk_name_.MergeFrom(from.chunk_name_);
  encrypted_chunk_name_.MergeFrom(from.encrypted_chunk_name_);
  chunk_size_.MergeFrom(from.chunk_size_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_file_hash(from.file_hash());
    }
    if (from._has_bit(1)) {
      set_se_version(from.se_version());
    }
    if (from._has_bit(5)) {
      set_compression_on(from.compression_on());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void DataMap::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DataMap::CopyFrom(const DataMap& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DataMap::Swap(DataMap* other) {
  if (other != this) {
    std::swap(file_hash_, other->file_hash_);
    std::swap(se_version_, other->se_version_);
    chunk_name_.Swap(&other->chunk_name_);
    encrypted_chunk_name_.Swap(&other->encrypted_chunk_name_);
    chunk_size_.Swap(&other->chunk_size_);
    std::swap(compression_on_, other->compression_on_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

bool DataMap::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

const ::google::protobuf::Descriptor* DataMap::GetDescriptor() const {
  return descriptor();
}

const ::google::protobuf::Reflection* DataMap::GetReflection() const {
  protobuf_AssignDescriptorsOnce();
  return DataMap_reflection_;
}

// ===================================================================

const ::std::string MetaDataMap::_default_display_name_;
const ::std::string MetaDataMap::_default_stats_;
const ::std::string MetaDataMap::_default_tag_;
#ifndef _MSC_VER
const int MetaDataMap::kIdFieldNumber;
const int MetaDataMap::kDisplayNameFieldNumber;
const int MetaDataMap::kTypeFieldNumber;
const int MetaDataMap::kFileHashFieldNumber;
const int MetaDataMap::kStatsFieldNumber;
const int MetaDataMap::kTagFieldNumber;
const int MetaDataMap::kFileSizeHighFieldNumber;
const int MetaDataMap::kFileSizeLowFieldNumber;
const int MetaDataMap::kCreationTimeFieldNumber;
const int MetaDataMap::kLastModifiedFieldNumber;
const int MetaDataMap::kLastAccessFieldNumber;
#endif  // !_MSC_VER

MetaDataMap::MetaDataMap()
  : ::google::protobuf::Message(),
    _unknown_fields_(),
    _cached_size_(0),
    id_(0),
    display_name_(const_cast< ::std::string*>(&_default_display_name_)),
    type_(0),
    file_hash_(),
    stats_(const_cast< ::std::string*>(&_default_stats_)),
    tag_(const_cast< ::std::string*>(&_default_tag_)),
    file_size_high_(0),
    file_size_low_(0),
    creation_time_(0),
    last_modified_(0),
    last_access_(0) {
  SharedCtor();
}

void MetaDataMap::InitAsDefaultInstance() {}

MetaDataMap::MetaDataMap(const MetaDataMap& from)
  : ::google::protobuf::Message(),
    _unknown_fields_(),
    _cached_size_(0),
    id_(0),
    display_name_(const_cast< ::std::string*>(&_default_display_name_)),
    type_(0),
    file_hash_(),
    stats_(const_cast< ::std::string*>(&_default_stats_)),
    tag_(const_cast< ::std::string*>(&_default_tag_)),
    file_size_high_(0),
    file_size_low_(0),
    creation_time_(0),
    last_modified_(0),
    last_access_(0) {
  SharedCtor();
  MergeFrom(from);
}

void MetaDataMap::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0;
  display_name_ = const_cast< ::std::string*>(&_default_display_name_);
  type_ = 0;
  stats_ = const_cast< ::std::string*>(&_default_stats_);
  tag_ = const_cast< ::std::string*>(&_default_tag_);
  file_size_high_ = 0;
  file_size_low_ = 0;
  creation_time_ = 0;
  last_modified_ = 0;
  last_access_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MetaDataMap::~MetaDataMap() {
  SharedDtor();
}

void MetaDataMap::SharedDtor() {
  if (display_name_ != &_default_display_name_) {
    delete display_name_;
  }
  if (stats_ != &_default_stats_) {
    delete stats_;
  }
  if (tag_ != &_default_tag_) {
    delete tag_;
  }
  if (this != default_instance_) {
  }
}

const ::google::protobuf::Descriptor* MetaDataMap::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MetaDataMap_descriptor_;
}

const MetaDataMap& MetaDataMap::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_datamaps_2eproto();  return *default_instance_;
}

MetaDataMap* MetaDataMap::default_instance_ = NULL;

MetaDataMap* MetaDataMap::New() const {
  return new MetaDataMap;
}

void MetaDataMap::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = 0;
    if (_has_bit(1)) {
      if (display_name_ != &_default_display_name_) {
        display_name_->clear();
      }
    }
    type_ = 0;
    if (_has_bit(4)) {
      if (stats_ != &_default_stats_) {
        stats_->clear();
      }
    }
    if (_has_bit(5)) {
      if (tag_ != &_default_tag_) {
        tag_->clear();
      }
    }
    file_size_high_ = 0;
    file_size_low_ = 0;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    creation_time_ = 0;
    last_modified_ = 0;
    last_access_ = 0;
  }
  file_hash_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MetaDataMap::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormat::GetTagFieldNumber(tag)) {
      // required int32 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormat::ReadInt32(
              input, &id_));
        _set_bit(0);
        if (input->ExpectTag(18)) goto parse_display_name;
        break;
      }
      
      // required bytes display_name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_display_name:
        DO_(::google::protobuf::internal::WireFormat::ReadBytes(input, mutable_display_name()));
        if (input->ExpectTag(24)) goto parse_type;
        break;
      }
      
      // required .maidsafe.itemtype type = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_type:
        int value;
        DO_(::google::protobuf::internal::WireFormat::ReadEnum(input, &value));
        if (maidsafe::itemtype_IsValid(value)) {
          set_type(static_cast< maidsafe::itemtype >(value));
        } else {
          mutable_unknown_fields()->AddVarint(3, value);
        }
        if (input->ExpectTag(34)) goto parse_file_hash;
        break;
      }
      
      // repeated bytes file_hash = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_file_hash:
        DO_(::google::protobuf::internal::WireFormat::ReadBytes(
             input, add_file_hash()));
        if (input->ExpectTag(34)) goto parse_file_hash;
        if (input->ExpectTag(42)) goto parse_stats;
        break;
      }
      
      // optional bytes stats = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_stats:
        DO_(::google::protobuf::internal::WireFormat::ReadBytes(input, mutable_stats()));
        if (input->ExpectTag(50)) goto parse_tag;
        break;
      }
      
      // optional bytes tag = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_tag:
        DO_(::google::protobuf::internal::WireFormat::ReadBytes(input, mutable_tag()));
        if (input->ExpectTag(56)) goto parse_file_size_high;
        break;
      }
      
      // optional int32 file_size_high = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_file_size_high:
        DO_(::google::protobuf::internal::WireFormat::ReadInt32(
              input, &file_size_high_));
        _set_bit(6);
        if (input->ExpectTag(64)) goto parse_file_size_low;
        break;
      }
      
      // optional int32 file_size_low = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_file_size_low:
        DO_(::google::protobuf::internal::WireFormat::ReadInt32(
              input, &file_size_low_));
        _set_bit(7);
        if (input->ExpectTag(72)) goto parse_creation_time;
        break;
      }
      
      // optional int32 creation_time = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_creation_time:
        DO_(::google::protobuf::internal::WireFormat::ReadInt32(
              input, &creation_time_));
        _set_bit(8);
        if (input->ExpectTag(80)) goto parse_last_modified;
        break;
      }
      
      // optional int32 last_modified = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_last_modified:
        DO_(::google::protobuf::internal::WireFormat::ReadInt32(
              input, &last_modified_));
        _set_bit(9);
        if (input->ExpectTag(88)) goto parse_last_access;
        break;
      }
      
      // optional int32 last_access = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_last_access:
        DO_(::google::protobuf::internal::WireFormat::ReadInt32(
              input, &last_access_));
        _set_bit(10);
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormat::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MetaDataMap::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    MetaDataMap::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // required int32 id = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::WriteInt32(1, this->id(), output);
  }
  
  // required bytes display_name = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::WriteBytes(2, this->display_name(), output);
  }
  
  // required .maidsafe.itemtype type = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormat::WriteEnum(3, this->type(), output);
  }
  
  // repeated bytes file_hash = 4;
  for (int i = 0; i < this->file_hash_size(); i++) {
    ::google::protobuf::internal::WireFormat::WriteBytes(4, this->file_hash(i), output);
  }
  
  // optional bytes stats = 5;
  if (_has_bit(4)) {
    ::google::protobuf::internal::WireFormat::WriteBytes(5, this->stats(), output);
  }
  
  // optional bytes tag = 6;
  if (_has_bit(5)) {
    ::google::protobuf::internal::WireFormat::WriteBytes(6, this->tag(), output);
  }
  
  // optional int32 file_size_high = 7;
  if (_has_bit(6)) {
    ::google::protobuf::internal::WireFormat::WriteInt32(7, this->file_size_high(), output);
  }
  
  // optional int32 file_size_low = 8;
  if (_has_bit(7)) {
    ::google::protobuf::internal::WireFormat::WriteInt32(8, this->file_size_low(), output);
  }
  
  // optional int32 creation_time = 9;
  if (_has_bit(8)) {
    ::google::protobuf::internal::WireFormat::WriteInt32(9, this->creation_time(), output);
  }
  
  // optional int32 last_modified = 10;
  if (_has_bit(9)) {
    ::google::protobuf::internal::WireFormat::WriteInt32(10, this->last_modified(), output);
  }
  
  // optional int32 last_access = 11;
  if (_has_bit(10)) {
    ::google::protobuf::internal::WireFormat::WriteInt32(11, this->last_access(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MetaDataMap::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 id = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormat::WriteInt32ToArray(1, this->id(), target);
  }
  
  // required bytes display_name = 2;
  if (_has_bit(1)) {
    target = ::google::protobuf::internal::WireFormat::WriteBytesToArray(2, this->display_name(), target);
  }
  
  // required .maidsafe.itemtype type = 3;
  if (_has_bit(2)) {
    target = ::google::protobuf::internal::WireFormat::WriteEnumToArray(3, this->type(), target);
  }
  
  // repeated bytes file_hash = 4;
  for (int i = 0; i < this->file_hash_size(); i++) {
    target = ::google::protobuf::internal::WireFormat::WriteBytesToArray(4, this->file_hash(i), target);
  }
  
  // optional bytes stats = 5;
  if (_has_bit(4)) {
    target = ::google::protobuf::internal::WireFormat::WriteBytesToArray(5, this->stats(), target);
  }
  
  // optional bytes tag = 6;
  if (_has_bit(5)) {
    target = ::google::protobuf::internal::WireFormat::WriteBytesToArray(6, this->tag(), target);
  }
  
  // optional int32 file_size_high = 7;
  if (_has_bit(6)) {
    target = ::google::protobuf::internal::WireFormat::WriteInt32ToArray(7, this->file_size_high(), target);
  }
  
  // optional int32 file_size_low = 8;
  if (_has_bit(7)) {
    target = ::google::protobuf::internal::WireFormat::WriteInt32ToArray(8, this->file_size_low(), target);
  }
  
  // optional int32 creation_time = 9;
  if (_has_bit(8)) {
    target = ::google::protobuf::internal::WireFormat::WriteInt32ToArray(9, this->creation_time(), target);
  }
  
  // optional int32 last_modified = 10;
  if (_has_bit(9)) {
    target = ::google::protobuf::internal::WireFormat::WriteInt32ToArray(10, this->last_modified(), target);
  }
  
  // optional int32 last_access = 11;
  if (_has_bit(10)) {
    target = ::google::protobuf::internal::WireFormat::WriteInt32ToArray(11, this->last_access(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MetaDataMap::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::Int32Size(
          this->id());
    }
    
    // required bytes display_name = 2;
    if (has_display_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::BytesSize(this->display_name());
    }
    
    // required .maidsafe.itemtype type = 3;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::EnumSize(this->type());
    }
    
    // optional bytes stats = 5;
    if (has_stats()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::BytesSize(this->stats());
    }
    
    // optional bytes tag = 6;
    if (has_tag()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::BytesSize(this->tag());
    }
    
    // optional int32 file_size_high = 7;
    if (has_file_size_high()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::Int32Size(
          this->file_size_high());
    }
    
    // optional int32 file_size_low = 8;
    if (has_file_size_low()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::Int32Size(
          this->file_size_low());
    }
    
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional int32 creation_time = 9;
    if (has_creation_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::Int32Size(
          this->creation_time());
    }
    
    // optional int32 last_modified = 10;
    if (has_last_modified()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::Int32Size(
          this->last_modified());
    }
    
    // optional int32 last_access = 11;
    if (has_last_access()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::Int32Size(
          this->last_access());
    }
    
  }
  // repeated bytes file_hash = 4;
  total_size += 1 * this->file_hash_size();
  for (int i = 0; i < this->file_hash_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormat::BytesSize(
      this->file_hash(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void MetaDataMap::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MetaDataMap* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MetaDataMap*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MetaDataMap::MergeFrom(const MetaDataMap& from) {
  GOOGLE_CHECK_NE(&from, this);
  file_hash_.MergeFrom(from.file_hash_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_id(from.id());
    }
    if (from._has_bit(1)) {
      set_display_name(from.display_name());
    }
    if (from._has_bit(2)) {
      set_type(from.type());
    }
    if (from._has_bit(4)) {
      set_stats(from.stats());
    }
    if (from._has_bit(5)) {
      set_tag(from.tag());
    }
    if (from._has_bit(6)) {
      set_file_size_high(from.file_size_high());
    }
    if (from._has_bit(7)) {
      set_file_size_low(from.file_size_low());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from._has_bit(8)) {
      set_creation_time(from.creation_time());
    }
    if (from._has_bit(9)) {
      set_last_modified(from.last_modified());
    }
    if (from._has_bit(10)) {
      set_last_access(from.last_access());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MetaDataMap::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MetaDataMap::CopyFrom(const MetaDataMap& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MetaDataMap::Swap(MetaDataMap* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(display_name_, other->display_name_);
    std::swap(type_, other->type_);
    file_hash_.Swap(&other->file_hash_);
    std::swap(stats_, other->stats_);
    std::swap(tag_, other->tag_);
    std::swap(file_size_high_, other->file_size_high_);
    std::swap(file_size_low_, other->file_size_low_);
    std::swap(creation_time_, other->creation_time_);
    std::swap(last_modified_, other->last_modified_);
    std::swap(last_access_, other->last_access_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

bool MetaDataMap::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  
  return true;
}

const ::google::protobuf::Descriptor* MetaDataMap::GetDescriptor() const {
  return descriptor();
}

const ::google::protobuf::Reflection* MetaDataMap::GetReflection() const {
  protobuf_AssignDescriptorsOnce();
  return MetaDataMap_reflection_;
}

// ===================================================================

const ::std::string Chunk::_default_compression_type_;
#ifndef _MSC_VER
const int Chunk::kCompressionTypeFieldNumber;
const int Chunk::kChunkletFieldNumber;
const int Chunk::kPreCompressionChunkletSizeFieldNumber;
#endif  // !_MSC_VER

Chunk::Chunk()
  : ::google::protobuf::Message(),
    _unknown_fields_(),
    _cached_size_(0),
    compression_type_(const_cast< ::std::string*>(&_default_compression_type_)),
    chunklet_(),
    pre_compression_chunklet_size_() {
  SharedCtor();
}

void Chunk::InitAsDefaultInstance() {}

Chunk::Chunk(const Chunk& from)
  : ::google::protobuf::Message(),
    _unknown_fields_(),
    _cached_size_(0),
    compression_type_(const_cast< ::std::string*>(&_default_compression_type_)),
    chunklet_(),
    pre_compression_chunklet_size_() {
  SharedCtor();
  MergeFrom(from);
}

void Chunk::SharedCtor() {
  _cached_size_ = 0;
  compression_type_ = const_cast< ::std::string*>(&_default_compression_type_);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Chunk::~Chunk() {
  SharedDtor();
}

void Chunk::SharedDtor() {
  if (compression_type_ != &_default_compression_type_) {
    delete compression_type_;
  }
  if (this != default_instance_) {
  }
}

const ::google::protobuf::Descriptor* Chunk::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Chunk_descriptor_;
}

const Chunk& Chunk::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_datamaps_2eproto();  return *default_instance_;
}

Chunk* Chunk::default_instance_ = NULL;

Chunk* Chunk::New() const {
  return new Chunk;
}

void Chunk::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (compression_type_ != &_default_compression_type_) {
        compression_type_->clear();
      }
    }
  }
  chunklet_.Clear();
  pre_compression_chunklet_size_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Chunk::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormat::GetTagFieldNumber(tag)) {
      // optional bytes compression_type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormat::ReadBytes(input, mutable_compression_type()));
        if (input->ExpectTag(18)) goto parse_chunklet;
        break;
      }
      
      // repeated bytes chunklet = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_chunklet:
        DO_(::google::protobuf::internal::WireFormat::ReadBytes(
             input, add_chunklet()));
        if (input->ExpectTag(18)) goto parse_chunklet;
        if (input->ExpectTag(24)) goto parse_pre_compression_chunklet_size;
        break;
      }
      
      // repeated int32 pre_compression_chunklet_size = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_pre_compression_chunklet_size:
        ::google::protobuf::int32 value;
        DO_(::google::protobuf::internal::WireFormat::ReadInt32(input, &value));
        add_pre_compression_chunklet_size(value);
        if (input->ExpectTag(24)) goto parse_pre_compression_chunklet_size;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormat::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Chunk::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    Chunk::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // optional bytes compression_type = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::WriteBytes(1, this->compression_type(), output);
  }
  
  // repeated bytes chunklet = 2;
  for (int i = 0; i < this->chunklet_size(); i++) {
    ::google::protobuf::internal::WireFormat::WriteBytes(2, this->chunklet(i), output);
  }
  
  // repeated int32 pre_compression_chunklet_size = 3;
  for (int i = 0; i < this->pre_compression_chunklet_size_size(); i++) {
    ::google::protobuf::internal::WireFormat::WriteInt32(3, this->pre_compression_chunklet_size(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Chunk::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional bytes compression_type = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormat::WriteBytesToArray(1, this->compression_type(), target);
  }
  
  // repeated bytes chunklet = 2;
  for (int i = 0; i < this->chunklet_size(); i++) {
    target = ::google::protobuf::internal::WireFormat::WriteBytesToArray(2, this->chunklet(i), target);
  }
  
  // repeated int32 pre_compression_chunklet_size = 3;
  for (int i = 0; i < this->pre_compression_chunklet_size_size(); i++) {
    target = ::google::protobuf::internal::WireFormat::WriteInt32ToArray(3, this->pre_compression_chunklet_size(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Chunk::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes compression_type = 1;
    if (has_compression_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::BytesSize(this->compression_type());
    }
    
  }
  // repeated bytes chunklet = 2;
  total_size += 1 * this->chunklet_size();
  for (int i = 0; i < this->chunklet_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormat::BytesSize(
      this->chunklet(i));
  }
  
  // repeated int32 pre_compression_chunklet_size = 3;
  {
    int data_size = 0;
    for (int i = 0; i < this->pre_compression_chunklet_size_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormat::Int32Size(
        this->pre_compression_chunklet_size(i));
    }
    total_size += 1 * this->pre_compression_chunklet_size_size() + data_size;
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void Chunk::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Chunk* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Chunk*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Chunk::MergeFrom(const Chunk& from) {
  GOOGLE_CHECK_NE(&from, this);
  chunklet_.MergeFrom(from.chunklet_);
  pre_compression_chunklet_size_.MergeFrom(from.pre_compression_chunklet_size_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_compression_type(from.compression_type());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Chunk::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Chunk::CopyFrom(const Chunk& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Chunk::Swap(Chunk* other) {
  if (other != this) {
    std::swap(compression_type_, other->compression_type_);
    chunklet_.Swap(&other->chunklet_);
    pre_compression_chunklet_size_.Swap(&other->pre_compression_chunklet_size_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

bool Chunk::IsInitialized() const {
  
  return true;
}

const ::google::protobuf::Descriptor* Chunk::GetDescriptor() const {
  return descriptor();
}

const ::google::protobuf::Reflection* Chunk::GetReflection() const {
  protobuf_AssignDescriptorsOnce();
  return Chunk_reflection_;
}

// ===================================================================

const ::std::string DataAtlas::_default_root_db_key_;
#ifndef _MSC_VER
const int DataAtlas::kRootDbKeyFieldNumber;
const int DataAtlas::kKeysFieldNumber;
const int DataAtlas::kMdmsFieldNumber;
const int DataAtlas::kDmsFieldNumber;
#endif  // !_MSC_VER

DataAtlas::DataAtlas()
  : ::google::protobuf::Message(),
    _unknown_fields_(),
    _cached_size_(0),
    root_db_key_(const_cast< ::std::string*>(&_default_root_db_key_)),
    keys_(),
    mdms_(),
    dms_() {
  SharedCtor();
}

void DataAtlas::InitAsDefaultInstance() {}

DataAtlas::DataAtlas(const DataAtlas& from)
  : ::google::protobuf::Message(),
    _unknown_fields_(),
    _cached_size_(0),
    root_db_key_(const_cast< ::std::string*>(&_default_root_db_key_)),
    keys_(),
    mdms_(),
    dms_() {
  SharedCtor();
  MergeFrom(from);
}

void DataAtlas::SharedCtor() {
  _cached_size_ = 0;
  root_db_key_ = const_cast< ::std::string*>(&_default_root_db_key_);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DataAtlas::~DataAtlas() {
  SharedDtor();
}

void DataAtlas::SharedDtor() {
  if (root_db_key_ != &_default_root_db_key_) {
    delete root_db_key_;
  }
  if (this != default_instance_) {
  }
}

const ::google::protobuf::Descriptor* DataAtlas::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DataAtlas_descriptor_;
}

const DataAtlas& DataAtlas::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_datamaps_2eproto();  return *default_instance_;
}

DataAtlas* DataAtlas::default_instance_ = NULL;

DataAtlas* DataAtlas::New() const {
  return new DataAtlas;
}

void DataAtlas::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (root_db_key_ != &_default_root_db_key_) {
        root_db_key_->clear();
      }
    }
  }
  keys_.Clear();
  mdms_.Clear();
  dms_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool DataAtlas::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormat::GetTagFieldNumber(tag)) {
      // optional bytes root_db_key = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormat::ReadBytes(input, mutable_root_db_key()));
        if (input->ExpectTag(18)) goto parse_keys;
        break;
      }
      
      // repeated .maidsafe.Key keys = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_keys:
        DO_(::google::protobuf::internal::WireFormat::ReadMessageNoVirtual(
             input, add_keys()));
        if (input->ExpectTag(18)) goto parse_keys;
        if (input->ExpectTag(26)) goto parse_mdms;
        break;
      }
      
      // repeated .maidsafe.MetaDataMap mdms = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_mdms:
        DO_(::google::protobuf::internal::WireFormat::ReadMessageNoVirtual(
             input, add_mdms()));
        if (input->ExpectTag(26)) goto parse_mdms;
        if (input->ExpectTag(34)) goto parse_dms;
        break;
      }
      
      // repeated .maidsafe.DataMap dms = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_dms:
        DO_(::google::protobuf::internal::WireFormat::ReadMessageNoVirtual(
             input, add_dms()));
        if (input->ExpectTag(34)) goto parse_dms;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormat::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DataAtlas::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    DataAtlas::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // optional bytes root_db_key = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::WriteBytes(1, this->root_db_key(), output);
  }
  
  // repeated .maidsafe.Key keys = 2;
  for (int i = 0; i < this->keys_size(); i++) {
    ::google::protobuf::internal::WireFormat::WriteMessageNoVirtual(2, this->keys(i), output);
  }
  
  // repeated .maidsafe.MetaDataMap mdms = 3;
  for (int i = 0; i < this->mdms_size(); i++) {
    ::google::protobuf::internal::WireFormat::WriteMessageNoVirtual(3, this->mdms(i), output);
  }
  
  // repeated .maidsafe.DataMap dms = 4;
  for (int i = 0; i < this->dms_size(); i++) {
    ::google::protobuf::internal::WireFormat::WriteMessageNoVirtual(4, this->dms(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* DataAtlas::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional bytes root_db_key = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormat::WriteBytesToArray(1, this->root_db_key(), target);
  }
  
  // repeated .maidsafe.Key keys = 2;
  for (int i = 0; i < this->keys_size(); i++) {
    target = ::google::protobuf::internal::WireFormat::WriteMessageNoVirtualToArray(2, this->keys(i), target);
  }
  
  // repeated .maidsafe.MetaDataMap mdms = 3;
  for (int i = 0; i < this->mdms_size(); i++) {
    target = ::google::protobuf::internal::WireFormat::WriteMessageNoVirtualToArray(3, this->mdms(i), target);
  }
  
  // repeated .maidsafe.DataMap dms = 4;
  for (int i = 0; i < this->dms_size(); i++) {
    target = ::google::protobuf::internal::WireFormat::WriteMessageNoVirtualToArray(4, this->dms(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int DataAtlas::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes root_db_key = 1;
    if (has_root_db_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::BytesSize(this->root_db_key());
    }
    
  }
  // repeated .maidsafe.Key keys = 2;
  total_size += 1 * this->keys_size();
  for (int i = 0; i < this->keys_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormat::MessageSizeNoVirtual(
        this->keys(i));
  }
  
  // repeated .maidsafe.MetaDataMap mdms = 3;
  total_size += 1 * this->mdms_size();
  for (int i = 0; i < this->mdms_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormat::MessageSizeNoVirtual(
        this->mdms(i));
  }
  
  // repeated .maidsafe.DataMap dms = 4;
  total_size += 1 * this->dms_size();
  for (int i = 0; i < this->dms_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormat::MessageSizeNoVirtual(
        this->dms(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void DataAtlas::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const DataAtlas* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const DataAtlas*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DataAtlas::MergeFrom(const DataAtlas& from) {
  GOOGLE_CHECK_NE(&from, this);
  keys_.MergeFrom(from.keys_);
  mdms_.MergeFrom(from.mdms_);
  dms_.MergeFrom(from.dms_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_root_db_key(from.root_db_key());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void DataAtlas::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DataAtlas::CopyFrom(const DataAtlas& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DataAtlas::Swap(DataAtlas* other) {
  if (other != this) {
    std::swap(root_db_key_, other->root_db_key_);
    keys_.Swap(&other->keys_);
    mdms_.Swap(&other->mdms_);
    dms_.Swap(&other->dms_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

bool DataAtlas::IsInitialized() const {
  
  for (int i = 0; i < keys_size(); i++) {
    if (!this->keys(i).IsInitialized()) return false;
  }
  for (int i = 0; i < mdms_size(); i++) {
    if (!this->mdms(i).IsInitialized()) return false;
  }
  for (int i = 0; i < dms_size(); i++) {
    if (!this->dms(i).IsInitialized()) return false;
  }
  return true;
}

const ::google::protobuf::Descriptor* DataAtlas::GetDescriptor() const {
  return descriptor();
}

const ::google::protobuf::Reflection* DataAtlas::GetReflection() const {
  protobuf_AssignDescriptorsOnce();
  return DataAtlas_reflection_;
}

}  // namespace maidsafe
