// Generated by the protocol buffer compiler.  DO NOT EDIT!

#include "datamaps.pb.h"
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format_inl.h>

namespace maidsafe {

namespace {

const ::google::protobuf::Descriptor* PublicContact_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PublicContact_reflection_ = NULL;
const ::google::protobuf::Descriptor* ShareParticipant_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ShareParticipant_reflection_ = NULL;
const ::google::protobuf::Descriptor* Share_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Share_reflection_ = NULL;
const ::google::protobuf::Descriptor* Key_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Key_reflection_ = NULL;
const ::google::protobuf::Descriptor* DataMap_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DataMap_reflection_ = NULL;
const ::google::protobuf::Descriptor* MetaDataMap_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MetaDataMap_reflection_ = NULL;
const ::google::protobuf::Descriptor* Chunk_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Chunk_reflection_ = NULL;
const ::google::protobuf::Descriptor* DataAtlas_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DataAtlas_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* ItemType_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_datamaps_2eproto() {
  protobuf_AddDesc_datamaps_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "datamaps.proto");
  GOOGLE_CHECK(file != NULL);
  PublicContact_descriptor_ = file->message_type(0);
  static const int PublicContact_offsets_[12] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PublicContact, pub_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PublicContact, pub_key_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PublicContact, full_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PublicContact, office_phone_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PublicContact, birthday_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PublicContact, gender_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PublicContact, language_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PublicContact, country_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PublicContact, city_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PublicContact, confirmed_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PublicContact, rank_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PublicContact, last_contact_),
  };
  PublicContact_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PublicContact_descriptor_,
      PublicContact::default_instance_,
      PublicContact_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PublicContact, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PublicContact, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PublicContact));
  ShareParticipant_descriptor_ = file->message_type(1);
  static const int ShareParticipant_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShareParticipant, public_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShareParticipant, public_name_pub_key_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShareParticipant, role_),
  };
  ShareParticipant_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ShareParticipant_descriptor_,
      ShareParticipant::default_instance_,
      ShareParticipant_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShareParticipant, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ShareParticipant, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ShareParticipant));
  Share_descriptor_ = file->message_type(2);
  static const int Share_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Share, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Share, msid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Share, msid_pub_key_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Share, msid_pri_key_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Share, participants_),
  };
  Share_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Share_descriptor_,
      Share::default_instance_,
      Share_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Share, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Share, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Share));
  Key_descriptor_ = file->message_type(3);
  static const int Key_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Key, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Key, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Key, private_key_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Key, public_key_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Key, public_key_signature_),
  };
  Key_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Key_descriptor_,
      Key::default_instance_,
      Key_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Key, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Key, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Key));
  DataMap_descriptor_ = file->message_type(4);
  static const int DataMap_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataMap, file_hash_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataMap, se_version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataMap, chunk_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataMap, encrypted_chunk_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataMap, chunk_size_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataMap, compression_on_),
  };
  DataMap_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      DataMap_descriptor_,
      DataMap::default_instance_,
      DataMap_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataMap, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataMap, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(DataMap));
  MetaDataMap_descriptor_ = file->message_type(5);
  static const int MetaDataMap_offsets_[11] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MetaDataMap, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MetaDataMap, display_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MetaDataMap, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MetaDataMap, file_hash_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MetaDataMap, stats_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MetaDataMap, tag_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MetaDataMap, file_size_high_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MetaDataMap, file_size_low_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MetaDataMap, creation_time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MetaDataMap, last_modified_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MetaDataMap, last_access_),
  };
  MetaDataMap_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MetaDataMap_descriptor_,
      MetaDataMap::default_instance_,
      MetaDataMap_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MetaDataMap, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MetaDataMap, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MetaDataMap));
  Chunk_descriptor_ = file->message_type(6);
  static const int Chunk_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Chunk, compression_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Chunk, chunklet_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Chunk, pre_compression_chunklet_size_),
  };
  Chunk_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Chunk_descriptor_,
      Chunk::default_instance_,
      Chunk_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Chunk, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Chunk, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Chunk));
  DataAtlas_descriptor_ = file->message_type(7);
  static const int DataAtlas_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataAtlas, root_db_key_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataAtlas, keys_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataAtlas, mdms_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataAtlas, dms_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataAtlas, contacts_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataAtlas, shares_),
  };
  DataAtlas_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      DataAtlas_descriptor_,
      DataAtlas::default_instance_,
      DataAtlas_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataAtlas, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DataAtlas, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(DataAtlas));
  ItemType_descriptor_ = file->enum_type(0);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_datamaps_2eproto);
}

void protobuf_RegisterTypes() {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PublicContact_descriptor_, &PublicContact::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ShareParticipant_descriptor_, &ShareParticipant::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Share_descriptor_, &Share::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Key_descriptor_, &Key::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    DataMap_descriptor_, &DataMap::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MetaDataMap_descriptor_, &MetaDataMap::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Chunk_descriptor_, &Chunk::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    DataAtlas_descriptor_, &DataAtlas::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_datamaps_2eproto() {
  delete PublicContact::default_instance_;
  delete PublicContact_reflection_;
  delete ShareParticipant::default_instance_;
  delete ShareParticipant_reflection_;
  delete Share::default_instance_;
  delete Share_reflection_;
  delete Key::default_instance_;
  delete Key_reflection_;
  delete DataMap::default_instance_;
  delete DataMap_reflection_;
  delete MetaDataMap::default_instance_;
  delete MetaDataMap_reflection_;
  delete Chunk::default_instance_;
  delete Chunk_reflection_;
  delete DataAtlas::default_instance_;
  delete DataAtlas_reflection_;
}

void protobuf_AddDesc_datamaps_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::maidsafe::protobuf_AddDesc_packet_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\016datamaps.proto\022\010maidsafe\032\014packet.proto"
    "\"\345\001\n\rPublicContact\022\020\n\010pub_name\030\001 \002(\014\022\017\n\007"
    "pub_key\030\002 \002(\014\022\021\n\tfull_name\030\003 \002(\014\022\024\n\014offi"
    "ce_phone\030\004 \002(\014\022\020\n\010birthday\030\005 \002(\014\022\016\n\006gend"
    "er\030\006 \002(\014\022\020\n\010language\030\007 \002(\005\022\017\n\007country\030\010 "
    "\002(\005\022\014\n\004city\030\t \002(\014\022\021\n\tconfirmed\030\n \002(\014\022\014\n\004"
    "rank\030\013 \002(\005\022\024\n\014last_contact\030\014 \002(\005\"R\n\020Shar"
    "eParticipant\022\023\n\013public_name\030\001 \002(\014\022\033\n\023pub"
    "lic_name_pub_key\030\002 \001(\014\022\014\n\004role\030\003 \002(\014\"\201\001\n"
    "\005Share\022\014\n\004name\030\001 \002(\014\022\014\n\004msid\030\002 \002(\014\022\024\n\014ms"
    "id_pub_key\030\003 \002(\014\022\024\n\014msid_pri_key\030\004 \001(\014\0220"
    "\n\014participants\030\005 \003(\0132\032.maidsafe.SharePar"
    "ticipant\"|\n\003Key\022\n\n\002id\030\001 \002(\014\022\"\n\004type\030\002 \002("
    "\0162\024.maidsafe.PacketType\022\023\n\013private_key\030\003"
    " \002(\014\022\022\n\npublic_key\030\004 \002(\014\022\034\n\024public_key_s"
    "ignature\030\005 \002(\014\"\225\001\n\007DataMap\022\021\n\tfile_hash\030"
    "\001 \002(\014\022\022\n\nse_version\030\002 \001(\014\022\022\n\nchunk_name\030"
    "\003 \003(\014\022\034\n\024encrypted_chunk_name\030\004 \003(\014\022\022\n\nc"
    "hunk_size\030\005 \003(\004\022\035\n\016compression_on\030\006 \001(\010:"
    "\005false\"\362\001\n\013MetaDataMap\022\n\n\002id\030\001 \002(\005\022\024\n\014di"
    "splay_name\030\002 \002(\014\022 \n\004type\030\003 \002(\0162\022.maidsaf"
    "e.ItemType\022\021\n\tfile_hash\030\004 \003(\014\022\r\n\005stats\030\005"
    " \001(\014\022\013\n\003tag\030\006 \001(\014\022\026\n\016file_size_high\030\007 \001("
    "\005\022\025\n\rfile_size_low\030\010 \001(\005\022\025\n\rcreation_tim"
    "e\030\t \001(\005\022\025\n\rlast_modified\030\n \001(\005\022\023\n\013last_a"
    "ccess\030\013 \001(\005\"Z\n\005Chunk\022\030\n\020compression_type"
    "\030\001 \001(\014\022\020\n\010chunklet\030\002 \003(\014\022%\n\035pre_compress"
    "ion_chunklet_size\030\003 \003(\005\"\316\001\n\tDataAtlas\022\023\n"
    "\013root_db_key\030\001 \001(\014\022\033\n\004keys\030\002 \003(\0132\r.maids"
    "afe.Key\022#\n\004mdms\030\003 \003(\0132\025.maidsafe.MetaDat"
    "aMap\022\036\n\003dms\030\004 \003(\0132\021.maidsafe.DataMap\022)\n\010"
    "contacts\030\005 \003(\0132\027.maidsafe.PublicContact\022"
    "\037\n\006shares\030\006 \003(\0132\017.maidsafe.Share*\240\001\n\010Ite"
    "mType\022\020\n\014REGULAR_FILE\020\000\022\016\n\nSMALL_FILE\020\001\022"
    "\016\n\nEMPTY_FILE\020\002\022\017\n\013LOCKED_FILE\020\003\022\r\n\tDIRE"
    "CTORY\020\004\022\023\n\017EMPTY_DIRECTORY\020\005\022\010\n\004LINK\020\006\022\026"
    "\n\022NOT_FOR_PROCESSING\020\007\022\013\n\007UNKNOWN\020\010", 1475);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "datamaps.proto", &protobuf_RegisterTypes);
  PublicContact::default_instance_ = new PublicContact();
  ShareParticipant::default_instance_ = new ShareParticipant();
  Share::default_instance_ = new Share();
  Key::default_instance_ = new Key();
  DataMap::default_instance_ = new DataMap();
  MetaDataMap::default_instance_ = new MetaDataMap();
  Chunk::default_instance_ = new Chunk();
  DataAtlas::default_instance_ = new DataAtlas();
  PublicContact::default_instance_->InitAsDefaultInstance();
  ShareParticipant::default_instance_->InitAsDefaultInstance();
  Share::default_instance_->InitAsDefaultInstance();
  Key::default_instance_->InitAsDefaultInstance();
  DataMap::default_instance_->InitAsDefaultInstance();
  MetaDataMap::default_instance_->InitAsDefaultInstance();
  Chunk::default_instance_->InitAsDefaultInstance();
  DataAtlas::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_datamaps_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_datamaps_2eproto {
  StaticDescriptorInitializer_datamaps_2eproto() {
    protobuf_AddDesc_datamaps_2eproto();
  }
} static_descriptor_initializer_datamaps_2eproto_;

const ::google::protobuf::EnumDescriptor* ItemType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ItemType_descriptor_;
}
bool ItemType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}


// ===================================================================

const ::std::string PublicContact::_default_pub_name_;
const ::std::string PublicContact::_default_pub_key_;
const ::std::string PublicContact::_default_full_name_;
const ::std::string PublicContact::_default_office_phone_;
const ::std::string PublicContact::_default_birthday_;
const ::std::string PublicContact::_default_gender_;
const ::std::string PublicContact::_default_city_;
const ::std::string PublicContact::_default_confirmed_;
#ifndef _MSC_VER
const int PublicContact::kPubNameFieldNumber;
const int PublicContact::kPubKeyFieldNumber;
const int PublicContact::kFullNameFieldNumber;
const int PublicContact::kOfficePhoneFieldNumber;
const int PublicContact::kBirthdayFieldNumber;
const int PublicContact::kGenderFieldNumber;
const int PublicContact::kLanguageFieldNumber;
const int PublicContact::kCountryFieldNumber;
const int PublicContact::kCityFieldNumber;
const int PublicContact::kConfirmedFieldNumber;
const int PublicContact::kRankFieldNumber;
const int PublicContact::kLastContactFieldNumber;
#endif  // !_MSC_VER

PublicContact::PublicContact()
  : ::google::protobuf::Message(),
    _unknown_fields_(),
    _cached_size_(0),
    pub_name_(const_cast< ::std::string*>(&_default_pub_name_)),
    pub_key_(const_cast< ::std::string*>(&_default_pub_key_)),
    full_name_(const_cast< ::std::string*>(&_default_full_name_)),
    office_phone_(const_cast< ::std::string*>(&_default_office_phone_)),
    birthday_(const_cast< ::std::string*>(&_default_birthday_)),
    gender_(const_cast< ::std::string*>(&_default_gender_)),
    language_(0),
    country_(0),
    city_(const_cast< ::std::string*>(&_default_city_)),
    confirmed_(const_cast< ::std::string*>(&_default_confirmed_)),
    rank_(0),
    last_contact_(0) {
  SharedCtor();
}

void PublicContact::InitAsDefaultInstance() {}

PublicContact::PublicContact(const PublicContact& from)
  : ::google::protobuf::Message(),
    _unknown_fields_(),
    _cached_size_(0),
    pub_name_(const_cast< ::std::string*>(&_default_pub_name_)),
    pub_key_(const_cast< ::std::string*>(&_default_pub_key_)),
    full_name_(const_cast< ::std::string*>(&_default_full_name_)),
    office_phone_(const_cast< ::std::string*>(&_default_office_phone_)),
    birthday_(const_cast< ::std::string*>(&_default_birthday_)),
    gender_(const_cast< ::std::string*>(&_default_gender_)),
    language_(0),
    country_(0),
    city_(const_cast< ::std::string*>(&_default_city_)),
    confirmed_(const_cast< ::std::string*>(&_default_confirmed_)),
    rank_(0),
    last_contact_(0) {
  SharedCtor();
  MergeFrom(from);
}

void PublicContact::SharedCtor() {
  _cached_size_ = 0;
  pub_name_ = const_cast< ::std::string*>(&_default_pub_name_);
  pub_key_ = const_cast< ::std::string*>(&_default_pub_key_);
  full_name_ = const_cast< ::std::string*>(&_default_full_name_);
  office_phone_ = const_cast< ::std::string*>(&_default_office_phone_);
  birthday_ = const_cast< ::std::string*>(&_default_birthday_);
  gender_ = const_cast< ::std::string*>(&_default_gender_);
  language_ = 0;
  country_ = 0;
  city_ = const_cast< ::std::string*>(&_default_city_);
  confirmed_ = const_cast< ::std::string*>(&_default_confirmed_);
  rank_ = 0;
  last_contact_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PublicContact::~PublicContact() {
  SharedDtor();
}

void PublicContact::SharedDtor() {
  if (pub_name_ != &_default_pub_name_) {
    delete pub_name_;
  }
  if (pub_key_ != &_default_pub_key_) {
    delete pub_key_;
  }
  if (full_name_ != &_default_full_name_) {
    delete full_name_;
  }
  if (office_phone_ != &_default_office_phone_) {
    delete office_phone_;
  }
  if (birthday_ != &_default_birthday_) {
    delete birthday_;
  }
  if (gender_ != &_default_gender_) {
    delete gender_;
  }
  if (city_ != &_default_city_) {
    delete city_;
  }
  if (confirmed_ != &_default_confirmed_) {
    delete confirmed_;
  }
  if (this != default_instance_) {
  }
}

const ::google::protobuf::Descriptor* PublicContact::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PublicContact_descriptor_;
}

const PublicContact& PublicContact::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_datamaps_2eproto();  return *default_instance_;
}

PublicContact* PublicContact::default_instance_ = NULL;

PublicContact* PublicContact::New() const {
  return new PublicContact;
}

void PublicContact::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (pub_name_ != &_default_pub_name_) {
        pub_name_->clear();
      }
    }
    if (_has_bit(1)) {
      if (pub_key_ != &_default_pub_key_) {
        pub_key_->clear();
      }
    }
    if (_has_bit(2)) {
      if (full_name_ != &_default_full_name_) {
        full_name_->clear();
      }
    }
    if (_has_bit(3)) {
      if (office_phone_ != &_default_office_phone_) {
        office_phone_->clear();
      }
    }
    if (_has_bit(4)) {
      if (birthday_ != &_default_birthday_) {
        birthday_->clear();
      }
    }
    if (_has_bit(5)) {
      if (gender_ != &_default_gender_) {
        gender_->clear();
      }
    }
    language_ = 0;
    country_ = 0;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (_has_bit(8)) {
      if (city_ != &_default_city_) {
        city_->clear();
      }
    }
    if (_has_bit(9)) {
      if (confirmed_ != &_default_confirmed_) {
        confirmed_->clear();
      }
    }
    rank_ = 0;
    last_contact_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PublicContact::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormat::GetTagFieldNumber(tag)) {
      // required bytes pub_name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormat::ReadBytes(input, mutable_pub_name()));
        if (input->ExpectTag(18)) goto parse_pub_key;
        break;
      }
      
      // required bytes pub_key = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_pub_key:
        DO_(::google::protobuf::internal::WireFormat::ReadBytes(input, mutable_pub_key()));
        if (input->ExpectTag(26)) goto parse_full_name;
        break;
      }
      
      // required bytes full_name = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_full_name:
        DO_(::google::protobuf::internal::WireFormat::ReadBytes(input, mutable_full_name()));
        if (input->ExpectTag(34)) goto parse_office_phone;
        break;
      }
      
      // required bytes office_phone = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_office_phone:
        DO_(::google::protobuf::internal::WireFormat::ReadBytes(input, mutable_office_phone()));
        if (input->ExpectTag(42)) goto parse_birthday;
        break;
      }
      
      // required bytes birthday = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_birthday:
        DO_(::google::protobuf::internal::WireFormat::ReadBytes(input, mutable_birthday()));
        if (input->ExpectTag(50)) goto parse_gender;
        break;
      }
      
      // required bytes gender = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_gender:
        DO_(::google::protobuf::internal::WireFormat::ReadBytes(input, mutable_gender()));
        if (input->ExpectTag(56)) goto parse_language;
        break;
      }
      
      // required int32 language = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_language:
        DO_(::google::protobuf::internal::WireFormat::ReadInt32(
              input, &language_));
        _set_bit(6);
        if (input->ExpectTag(64)) goto parse_country;
        break;
      }
      
      // required int32 country = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_country:
        DO_(::google::protobuf::internal::WireFormat::ReadInt32(
              input, &country_));
        _set_bit(7);
        if (input->ExpectTag(74)) goto parse_city;
        break;
      }
      
      // required bytes city = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_city:
        DO_(::google::protobuf::internal::WireFormat::ReadBytes(input, mutable_city()));
        if (input->ExpectTag(82)) goto parse_confirmed;
        break;
      }
      
      // required bytes confirmed = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_confirmed:
        DO_(::google::protobuf::internal::WireFormat::ReadBytes(input, mutable_confirmed()));
        if (input->ExpectTag(88)) goto parse_rank;
        break;
      }
      
      // required int32 rank = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_rank:
        DO_(::google::protobuf::internal::WireFormat::ReadInt32(
              input, &rank_));
        _set_bit(10);
        if (input->ExpectTag(96)) goto parse_last_contact;
        break;
      }
      
      // required int32 last_contact = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_last_contact:
        DO_(::google::protobuf::internal::WireFormat::ReadInt32(
              input, &last_contact_));
        _set_bit(11);
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormat::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PublicContact::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    PublicContact::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // required bytes pub_name = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::WriteBytes(1, this->pub_name(), output);
  }
  
  // required bytes pub_key = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::WriteBytes(2, this->pub_key(), output);
  }
  
  // required bytes full_name = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormat::WriteBytes(3, this->full_name(), output);
  }
  
  // required bytes office_phone = 4;
  if (_has_bit(3)) {
    ::google::protobuf::internal::WireFormat::WriteBytes(4, this->office_phone(), output);
  }
  
  // required bytes birthday = 5;
  if (_has_bit(4)) {
    ::google::protobuf::internal::WireFormat::WriteBytes(5, this->birthday(), output);
  }
  
  // required bytes gender = 6;
  if (_has_bit(5)) {
    ::google::protobuf::internal::WireFormat::WriteBytes(6, this->gender(), output);
  }
  
  // required int32 language = 7;
  if (_has_bit(6)) {
    ::google::protobuf::internal::WireFormat::WriteInt32(7, this->language(), output);
  }
  
  // required int32 country = 8;
  if (_has_bit(7)) {
    ::google::protobuf::internal::WireFormat::WriteInt32(8, this->country(), output);
  }
  
  // required bytes city = 9;
  if (_has_bit(8)) {
    ::google::protobuf::internal::WireFormat::WriteBytes(9, this->city(), output);
  }
  
  // required bytes confirmed = 10;
  if (_has_bit(9)) {
    ::google::protobuf::internal::WireFormat::WriteBytes(10, this->confirmed(), output);
  }
  
  // required int32 rank = 11;
  if (_has_bit(10)) {
    ::google::protobuf::internal::WireFormat::WriteInt32(11, this->rank(), output);
  }
  
  // required int32 last_contact = 12;
  if (_has_bit(11)) {
    ::google::protobuf::internal::WireFormat::WriteInt32(12, this->last_contact(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* PublicContact::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required bytes pub_name = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormat::WriteBytesToArray(1, this->pub_name(), target);
  }
  
  // required bytes pub_key = 2;
  if (_has_bit(1)) {
    target = ::google::protobuf::internal::WireFormat::WriteBytesToArray(2, this->pub_key(), target);
  }
  
  // required bytes full_name = 3;
  if (_has_bit(2)) {
    target = ::google::protobuf::internal::WireFormat::WriteBytesToArray(3, this->full_name(), target);
  }
  
  // required bytes office_phone = 4;
  if (_has_bit(3)) {
    target = ::google::protobuf::internal::WireFormat::WriteBytesToArray(4, this->office_phone(), target);
  }
  
  // required bytes birthday = 5;
  if (_has_bit(4)) {
    target = ::google::protobuf::internal::WireFormat::WriteBytesToArray(5, this->birthday(), target);
  }
  
  // required bytes gender = 6;
  if (_has_bit(5)) {
    target = ::google::protobuf::internal::WireFormat::WriteBytesToArray(6, this->gender(), target);
  }
  
  // required int32 language = 7;
  if (_has_bit(6)) {
    target = ::google::protobuf::internal::WireFormat::WriteInt32ToArray(7, this->language(), target);
  }
  
  // required int32 country = 8;
  if (_has_bit(7)) {
    target = ::google::protobuf::internal::WireFormat::WriteInt32ToArray(8, this->country(), target);
  }
  
  // required bytes city = 9;
  if (_has_bit(8)) {
    target = ::google::protobuf::internal::WireFormat::WriteBytesToArray(9, this->city(), target);
  }
  
  // required bytes confirmed = 10;
  if (_has_bit(9)) {
    target = ::google::protobuf::internal::WireFormat::WriteBytesToArray(10, this->confirmed(), target);
  }
  
  // required int32 rank = 11;
  if (_has_bit(10)) {
    target = ::google::protobuf::internal::WireFormat::WriteInt32ToArray(11, this->rank(), target);
  }
  
  // required int32 last_contact = 12;
  if (_has_bit(11)) {
    target = ::google::protobuf::internal::WireFormat::WriteInt32ToArray(12, this->last_contact(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int PublicContact::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes pub_name = 1;
    if (has_pub_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::BytesSize(this->pub_name());
    }
    
    // required bytes pub_key = 2;
    if (has_pub_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::BytesSize(this->pub_key());
    }
    
    // required bytes full_name = 3;
    if (has_full_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::BytesSize(this->full_name());
    }
    
    // required bytes office_phone = 4;
    if (has_office_phone()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::BytesSize(this->office_phone());
    }
    
    // required bytes birthday = 5;
    if (has_birthday()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::BytesSize(this->birthday());
    }
    
    // required bytes gender = 6;
    if (has_gender()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::BytesSize(this->gender());
    }
    
    // required int32 language = 7;
    if (has_language()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::Int32Size(
          this->language());
    }
    
    // required int32 country = 8;
    if (has_country()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::Int32Size(
          this->country());
    }
    
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // required bytes city = 9;
    if (has_city()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::BytesSize(this->city());
    }
    
    // required bytes confirmed = 10;
    if (has_confirmed()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::BytesSize(this->confirmed());
    }
    
    // required int32 rank = 11;
    if (has_rank()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::Int32Size(
          this->rank());
    }
    
    // required int32 last_contact = 12;
    if (has_last_contact()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::Int32Size(
          this->last_contact());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void PublicContact::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PublicContact* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PublicContact*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PublicContact::MergeFrom(const PublicContact& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_pub_name(from.pub_name());
    }
    if (from._has_bit(1)) {
      set_pub_key(from.pub_key());
    }
    if (from._has_bit(2)) {
      set_full_name(from.full_name());
    }
    if (from._has_bit(3)) {
      set_office_phone(from.office_phone());
    }
    if (from._has_bit(4)) {
      set_birthday(from.birthday());
    }
    if (from._has_bit(5)) {
      set_gender(from.gender());
    }
    if (from._has_bit(6)) {
      set_language(from.language());
    }
    if (from._has_bit(7)) {
      set_country(from.country());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from._has_bit(8)) {
      set_city(from.city());
    }
    if (from._has_bit(9)) {
      set_confirmed(from.confirmed());
    }
    if (from._has_bit(10)) {
      set_rank(from.rank());
    }
    if (from._has_bit(11)) {
      set_last_contact(from.last_contact());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PublicContact::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PublicContact::CopyFrom(const PublicContact& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PublicContact::Swap(PublicContact* other) {
  if (other != this) {
    std::swap(pub_name_, other->pub_name_);
    std::swap(pub_key_, other->pub_key_);
    std::swap(full_name_, other->full_name_);
    std::swap(office_phone_, other->office_phone_);
    std::swap(birthday_, other->birthday_);
    std::swap(gender_, other->gender_);
    std::swap(language_, other->language_);
    std::swap(country_, other->country_);
    std::swap(city_, other->city_);
    std::swap(confirmed_, other->confirmed_);
    std::swap(rank_, other->rank_);
    std::swap(last_contact_, other->last_contact_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

bool PublicContact::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000fff) != 0x00000fff) return false;
  
  return true;
}

const ::google::protobuf::Descriptor* PublicContact::GetDescriptor() const {
  return descriptor();
}

const ::google::protobuf::Reflection* PublicContact::GetReflection() const {
  protobuf_AssignDescriptorsOnce();
  return PublicContact_reflection_;
}

// ===================================================================

const ::std::string ShareParticipant::_default_public_name_;
const ::std::string ShareParticipant::_default_public_name_pub_key_;
const ::std::string ShareParticipant::_default_role_;
#ifndef _MSC_VER
const int ShareParticipant::kPublicNameFieldNumber;
const int ShareParticipant::kPublicNamePubKeyFieldNumber;
const int ShareParticipant::kRoleFieldNumber;
#endif  // !_MSC_VER

ShareParticipant::ShareParticipant()
  : ::google::protobuf::Message(),
    _unknown_fields_(),
    _cached_size_(0),
    public_name_(const_cast< ::std::string*>(&_default_public_name_)),
    public_name_pub_key_(const_cast< ::std::string*>(&_default_public_name_pub_key_)),
    role_(const_cast< ::std::string*>(&_default_role_)) {
  SharedCtor();
}

void ShareParticipant::InitAsDefaultInstance() {}

ShareParticipant::ShareParticipant(const ShareParticipant& from)
  : ::google::protobuf::Message(),
    _unknown_fields_(),
    _cached_size_(0),
    public_name_(const_cast< ::std::string*>(&_default_public_name_)),
    public_name_pub_key_(const_cast< ::std::string*>(&_default_public_name_pub_key_)),
    role_(const_cast< ::std::string*>(&_default_role_)) {
  SharedCtor();
  MergeFrom(from);
}

void ShareParticipant::SharedCtor() {
  _cached_size_ = 0;
  public_name_ = const_cast< ::std::string*>(&_default_public_name_);
  public_name_pub_key_ = const_cast< ::std::string*>(&_default_public_name_pub_key_);
  role_ = const_cast< ::std::string*>(&_default_role_);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ShareParticipant::~ShareParticipant() {
  SharedDtor();
}

void ShareParticipant::SharedDtor() {
  if (public_name_ != &_default_public_name_) {
    delete public_name_;
  }
  if (public_name_pub_key_ != &_default_public_name_pub_key_) {
    delete public_name_pub_key_;
  }
  if (role_ != &_default_role_) {
    delete role_;
  }
  if (this != default_instance_) {
  }
}

const ::google::protobuf::Descriptor* ShareParticipant::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ShareParticipant_descriptor_;
}

const ShareParticipant& ShareParticipant::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_datamaps_2eproto();  return *default_instance_;
}

ShareParticipant* ShareParticipant::default_instance_ = NULL;

ShareParticipant* ShareParticipant::New() const {
  return new ShareParticipant;
}

void ShareParticipant::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (public_name_ != &_default_public_name_) {
        public_name_->clear();
      }
    }
    if (_has_bit(1)) {
      if (public_name_pub_key_ != &_default_public_name_pub_key_) {
        public_name_pub_key_->clear();
      }
    }
    if (_has_bit(2)) {
      if (role_ != &_default_role_) {
        role_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ShareParticipant::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormat::GetTagFieldNumber(tag)) {
      // required bytes public_name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormat::ReadBytes(input, mutable_public_name()));
        if (input->ExpectTag(18)) goto parse_public_name_pub_key;
        break;
      }
      
      // optional bytes public_name_pub_key = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_public_name_pub_key:
        DO_(::google::protobuf::internal::WireFormat::ReadBytes(input, mutable_public_name_pub_key()));
        if (input->ExpectTag(26)) goto parse_role;
        break;
      }
      
      // required bytes role = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_role:
        DO_(::google::protobuf::internal::WireFormat::ReadBytes(input, mutable_role()));
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormat::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ShareParticipant::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    ShareParticipant::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // required bytes public_name = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::WriteBytes(1, this->public_name(), output);
  }
  
  // optional bytes public_name_pub_key = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::WriteBytes(2, this->public_name_pub_key(), output);
  }
  
  // required bytes role = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormat::WriteBytes(3, this->role(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ShareParticipant::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required bytes public_name = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormat::WriteBytesToArray(1, this->public_name(), target);
  }
  
  // optional bytes public_name_pub_key = 2;
  if (_has_bit(1)) {
    target = ::google::protobuf::internal::WireFormat::WriteBytesToArray(2, this->public_name_pub_key(), target);
  }
  
  // required bytes role = 3;
  if (_has_bit(2)) {
    target = ::google::protobuf::internal::WireFormat::WriteBytesToArray(3, this->role(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ShareParticipant::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes public_name = 1;
    if (has_public_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::BytesSize(this->public_name());
    }
    
    // optional bytes public_name_pub_key = 2;
    if (has_public_name_pub_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::BytesSize(this->public_name_pub_key());
    }
    
    // required bytes role = 3;
    if (has_role()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::BytesSize(this->role());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void ShareParticipant::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ShareParticipant* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ShareParticipant*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ShareParticipant::MergeFrom(const ShareParticipant& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_public_name(from.public_name());
    }
    if (from._has_bit(1)) {
      set_public_name_pub_key(from.public_name_pub_key());
    }
    if (from._has_bit(2)) {
      set_role(from.role());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ShareParticipant::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ShareParticipant::CopyFrom(const ShareParticipant& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ShareParticipant::Swap(ShareParticipant* other) {
  if (other != this) {
    std::swap(public_name_, other->public_name_);
    std::swap(public_name_pub_key_, other->public_name_pub_key_);
    std::swap(role_, other->role_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

bool ShareParticipant::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000005) != 0x00000005) return false;
  
  return true;
}

const ::google::protobuf::Descriptor* ShareParticipant::GetDescriptor() const {
  return descriptor();
}

const ::google::protobuf::Reflection* ShareParticipant::GetReflection() const {
  protobuf_AssignDescriptorsOnce();
  return ShareParticipant_reflection_;
}

// ===================================================================

const ::std::string Share::_default_name_;
const ::std::string Share::_default_msid_;
const ::std::string Share::_default_msid_pub_key_;
const ::std::string Share::_default_msid_pri_key_;
#ifndef _MSC_VER
const int Share::kNameFieldNumber;
const int Share::kMsidFieldNumber;
const int Share::kMsidPubKeyFieldNumber;
const int Share::kMsidPriKeyFieldNumber;
const int Share::kParticipantsFieldNumber;
#endif  // !_MSC_VER

Share::Share()
  : ::google::protobuf::Message(),
    _unknown_fields_(),
    _cached_size_(0),
    name_(const_cast< ::std::string*>(&_default_name_)),
    msid_(const_cast< ::std::string*>(&_default_msid_)),
    msid_pub_key_(const_cast< ::std::string*>(&_default_msid_pub_key_)),
    msid_pri_key_(const_cast< ::std::string*>(&_default_msid_pri_key_)),
    participants_() {
  SharedCtor();
}

void Share::InitAsDefaultInstance() {}

Share::Share(const Share& from)
  : ::google::protobuf::Message(),
    _unknown_fields_(),
    _cached_size_(0),
    name_(const_cast< ::std::string*>(&_default_name_)),
    msid_(const_cast< ::std::string*>(&_default_msid_)),
    msid_pub_key_(const_cast< ::std::string*>(&_default_msid_pub_key_)),
    msid_pri_key_(const_cast< ::std::string*>(&_default_msid_pri_key_)),
    participants_() {
  SharedCtor();
  MergeFrom(from);
}

void Share::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&_default_name_);
  msid_ = const_cast< ::std::string*>(&_default_msid_);
  msid_pub_key_ = const_cast< ::std::string*>(&_default_msid_pub_key_);
  msid_pri_key_ = const_cast< ::std::string*>(&_default_msid_pri_key_);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Share::~Share() {
  SharedDtor();
}

void Share::SharedDtor() {
  if (name_ != &_default_name_) {
    delete name_;
  }
  if (msid_ != &_default_msid_) {
    delete msid_;
  }
  if (msid_pub_key_ != &_default_msid_pub_key_) {
    delete msid_pub_key_;
  }
  if (msid_pri_key_ != &_default_msid_pri_key_) {
    delete msid_pri_key_;
  }
  if (this != default_instance_) {
  }
}

const ::google::protobuf::Descriptor* Share::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Share_descriptor_;
}

const Share& Share::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_datamaps_2eproto();  return *default_instance_;
}

Share* Share::default_instance_ = NULL;

Share* Share::New() const {
  return new Share;
}

void Share::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (name_ != &_default_name_) {
        name_->clear();
      }
    }
    if (_has_bit(1)) {
      if (msid_ != &_default_msid_) {
        msid_->clear();
      }
    }
    if (_has_bit(2)) {
      if (msid_pub_key_ != &_default_msid_pub_key_) {
        msid_pub_key_->clear();
      }
    }
    if (_has_bit(3)) {
      if (msid_pri_key_ != &_default_msid_pri_key_) {
        msid_pri_key_->clear();
      }
    }
  }
  participants_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Share::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormat::GetTagFieldNumber(tag)) {
      // required bytes name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormat::ReadBytes(input, mutable_name()));
        if (input->ExpectTag(18)) goto parse_msid;
        break;
      }
      
      // required bytes msid = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_msid:
        DO_(::google::protobuf::internal::WireFormat::ReadBytes(input, mutable_msid()));
        if (input->ExpectTag(26)) goto parse_msid_pub_key;
        break;
      }
      
      // required bytes msid_pub_key = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_msid_pub_key:
        DO_(::google::protobuf::internal::WireFormat::ReadBytes(input, mutable_msid_pub_key()));
        if (input->ExpectTag(34)) goto parse_msid_pri_key;
        break;
      }
      
      // optional bytes msid_pri_key = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_msid_pri_key:
        DO_(::google::protobuf::internal::WireFormat::ReadBytes(input, mutable_msid_pri_key()));
        if (input->ExpectTag(42)) goto parse_participants;
        break;
      }
      
      // repeated .maidsafe.ShareParticipant participants = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_participants:
        DO_(::google::protobuf::internal::WireFormat::ReadMessageNoVirtual(
             input, add_participants()));
        if (input->ExpectTag(42)) goto parse_participants;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormat::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Share::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    Share::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // required bytes name = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::WriteBytes(1, this->name(), output);
  }
  
  // required bytes msid = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::WriteBytes(2, this->msid(), output);
  }
  
  // required bytes msid_pub_key = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormat::WriteBytes(3, this->msid_pub_key(), output);
  }
  
  // optional bytes msid_pri_key = 4;
  if (_has_bit(3)) {
    ::google::protobuf::internal::WireFormat::WriteBytes(4, this->msid_pri_key(), output);
  }
  
  // repeated .maidsafe.ShareParticipant participants = 5;
  for (int i = 0; i < this->participants_size(); i++) {
    ::google::protobuf::internal::WireFormat::WriteMessageNoVirtual(5, this->participants(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Share::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required bytes name = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormat::WriteBytesToArray(1, this->name(), target);
  }
  
  // required bytes msid = 2;
  if (_has_bit(1)) {
    target = ::google::protobuf::internal::WireFormat::WriteBytesToArray(2, this->msid(), target);
  }
  
  // required bytes msid_pub_key = 3;
  if (_has_bit(2)) {
    target = ::google::protobuf::internal::WireFormat::WriteBytesToArray(3, this->msid_pub_key(), target);
  }
  
  // optional bytes msid_pri_key = 4;
  if (_has_bit(3)) {
    target = ::google::protobuf::internal::WireFormat::WriteBytesToArray(4, this->msid_pri_key(), target);
  }
  
  // repeated .maidsafe.ShareParticipant participants = 5;
  for (int i = 0; i < this->participants_size(); i++) {
    target = ::google::protobuf::internal::WireFormat::WriteMessageNoVirtualToArray(5, this->participants(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Share::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::BytesSize(this->name());
    }
    
    // required bytes msid = 2;
    if (has_msid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::BytesSize(this->msid());
    }
    
    // required bytes msid_pub_key = 3;
    if (has_msid_pub_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::BytesSize(this->msid_pub_key());
    }
    
    // optional bytes msid_pri_key = 4;
    if (has_msid_pri_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::BytesSize(this->msid_pri_key());
    }
    
  }
  // repeated .maidsafe.ShareParticipant participants = 5;
  total_size += 1 * this->participants_size();
  for (int i = 0; i < this->participants_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormat::MessageSizeNoVirtual(
        this->participants(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void Share::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Share* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Share*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Share::MergeFrom(const Share& from) {
  GOOGLE_CHECK_NE(&from, this);
  participants_.MergeFrom(from.participants_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_name(from.name());
    }
    if (from._has_bit(1)) {
      set_msid(from.msid());
    }
    if (from._has_bit(2)) {
      set_msid_pub_key(from.msid_pub_key());
    }
    if (from._has_bit(3)) {
      set_msid_pri_key(from.msid_pri_key());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Share::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Share::CopyFrom(const Share& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Share::Swap(Share* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(msid_, other->msid_);
    std::swap(msid_pub_key_, other->msid_pub_key_);
    std::swap(msid_pri_key_, other->msid_pri_key_);
    participants_.Swap(&other->participants_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

bool Share::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  
  for (int i = 0; i < participants_size(); i++) {
    if (!this->participants(i).IsInitialized()) return false;
  }
  return true;
}

const ::google::protobuf::Descriptor* Share::GetDescriptor() const {
  return descriptor();
}

const ::google::protobuf::Reflection* Share::GetReflection() const {
  protobuf_AssignDescriptorsOnce();
  return Share_reflection_;
}

// ===================================================================

const ::std::string Key::_default_id_;
const ::std::string Key::_default_private_key_;
const ::std::string Key::_default_public_key_;
const ::std::string Key::_default_public_key_signature_;
#ifndef _MSC_VER
const int Key::kIdFieldNumber;
const int Key::kTypeFieldNumber;
const int Key::kPrivateKeyFieldNumber;
const int Key::kPublicKeyFieldNumber;
const int Key::kPublicKeySignatureFieldNumber;
#endif  // !_MSC_VER

Key::Key()
  : ::google::protobuf::Message(),
    _unknown_fields_(),
    _cached_size_(0),
    id_(const_cast< ::std::string*>(&_default_id_)),
    type_(0),
    private_key_(const_cast< ::std::string*>(&_default_private_key_)),
    public_key_(const_cast< ::std::string*>(&_default_public_key_)),
    public_key_signature_(const_cast< ::std::string*>(&_default_public_key_signature_)) {
  SharedCtor();
}

void Key::InitAsDefaultInstance() {}

Key::Key(const Key& from)
  : ::google::protobuf::Message(),
    _unknown_fields_(),
    _cached_size_(0),
    id_(const_cast< ::std::string*>(&_default_id_)),
    type_(0),
    private_key_(const_cast< ::std::string*>(&_default_private_key_)),
    public_key_(const_cast< ::std::string*>(&_default_public_key_)),
    public_key_signature_(const_cast< ::std::string*>(&_default_public_key_signature_)) {
  SharedCtor();
  MergeFrom(from);
}

void Key::SharedCtor() {
  _cached_size_ = 0;
  id_ = const_cast< ::std::string*>(&_default_id_);
  type_ = 0;
  private_key_ = const_cast< ::std::string*>(&_default_private_key_);
  public_key_ = const_cast< ::std::string*>(&_default_public_key_);
  public_key_signature_ = const_cast< ::std::string*>(&_default_public_key_signature_);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Key::~Key() {
  SharedDtor();
}

void Key::SharedDtor() {
  if (id_ != &_default_id_) {
    delete id_;
  }
  if (private_key_ != &_default_private_key_) {
    delete private_key_;
  }
  if (public_key_ != &_default_public_key_) {
    delete public_key_;
  }
  if (public_key_signature_ != &_default_public_key_signature_) {
    delete public_key_signature_;
  }
  if (this != default_instance_) {
  }
}

const ::google::protobuf::Descriptor* Key::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Key_descriptor_;
}

const Key& Key::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_datamaps_2eproto();  return *default_instance_;
}

Key* Key::default_instance_ = NULL;

Key* Key::New() const {
  return new Key;
}

void Key::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (id_ != &_default_id_) {
        id_->clear();
      }
    }
    type_ = 0;
    if (_has_bit(2)) {
      if (private_key_ != &_default_private_key_) {
        private_key_->clear();
      }
    }
    if (_has_bit(3)) {
      if (public_key_ != &_default_public_key_) {
        public_key_->clear();
      }
    }
    if (_has_bit(4)) {
      if (public_key_signature_ != &_default_public_key_signature_) {
        public_key_signature_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Key::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormat::GetTagFieldNumber(tag)) {
      // required bytes id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormat::ReadBytes(input, mutable_id()));
        if (input->ExpectTag(16)) goto parse_type;
        break;
      }
      
      // required .maidsafe.PacketType type = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_type:
        int value;
        DO_(::google::protobuf::internal::WireFormat::ReadEnum(input, &value));
        if (maidsafe::PacketType_IsValid(value)) {
          set_type(static_cast< maidsafe::PacketType >(value));
        } else {
          mutable_unknown_fields()->AddVarint(2, value);
        }
        if (input->ExpectTag(26)) goto parse_private_key;
        break;
      }
      
      // required bytes private_key = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_private_key:
        DO_(::google::protobuf::internal::WireFormat::ReadBytes(input, mutable_private_key()));
        if (input->ExpectTag(34)) goto parse_public_key;
        break;
      }
      
      // required bytes public_key = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_public_key:
        DO_(::google::protobuf::internal::WireFormat::ReadBytes(input, mutable_public_key()));
        if (input->ExpectTag(42)) goto parse_public_key_signature;
        break;
      }
      
      // required bytes public_key_signature = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_public_key_signature:
        DO_(::google::protobuf::internal::WireFormat::ReadBytes(input, mutable_public_key_signature()));
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormat::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Key::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    Key::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // required bytes id = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::WriteBytes(1, this->id(), output);
  }
  
  // required .maidsafe.PacketType type = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::WriteEnum(2, this->type(), output);
  }
  
  // required bytes private_key = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormat::WriteBytes(3, this->private_key(), output);
  }
  
  // required bytes public_key = 4;
  if (_has_bit(3)) {
    ::google::protobuf::internal::WireFormat::WriteBytes(4, this->public_key(), output);
  }
  
  // required bytes public_key_signature = 5;
  if (_has_bit(4)) {
    ::google::protobuf::internal::WireFormat::WriteBytes(5, this->public_key_signature(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Key::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required bytes id = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormat::WriteBytesToArray(1, this->id(), target);
  }
  
  // required .maidsafe.PacketType type = 2;
  if (_has_bit(1)) {
    target = ::google::protobuf::internal::WireFormat::WriteEnumToArray(2, this->type(), target);
  }
  
  // required bytes private_key = 3;
  if (_has_bit(2)) {
    target = ::google::protobuf::internal::WireFormat::WriteBytesToArray(3, this->private_key(), target);
  }
  
  // required bytes public_key = 4;
  if (_has_bit(3)) {
    target = ::google::protobuf::internal::WireFormat::WriteBytesToArray(4, this->public_key(), target);
  }
  
  // required bytes public_key_signature = 5;
  if (_has_bit(4)) {
    target = ::google::protobuf::internal::WireFormat::WriteBytesToArray(5, this->public_key_signature(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Key::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::BytesSize(this->id());
    }
    
    // required .maidsafe.PacketType type = 2;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::EnumSize(this->type());
    }
    
    // required bytes private_key = 3;
    if (has_private_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::BytesSize(this->private_key());
    }
    
    // required bytes public_key = 4;
    if (has_public_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::BytesSize(this->public_key());
    }
    
    // required bytes public_key_signature = 5;
    if (has_public_key_signature()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::BytesSize(this->public_key_signature());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void Key::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Key* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Key*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Key::MergeFrom(const Key& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_id(from.id());
    }
    if (from._has_bit(1)) {
      set_type(from.type());
    }
    if (from._has_bit(2)) {
      set_private_key(from.private_key());
    }
    if (from._has_bit(3)) {
      set_public_key(from.public_key());
    }
    if (from._has_bit(4)) {
      set_public_key_signature(from.public_key_signature());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Key::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Key::CopyFrom(const Key& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Key::Swap(Key* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(type_, other->type_);
    std::swap(private_key_, other->private_key_);
    std::swap(public_key_, other->public_key_);
    std::swap(public_key_signature_, other->public_key_signature_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

bool Key::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001f) != 0x0000001f) return false;
  
  return true;
}

const ::google::protobuf::Descriptor* Key::GetDescriptor() const {
  return descriptor();
}

const ::google::protobuf::Reflection* Key::GetReflection() const {
  protobuf_AssignDescriptorsOnce();
  return Key_reflection_;
}

// ===================================================================

const ::std::string DataMap::_default_file_hash_;
const ::std::string DataMap::_default_se_version_;
#ifndef _MSC_VER
const int DataMap::kFileHashFieldNumber;
const int DataMap::kSeVersionFieldNumber;
const int DataMap::kChunkNameFieldNumber;
const int DataMap::kEncryptedChunkNameFieldNumber;
const int DataMap::kChunkSizeFieldNumber;
const int DataMap::kCompressionOnFieldNumber;
#endif  // !_MSC_VER

DataMap::DataMap()
  : ::google::protobuf::Message(),
    _unknown_fields_(),
    _cached_size_(0),
    file_hash_(const_cast< ::std::string*>(&_default_file_hash_)),
    se_version_(const_cast< ::std::string*>(&_default_se_version_)),
    chunk_name_(),
    encrypted_chunk_name_(),
    chunk_size_(),
    compression_on_(false) {
  SharedCtor();
}

void DataMap::InitAsDefaultInstance() {}

DataMap::DataMap(const DataMap& from)
  : ::google::protobuf::Message(),
    _unknown_fields_(),
    _cached_size_(0),
    file_hash_(const_cast< ::std::string*>(&_default_file_hash_)),
    se_version_(const_cast< ::std::string*>(&_default_se_version_)),
    chunk_name_(),
    encrypted_chunk_name_(),
    chunk_size_(),
    compression_on_(false) {
  SharedCtor();
  MergeFrom(from);
}

void DataMap::SharedCtor() {
  _cached_size_ = 0;
  file_hash_ = const_cast< ::std::string*>(&_default_file_hash_);
  se_version_ = const_cast< ::std::string*>(&_default_se_version_);
  compression_on_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DataMap::~DataMap() {
  SharedDtor();
}

void DataMap::SharedDtor() {
  if (file_hash_ != &_default_file_hash_) {
    delete file_hash_;
  }
  if (se_version_ != &_default_se_version_) {
    delete se_version_;
  }
  if (this != default_instance_) {
  }
}

const ::google::protobuf::Descriptor* DataMap::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DataMap_descriptor_;
}

const DataMap& DataMap::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_datamaps_2eproto();  return *default_instance_;
}

DataMap* DataMap::default_instance_ = NULL;

DataMap* DataMap::New() const {
  return new DataMap;
}

void DataMap::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (file_hash_ != &_default_file_hash_) {
        file_hash_->clear();
      }
    }
    if (_has_bit(1)) {
      if (se_version_ != &_default_se_version_) {
        se_version_->clear();
      }
    }
    compression_on_ = false;
  }
  chunk_name_.Clear();
  encrypted_chunk_name_.Clear();
  chunk_size_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool DataMap::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormat::GetTagFieldNumber(tag)) {
      // required bytes file_hash = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormat::ReadBytes(input, mutable_file_hash()));
        if (input->ExpectTag(18)) goto parse_se_version;
        break;
      }
      
      // optional bytes se_version = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_se_version:
        DO_(::google::protobuf::internal::WireFormat::ReadBytes(input, mutable_se_version()));
        if (input->ExpectTag(26)) goto parse_chunk_name;
        break;
      }
      
      // repeated bytes chunk_name = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_chunk_name:
        DO_(::google::protobuf::internal::WireFormat::ReadBytes(
             input, add_chunk_name()));
        if (input->ExpectTag(26)) goto parse_chunk_name;
        if (input->ExpectTag(34)) goto parse_encrypted_chunk_name;
        break;
      }
      
      // repeated bytes encrypted_chunk_name = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_encrypted_chunk_name:
        DO_(::google::protobuf::internal::WireFormat::ReadBytes(
             input, add_encrypted_chunk_name()));
        if (input->ExpectTag(34)) goto parse_encrypted_chunk_name;
        if (input->ExpectTag(40)) goto parse_chunk_size;
        break;
      }
      
      // repeated uint64 chunk_size = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_chunk_size:
        ::google::protobuf::uint64 value;
        DO_(::google::protobuf::internal::WireFormat::ReadUInt64(input, &value));
        add_chunk_size(value);
        if (input->ExpectTag(40)) goto parse_chunk_size;
        if (input->ExpectTag(48)) goto parse_compression_on;
        break;
      }
      
      // optional bool compression_on = 6 [default = false];
      case 6: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_compression_on:
        DO_(::google::protobuf::internal::WireFormat::ReadBool(
              input, &compression_on_));
        _set_bit(5);
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormat::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DataMap::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    DataMap::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // required bytes file_hash = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::WriteBytes(1, this->file_hash(), output);
  }
  
  // optional bytes se_version = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::WriteBytes(2, this->se_version(), output);
  }
  
  // repeated bytes chunk_name = 3;
  for (int i = 0; i < this->chunk_name_size(); i++) {
    ::google::protobuf::internal::WireFormat::WriteBytes(3, this->chunk_name(i), output);
  }
  
  // repeated bytes encrypted_chunk_name = 4;
  for (int i = 0; i < this->encrypted_chunk_name_size(); i++) {
    ::google::protobuf::internal::WireFormat::WriteBytes(4, this->encrypted_chunk_name(i), output);
  }
  
  // repeated uint64 chunk_size = 5;
  for (int i = 0; i < this->chunk_size_size(); i++) {
    ::google::protobuf::internal::WireFormat::WriteUInt64(5, this->chunk_size(i), output);
  }
  
  // optional bool compression_on = 6 [default = false];
  if (_has_bit(5)) {
    ::google::protobuf::internal::WireFormat::WriteBool(6, this->compression_on(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* DataMap::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required bytes file_hash = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormat::WriteBytesToArray(1, this->file_hash(), target);
  }
  
  // optional bytes se_version = 2;
  if (_has_bit(1)) {
    target = ::google::protobuf::internal::WireFormat::WriteBytesToArray(2, this->se_version(), target);
  }
  
  // repeated bytes chunk_name = 3;
  for (int i = 0; i < this->chunk_name_size(); i++) {
    target = ::google::protobuf::internal::WireFormat::WriteBytesToArray(3, this->chunk_name(i), target);
  }
  
  // repeated bytes encrypted_chunk_name = 4;
  for (int i = 0; i < this->encrypted_chunk_name_size(); i++) {
    target = ::google::protobuf::internal::WireFormat::WriteBytesToArray(4, this->encrypted_chunk_name(i), target);
  }
  
  // repeated uint64 chunk_size = 5;
  for (int i = 0; i < this->chunk_size_size(); i++) {
    target = ::google::protobuf::internal::WireFormat::WriteUInt64ToArray(5, this->chunk_size(i), target);
  }
  
  // optional bool compression_on = 6 [default = false];
  if (_has_bit(5)) {
    target = ::google::protobuf::internal::WireFormat::WriteBoolToArray(6, this->compression_on(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int DataMap::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes file_hash = 1;
    if (has_file_hash()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::BytesSize(this->file_hash());
    }
    
    // optional bytes se_version = 2;
    if (has_se_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::BytesSize(this->se_version());
    }
    
    // optional bool compression_on = 6 [default = false];
    if (has_compression_on()) {
      total_size += 1 + 1;
    }
    
  }
  // repeated bytes chunk_name = 3;
  total_size += 1 * this->chunk_name_size();
  for (int i = 0; i < this->chunk_name_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormat::BytesSize(
      this->chunk_name(i));
  }
  
  // repeated bytes encrypted_chunk_name = 4;
  total_size += 1 * this->encrypted_chunk_name_size();
  for (int i = 0; i < this->encrypted_chunk_name_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormat::BytesSize(
      this->encrypted_chunk_name(i));
  }
  
  // repeated uint64 chunk_size = 5;
  {
    int data_size = 0;
    for (int i = 0; i < this->chunk_size_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormat::UInt64Size(
        this->chunk_size(i));
    }
    total_size += 1 * this->chunk_size_size() + data_size;
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void DataMap::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const DataMap* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const DataMap*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DataMap::MergeFrom(const DataMap& from) {
  GOOGLE_CHECK_NE(&from, this);
  chunk_name_.MergeFrom(from.chunk_name_);
  encrypted_chunk_name_.MergeFrom(from.encrypted_chunk_name_);
  chunk_size_.MergeFrom(from.chunk_size_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_file_hash(from.file_hash());
    }
    if (from._has_bit(1)) {
      set_se_version(from.se_version());
    }
    if (from._has_bit(5)) {
      set_compression_on(from.compression_on());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void DataMap::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DataMap::CopyFrom(const DataMap& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DataMap::Swap(DataMap* other) {
  if (other != this) {
    std::swap(file_hash_, other->file_hash_);
    std::swap(se_version_, other->se_version_);
    chunk_name_.Swap(&other->chunk_name_);
    encrypted_chunk_name_.Swap(&other->encrypted_chunk_name_);
    chunk_size_.Swap(&other->chunk_size_);
    std::swap(compression_on_, other->compression_on_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

bool DataMap::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  
  return true;
}

const ::google::protobuf::Descriptor* DataMap::GetDescriptor() const {
  return descriptor();
}

const ::google::protobuf::Reflection* DataMap::GetReflection() const {
  protobuf_AssignDescriptorsOnce();
  return DataMap_reflection_;
}

// ===================================================================

const ::std::string MetaDataMap::_default_display_name_;
const ::std::string MetaDataMap::_default_stats_;
const ::std::string MetaDataMap::_default_tag_;
#ifndef _MSC_VER
const int MetaDataMap::kIdFieldNumber;
const int MetaDataMap::kDisplayNameFieldNumber;
const int MetaDataMap::kTypeFieldNumber;
const int MetaDataMap::kFileHashFieldNumber;
const int MetaDataMap::kStatsFieldNumber;
const int MetaDataMap::kTagFieldNumber;
const int MetaDataMap::kFileSizeHighFieldNumber;
const int MetaDataMap::kFileSizeLowFieldNumber;
const int MetaDataMap::kCreationTimeFieldNumber;
const int MetaDataMap::kLastModifiedFieldNumber;
const int MetaDataMap::kLastAccessFieldNumber;
#endif  // !_MSC_VER

MetaDataMap::MetaDataMap()
  : ::google::protobuf::Message(),
    _unknown_fields_(),
    _cached_size_(0),
    id_(0),
    display_name_(const_cast< ::std::string*>(&_default_display_name_)),
    type_(0),
    file_hash_(),
    stats_(const_cast< ::std::string*>(&_default_stats_)),
    tag_(const_cast< ::std::string*>(&_default_tag_)),
    file_size_high_(0),
    file_size_low_(0),
    creation_time_(0),
    last_modified_(0),
    last_access_(0) {
  SharedCtor();
}

void MetaDataMap::InitAsDefaultInstance() {}

MetaDataMap::MetaDataMap(const MetaDataMap& from)
  : ::google::protobuf::Message(),
    _unknown_fields_(),
    _cached_size_(0),
    id_(0),
    display_name_(const_cast< ::std::string*>(&_default_display_name_)),
    type_(0),
    file_hash_(),
    stats_(const_cast< ::std::string*>(&_default_stats_)),
    tag_(const_cast< ::std::string*>(&_default_tag_)),
    file_size_high_(0),
    file_size_low_(0),
    creation_time_(0),
    last_modified_(0),
    last_access_(0) {
  SharedCtor();
  MergeFrom(from);
}

void MetaDataMap::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0;
  display_name_ = const_cast< ::std::string*>(&_default_display_name_);
  type_ = 0;
  stats_ = const_cast< ::std::string*>(&_default_stats_);
  tag_ = const_cast< ::std::string*>(&_default_tag_);
  file_size_high_ = 0;
  file_size_low_ = 0;
  creation_time_ = 0;
  last_modified_ = 0;
  last_access_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MetaDataMap::~MetaDataMap() {
  SharedDtor();
}

void MetaDataMap::SharedDtor() {
  if (display_name_ != &_default_display_name_) {
    delete display_name_;
  }
  if (stats_ != &_default_stats_) {
    delete stats_;
  }
  if (tag_ != &_default_tag_) {
    delete tag_;
  }
  if (this != default_instance_) {
  }
}

const ::google::protobuf::Descriptor* MetaDataMap::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MetaDataMap_descriptor_;
}

const MetaDataMap& MetaDataMap::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_datamaps_2eproto();  return *default_instance_;
}

MetaDataMap* MetaDataMap::default_instance_ = NULL;

MetaDataMap* MetaDataMap::New() const {
  return new MetaDataMap;
}

void MetaDataMap::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    id_ = 0;
    if (_has_bit(1)) {
      if (display_name_ != &_default_display_name_) {
        display_name_->clear();
      }
    }
    type_ = 0;
    if (_has_bit(4)) {
      if (stats_ != &_default_stats_) {
        stats_->clear();
      }
    }
    if (_has_bit(5)) {
      if (tag_ != &_default_tag_) {
        tag_->clear();
      }
    }
    file_size_high_ = 0;
    file_size_low_ = 0;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    creation_time_ = 0;
    last_modified_ = 0;
    last_access_ = 0;
  }
  file_hash_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MetaDataMap::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormat::GetTagFieldNumber(tag)) {
      // required int32 id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormat::ReadInt32(
              input, &id_));
        _set_bit(0);
        if (input->ExpectTag(18)) goto parse_display_name;
        break;
      }
      
      // required bytes display_name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_display_name:
        DO_(::google::protobuf::internal::WireFormat::ReadBytes(input, mutable_display_name()));
        if (input->ExpectTag(24)) goto parse_type;
        break;
      }
      
      // required .maidsafe.ItemType type = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_type:
        int value;
        DO_(::google::protobuf::internal::WireFormat::ReadEnum(input, &value));
        if (maidsafe::ItemType_IsValid(value)) {
          set_type(static_cast< maidsafe::ItemType >(value));
        } else {
          mutable_unknown_fields()->AddVarint(3, value);
        }
        if (input->ExpectTag(34)) goto parse_file_hash;
        break;
      }
      
      // repeated bytes file_hash = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_file_hash:
        DO_(::google::protobuf::internal::WireFormat::ReadBytes(
             input, add_file_hash()));
        if (input->ExpectTag(34)) goto parse_file_hash;
        if (input->ExpectTag(42)) goto parse_stats;
        break;
      }
      
      // optional bytes stats = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_stats:
        DO_(::google::protobuf::internal::WireFormat::ReadBytes(input, mutable_stats()));
        if (input->ExpectTag(50)) goto parse_tag;
        break;
      }
      
      // optional bytes tag = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_tag:
        DO_(::google::protobuf::internal::WireFormat::ReadBytes(input, mutable_tag()));
        if (input->ExpectTag(56)) goto parse_file_size_high;
        break;
      }
      
      // optional int32 file_size_high = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_file_size_high:
        DO_(::google::protobuf::internal::WireFormat::ReadInt32(
              input, &file_size_high_));
        _set_bit(6);
        if (input->ExpectTag(64)) goto parse_file_size_low;
        break;
      }
      
      // optional int32 file_size_low = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_file_size_low:
        DO_(::google::protobuf::internal::WireFormat::ReadInt32(
              input, &file_size_low_));
        _set_bit(7);
        if (input->ExpectTag(72)) goto parse_creation_time;
        break;
      }
      
      // optional int32 creation_time = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_creation_time:
        DO_(::google::protobuf::internal::WireFormat::ReadInt32(
              input, &creation_time_));
        _set_bit(8);
        if (input->ExpectTag(80)) goto parse_last_modified;
        break;
      }
      
      // optional int32 last_modified = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_last_modified:
        DO_(::google::protobuf::internal::WireFormat::ReadInt32(
              input, &last_modified_));
        _set_bit(9);
        if (input->ExpectTag(88)) goto parse_last_access;
        break;
      }
      
      // optional int32 last_access = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_last_access:
        DO_(::google::protobuf::internal::WireFormat::ReadInt32(
              input, &last_access_));
        _set_bit(10);
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormat::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MetaDataMap::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    MetaDataMap::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // required int32 id = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::WriteInt32(1, this->id(), output);
  }
  
  // required bytes display_name = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormat::WriteBytes(2, this->display_name(), output);
  }
  
  // required .maidsafe.ItemType type = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormat::WriteEnum(3, this->type(), output);
  }
  
  // repeated bytes file_hash = 4;
  for (int i = 0; i < this->file_hash_size(); i++) {
    ::google::protobuf::internal::WireFormat::WriteBytes(4, this->file_hash(i), output);
  }
  
  // optional bytes stats = 5;
  if (_has_bit(4)) {
    ::google::protobuf::internal::WireFormat::WriteBytes(5, this->stats(), output);
  }
  
  // optional bytes tag = 6;
  if (_has_bit(5)) {
    ::google::protobuf::internal::WireFormat::WriteBytes(6, this->tag(), output);
  }
  
  // optional int32 file_size_high = 7;
  if (_has_bit(6)) {
    ::google::protobuf::internal::WireFormat::WriteInt32(7, this->file_size_high(), output);
  }
  
  // optional int32 file_size_low = 8;
  if (_has_bit(7)) {
    ::google::protobuf::internal::WireFormat::WriteInt32(8, this->file_size_low(), output);
  }
  
  // optional int32 creation_time = 9;
  if (_has_bit(8)) {
    ::google::protobuf::internal::WireFormat::WriteInt32(9, this->creation_time(), output);
  }
  
  // optional int32 last_modified = 10;
  if (_has_bit(9)) {
    ::google::protobuf::internal::WireFormat::WriteInt32(10, this->last_modified(), output);
  }
  
  // optional int32 last_access = 11;
  if (_has_bit(10)) {
    ::google::protobuf::internal::WireFormat::WriteInt32(11, this->last_access(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MetaDataMap::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 id = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormat::WriteInt32ToArray(1, this->id(), target);
  }
  
  // required bytes display_name = 2;
  if (_has_bit(1)) {
    target = ::google::protobuf::internal::WireFormat::WriteBytesToArray(2, this->display_name(), target);
  }
  
  // required .maidsafe.ItemType type = 3;
  if (_has_bit(2)) {
    target = ::google::protobuf::internal::WireFormat::WriteEnumToArray(3, this->type(), target);
  }
  
  // repeated bytes file_hash = 4;
  for (int i = 0; i < this->file_hash_size(); i++) {
    target = ::google::protobuf::internal::WireFormat::WriteBytesToArray(4, this->file_hash(i), target);
  }
  
  // optional bytes stats = 5;
  if (_has_bit(4)) {
    target = ::google::protobuf::internal::WireFormat::WriteBytesToArray(5, this->stats(), target);
  }
  
  // optional bytes tag = 6;
  if (_has_bit(5)) {
    target = ::google::protobuf::internal::WireFormat::WriteBytesToArray(6, this->tag(), target);
  }
  
  // optional int32 file_size_high = 7;
  if (_has_bit(6)) {
    target = ::google::protobuf::internal::WireFormat::WriteInt32ToArray(7, this->file_size_high(), target);
  }
  
  // optional int32 file_size_low = 8;
  if (_has_bit(7)) {
    target = ::google::protobuf::internal::WireFormat::WriteInt32ToArray(8, this->file_size_low(), target);
  }
  
  // optional int32 creation_time = 9;
  if (_has_bit(8)) {
    target = ::google::protobuf::internal::WireFormat::WriteInt32ToArray(9, this->creation_time(), target);
  }
  
  // optional int32 last_modified = 10;
  if (_has_bit(9)) {
    target = ::google::protobuf::internal::WireFormat::WriteInt32ToArray(10, this->last_modified(), target);
  }
  
  // optional int32 last_access = 11;
  if (_has_bit(10)) {
    target = ::google::protobuf::internal::WireFormat::WriteInt32ToArray(11, this->last_access(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MetaDataMap::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::Int32Size(
          this->id());
    }
    
    // required bytes display_name = 2;
    if (has_display_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::BytesSize(this->display_name());
    }
    
    // required .maidsafe.ItemType type = 3;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::EnumSize(this->type());
    }
    
    // optional bytes stats = 5;
    if (has_stats()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::BytesSize(this->stats());
    }
    
    // optional bytes tag = 6;
    if (has_tag()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::BytesSize(this->tag());
    }
    
    // optional int32 file_size_high = 7;
    if (has_file_size_high()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::Int32Size(
          this->file_size_high());
    }
    
    // optional int32 file_size_low = 8;
    if (has_file_size_low()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::Int32Size(
          this->file_size_low());
    }
    
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional int32 creation_time = 9;
    if (has_creation_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::Int32Size(
          this->creation_time());
    }
    
    // optional int32 last_modified = 10;
    if (has_last_modified()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::Int32Size(
          this->last_modified());
    }
    
    // optional int32 last_access = 11;
    if (has_last_access()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::Int32Size(
          this->last_access());
    }
    
  }
  // repeated bytes file_hash = 4;
  total_size += 1 * this->file_hash_size();
  for (int i = 0; i < this->file_hash_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormat::BytesSize(
      this->file_hash(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void MetaDataMap::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MetaDataMap* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MetaDataMap*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MetaDataMap::MergeFrom(const MetaDataMap& from) {
  GOOGLE_CHECK_NE(&from, this);
  file_hash_.MergeFrom(from.file_hash_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_id(from.id());
    }
    if (from._has_bit(1)) {
      set_display_name(from.display_name());
    }
    if (from._has_bit(2)) {
      set_type(from.type());
    }
    if (from._has_bit(4)) {
      set_stats(from.stats());
    }
    if (from._has_bit(5)) {
      set_tag(from.tag());
    }
    if (from._has_bit(6)) {
      set_file_size_high(from.file_size_high());
    }
    if (from._has_bit(7)) {
      set_file_size_low(from.file_size_low());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from._has_bit(8)) {
      set_creation_time(from.creation_time());
    }
    if (from._has_bit(9)) {
      set_last_modified(from.last_modified());
    }
    if (from._has_bit(10)) {
      set_last_access(from.last_access());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MetaDataMap::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MetaDataMap::CopyFrom(const MetaDataMap& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MetaDataMap::Swap(MetaDataMap* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(display_name_, other->display_name_);
    std::swap(type_, other->type_);
    file_hash_.Swap(&other->file_hash_);
    std::swap(stats_, other->stats_);
    std::swap(tag_, other->tag_);
    std::swap(file_size_high_, other->file_size_high_);
    std::swap(file_size_low_, other->file_size_low_);
    std::swap(creation_time_, other->creation_time_);
    std::swap(last_modified_, other->last_modified_);
    std::swap(last_access_, other->last_access_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

bool MetaDataMap::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  
  return true;
}

const ::google::protobuf::Descriptor* MetaDataMap::GetDescriptor() const {
  return descriptor();
}

const ::google::protobuf::Reflection* MetaDataMap::GetReflection() const {
  protobuf_AssignDescriptorsOnce();
  return MetaDataMap_reflection_;
}

// ===================================================================

const ::std::string Chunk::_default_compression_type_;
#ifndef _MSC_VER
const int Chunk::kCompressionTypeFieldNumber;
const int Chunk::kChunkletFieldNumber;
const int Chunk::kPreCompressionChunkletSizeFieldNumber;
#endif  // !_MSC_VER

Chunk::Chunk()
  : ::google::protobuf::Message(),
    _unknown_fields_(),
    _cached_size_(0),
    compression_type_(const_cast< ::std::string*>(&_default_compression_type_)),
    chunklet_(),
    pre_compression_chunklet_size_() {
  SharedCtor();
}

void Chunk::InitAsDefaultInstance() {}

Chunk::Chunk(const Chunk& from)
  : ::google::protobuf::Message(),
    _unknown_fields_(),
    _cached_size_(0),
    compression_type_(const_cast< ::std::string*>(&_default_compression_type_)),
    chunklet_(),
    pre_compression_chunklet_size_() {
  SharedCtor();
  MergeFrom(from);
}

void Chunk::SharedCtor() {
  _cached_size_ = 0;
  compression_type_ = const_cast< ::std::string*>(&_default_compression_type_);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Chunk::~Chunk() {
  SharedDtor();
}

void Chunk::SharedDtor() {
  if (compression_type_ != &_default_compression_type_) {
    delete compression_type_;
  }
  if (this != default_instance_) {
  }
}

const ::google::protobuf::Descriptor* Chunk::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Chunk_descriptor_;
}

const Chunk& Chunk::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_datamaps_2eproto();  return *default_instance_;
}

Chunk* Chunk::default_instance_ = NULL;

Chunk* Chunk::New() const {
  return new Chunk;
}

void Chunk::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (compression_type_ != &_default_compression_type_) {
        compression_type_->clear();
      }
    }
  }
  chunklet_.Clear();
  pre_compression_chunklet_size_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Chunk::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormat::GetTagFieldNumber(tag)) {
      // optional bytes compression_type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormat::ReadBytes(input, mutable_compression_type()));
        if (input->ExpectTag(18)) goto parse_chunklet;
        break;
      }
      
      // repeated bytes chunklet = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_chunklet:
        DO_(::google::protobuf::internal::WireFormat::ReadBytes(
             input, add_chunklet()));
        if (input->ExpectTag(18)) goto parse_chunklet;
        if (input->ExpectTag(24)) goto parse_pre_compression_chunklet_size;
        break;
      }
      
      // repeated int32 pre_compression_chunklet_size = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_VARINT) {
          goto handle_uninterpreted;
        }
       parse_pre_compression_chunklet_size:
        ::google::protobuf::int32 value;
        DO_(::google::protobuf::internal::WireFormat::ReadInt32(input, &value));
        add_pre_compression_chunklet_size(value);
        if (input->ExpectTag(24)) goto parse_pre_compression_chunklet_size;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormat::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Chunk::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    Chunk::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // optional bytes compression_type = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::WriteBytes(1, this->compression_type(), output);
  }
  
  // repeated bytes chunklet = 2;
  for (int i = 0; i < this->chunklet_size(); i++) {
    ::google::protobuf::internal::WireFormat::WriteBytes(2, this->chunklet(i), output);
  }
  
  // repeated int32 pre_compression_chunklet_size = 3;
  for (int i = 0; i < this->pre_compression_chunklet_size_size(); i++) {
    ::google::protobuf::internal::WireFormat::WriteInt32(3, this->pre_compression_chunklet_size(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Chunk::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional bytes compression_type = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormat::WriteBytesToArray(1, this->compression_type(), target);
  }
  
  // repeated bytes chunklet = 2;
  for (int i = 0; i < this->chunklet_size(); i++) {
    target = ::google::protobuf::internal::WireFormat::WriteBytesToArray(2, this->chunklet(i), target);
  }
  
  // repeated int32 pre_compression_chunklet_size = 3;
  for (int i = 0; i < this->pre_compression_chunklet_size_size(); i++) {
    target = ::google::protobuf::internal::WireFormat::WriteInt32ToArray(3, this->pre_compression_chunklet_size(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Chunk::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes compression_type = 1;
    if (has_compression_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::BytesSize(this->compression_type());
    }
    
  }
  // repeated bytes chunklet = 2;
  total_size += 1 * this->chunklet_size();
  for (int i = 0; i < this->chunklet_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormat::BytesSize(
      this->chunklet(i));
  }
  
  // repeated int32 pre_compression_chunklet_size = 3;
  {
    int data_size = 0;
    for (int i = 0; i < this->pre_compression_chunklet_size_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormat::Int32Size(
        this->pre_compression_chunklet_size(i));
    }
    total_size += 1 * this->pre_compression_chunklet_size_size() + data_size;
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void Chunk::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Chunk* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Chunk*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Chunk::MergeFrom(const Chunk& from) {
  GOOGLE_CHECK_NE(&from, this);
  chunklet_.MergeFrom(from.chunklet_);
  pre_compression_chunklet_size_.MergeFrom(from.pre_compression_chunklet_size_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_compression_type(from.compression_type());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Chunk::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Chunk::CopyFrom(const Chunk& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Chunk::Swap(Chunk* other) {
  if (other != this) {
    std::swap(compression_type_, other->compression_type_);
    chunklet_.Swap(&other->chunklet_);
    pre_compression_chunklet_size_.Swap(&other->pre_compression_chunklet_size_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

bool Chunk::IsInitialized() const {
  
  return true;
}

const ::google::protobuf::Descriptor* Chunk::GetDescriptor() const {
  return descriptor();
}

const ::google::protobuf::Reflection* Chunk::GetReflection() const {
  protobuf_AssignDescriptorsOnce();
  return Chunk_reflection_;
}

// ===================================================================

const ::std::string DataAtlas::_default_root_db_key_;
#ifndef _MSC_VER
const int DataAtlas::kRootDbKeyFieldNumber;
const int DataAtlas::kKeysFieldNumber;
const int DataAtlas::kMdmsFieldNumber;
const int DataAtlas::kDmsFieldNumber;
const int DataAtlas::kContactsFieldNumber;
const int DataAtlas::kSharesFieldNumber;
#endif  // !_MSC_VER

DataAtlas::DataAtlas()
  : ::google::protobuf::Message(),
    _unknown_fields_(),
    _cached_size_(0),
    root_db_key_(const_cast< ::std::string*>(&_default_root_db_key_)),
    keys_(),
    mdms_(),
    dms_(),
    contacts_(),
    shares_() {
  SharedCtor();
}

void DataAtlas::InitAsDefaultInstance() {}

DataAtlas::DataAtlas(const DataAtlas& from)
  : ::google::protobuf::Message(),
    _unknown_fields_(),
    _cached_size_(0),
    root_db_key_(const_cast< ::std::string*>(&_default_root_db_key_)),
    keys_(),
    mdms_(),
    dms_(),
    contacts_(),
    shares_() {
  SharedCtor();
  MergeFrom(from);
}

void DataAtlas::SharedCtor() {
  _cached_size_ = 0;
  root_db_key_ = const_cast< ::std::string*>(&_default_root_db_key_);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DataAtlas::~DataAtlas() {
  SharedDtor();
}

void DataAtlas::SharedDtor() {
  if (root_db_key_ != &_default_root_db_key_) {
    delete root_db_key_;
  }
  if (this != default_instance_) {
  }
}

const ::google::protobuf::Descriptor* DataAtlas::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DataAtlas_descriptor_;
}

const DataAtlas& DataAtlas::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_datamaps_2eproto();  return *default_instance_;
}

DataAtlas* DataAtlas::default_instance_ = NULL;

DataAtlas* DataAtlas::New() const {
  return new DataAtlas;
}

void DataAtlas::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (root_db_key_ != &_default_root_db_key_) {
        root_db_key_->clear();
      }
    }
  }
  keys_.Clear();
  mdms_.Clear();
  dms_.Clear();
  contacts_.Clear();
  shares_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool DataAtlas::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormat::GetTagFieldNumber(tag)) {
      // optional bytes root_db_key = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
        DO_(::google::protobuf::internal::WireFormat::ReadBytes(input, mutable_root_db_key()));
        if (input->ExpectTag(18)) goto parse_keys;
        break;
      }
      
      // repeated .maidsafe.Key keys = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_keys:
        DO_(::google::protobuf::internal::WireFormat::ReadMessageNoVirtual(
             input, add_keys()));
        if (input->ExpectTag(18)) goto parse_keys;
        if (input->ExpectTag(26)) goto parse_mdms;
        break;
      }
      
      // repeated .maidsafe.MetaDataMap mdms = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_mdms:
        DO_(::google::protobuf::internal::WireFormat::ReadMessageNoVirtual(
             input, add_mdms()));
        if (input->ExpectTag(26)) goto parse_mdms;
        if (input->ExpectTag(34)) goto parse_dms;
        break;
      }
      
      // repeated .maidsafe.DataMap dms = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_dms:
        DO_(::google::protobuf::internal::WireFormat::ReadMessageNoVirtual(
             input, add_dms()));
        if (input->ExpectTag(34)) goto parse_dms;
        if (input->ExpectTag(42)) goto parse_contacts;
        break;
      }
      
      // repeated .maidsafe.PublicContact contacts = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_contacts:
        DO_(::google::protobuf::internal::WireFormat::ReadMessageNoVirtual(
             input, add_contacts()));
        if (input->ExpectTag(42)) goto parse_contacts;
        if (input->ExpectTag(50)) goto parse_shares;
        break;
      }
      
      // repeated .maidsafe.Share shares = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) !=
            ::google::protobuf::internal::WireFormat::WIRETYPE_LENGTH_DELIMITED) {
          goto handle_uninterpreted;
        }
       parse_shares:
        DO_(::google::protobuf::internal::WireFormat::ReadMessageNoVirtual(
             input, add_shares()));
        if (input->ExpectTag(50)) goto parse_shares;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormat::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormat::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DataAtlas::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  ::google::protobuf::uint8* raw_buffer = output->GetDirectBufferForNBytesAndAdvance(_cached_size_);
  if (raw_buffer != NULL) {
    DataAtlas::SerializeWithCachedSizesToArray(raw_buffer);
    return;
  }
  
  // optional bytes root_db_key = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormat::WriteBytes(1, this->root_db_key(), output);
  }
  
  // repeated .maidsafe.Key keys = 2;
  for (int i = 0; i < this->keys_size(); i++) {
    ::google::protobuf::internal::WireFormat::WriteMessageNoVirtual(2, this->keys(i), output);
  }
  
  // repeated .maidsafe.MetaDataMap mdms = 3;
  for (int i = 0; i < this->mdms_size(); i++) {
    ::google::protobuf::internal::WireFormat::WriteMessageNoVirtual(3, this->mdms(i), output);
  }
  
  // repeated .maidsafe.DataMap dms = 4;
  for (int i = 0; i < this->dms_size(); i++) {
    ::google::protobuf::internal::WireFormat::WriteMessageNoVirtual(4, this->dms(i), output);
  }
  
  // repeated .maidsafe.PublicContact contacts = 5;
  for (int i = 0; i < this->contacts_size(); i++) {
    ::google::protobuf::internal::WireFormat::WriteMessageNoVirtual(5, this->contacts(i), output);
  }
  
  // repeated .maidsafe.Share shares = 6;
  for (int i = 0; i < this->shares_size(); i++) {
    ::google::protobuf::internal::WireFormat::WriteMessageNoVirtual(6, this->shares(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* DataAtlas::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional bytes root_db_key = 1;
  if (_has_bit(0)) {
    target = ::google::protobuf::internal::WireFormat::WriteBytesToArray(1, this->root_db_key(), target);
  }
  
  // repeated .maidsafe.Key keys = 2;
  for (int i = 0; i < this->keys_size(); i++) {
    target = ::google::protobuf::internal::WireFormat::WriteMessageNoVirtualToArray(2, this->keys(i), target);
  }
  
  // repeated .maidsafe.MetaDataMap mdms = 3;
  for (int i = 0; i < this->mdms_size(); i++) {
    target = ::google::protobuf::internal::WireFormat::WriteMessageNoVirtualToArray(3, this->mdms(i), target);
  }
  
  // repeated .maidsafe.DataMap dms = 4;
  for (int i = 0; i < this->dms_size(); i++) {
    target = ::google::protobuf::internal::WireFormat::WriteMessageNoVirtualToArray(4, this->dms(i), target);
  }
  
  // repeated .maidsafe.PublicContact contacts = 5;
  for (int i = 0; i < this->contacts_size(); i++) {
    target = ::google::protobuf::internal::WireFormat::WriteMessageNoVirtualToArray(5, this->contacts(i), target);
  }
  
  // repeated .maidsafe.Share shares = 6;
  for (int i = 0; i < this->shares_size(); i++) {
    target = ::google::protobuf::internal::WireFormat::WriteMessageNoVirtualToArray(6, this->shares(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int DataAtlas::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes root_db_key = 1;
    if (has_root_db_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormat::BytesSize(this->root_db_key());
    }
    
  }
  // repeated .maidsafe.Key keys = 2;
  total_size += 1 * this->keys_size();
  for (int i = 0; i < this->keys_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormat::MessageSizeNoVirtual(
        this->keys(i));
  }
  
  // repeated .maidsafe.MetaDataMap mdms = 3;
  total_size += 1 * this->mdms_size();
  for (int i = 0; i < this->mdms_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormat::MessageSizeNoVirtual(
        this->mdms(i));
  }
  
  // repeated .maidsafe.DataMap dms = 4;
  total_size += 1 * this->dms_size();
  for (int i = 0; i < this->dms_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormat::MessageSizeNoVirtual(
        this->dms(i));
  }
  
  // repeated .maidsafe.PublicContact contacts = 5;
  total_size += 1 * this->contacts_size();
  for (int i = 0; i < this->contacts_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormat::MessageSizeNoVirtual(
        this->contacts(i));
  }
  
  // repeated .maidsafe.Share shares = 6;
  total_size += 1 * this->shares_size();
  for (int i = 0; i < this->shares_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormat::MessageSizeNoVirtual(
        this->shares(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  _cached_size_ = total_size;
  return total_size;
}

void DataAtlas::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const DataAtlas* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const DataAtlas*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DataAtlas::MergeFrom(const DataAtlas& from) {
  GOOGLE_CHECK_NE(&from, this);
  keys_.MergeFrom(from.keys_);
  mdms_.MergeFrom(from.mdms_);
  dms_.MergeFrom(from.dms_);
  contacts_.MergeFrom(from.contacts_);
  shares_.MergeFrom(from.shares_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_root_db_key(from.root_db_key());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void DataAtlas::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DataAtlas::CopyFrom(const DataAtlas& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DataAtlas::Swap(DataAtlas* other) {
  if (other != this) {
    std::swap(root_db_key_, other->root_db_key_);
    keys_.Swap(&other->keys_);
    mdms_.Swap(&other->mdms_);
    dms_.Swap(&other->dms_);
    contacts_.Swap(&other->contacts_);
    shares_.Swap(&other->shares_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

bool DataAtlas::IsInitialized() const {
  
  for (int i = 0; i < keys_size(); i++) {
    if (!this->keys(i).IsInitialized()) return false;
  }
  for (int i = 0; i < mdms_size(); i++) {
    if (!this->mdms(i).IsInitialized()) return false;
  }
  for (int i = 0; i < dms_size(); i++) {
    if (!this->dms(i).IsInitialized()) return false;
  }
  for (int i = 0; i < contacts_size(); i++) {
    if (!this->contacts(i).IsInitialized()) return false;
  }
  for (int i = 0; i < shares_size(); i++) {
    if (!this->shares(i).IsInitialized()) return false;
  }
  return true;
}

const ::google::protobuf::Descriptor* DataAtlas::GetDescriptor() const {
  return descriptor();
}

const ::google::protobuf::Reflection* DataAtlas::GetReflection() const {
  protobuf_AssignDescriptorsOnce();
  return DataAtlas_reflection_;
}

}  // namespace maidsafe
