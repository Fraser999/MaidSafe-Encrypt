// Generated by the protocol buffer compiler.  DO NOT EDIT!

#ifndef PROTOBUF_datamaps_2eproto__INCLUDED
#define PROTOBUF_datamaps_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2001000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2001000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>

namespace maidsafe {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_datamaps_2eproto();
void protobuf_AssignDesc_datamaps_2eproto();
void protobuf_ShutdownFile_datamaps_2eproto();

class PublicContact;
class ShareParticipant;
class Share;
class Key;
class DataMap;
class MetaDataMap;
class Chunk;
class DataAtlas;

enum itemtype {
  REGULAR_FILE = 0,
  SMALL_FILE = 1,
  EMPTY_FILE = 2,
  LOCKED_FILE = 3,
  DIRECTORY = 4,
  EMPTY_DIRECTORY = 5,
  LINK = 6,
  NOT_FOR_PROCESSING = 7,
  UNKNOWN = 8
};
const ::google::protobuf::EnumDescriptor* itemtype_descriptor();
bool itemtype_IsValid(int value);
const itemtype itemtype_MIN = REGULAR_FILE;
const itemtype itemtype_MAX = UNKNOWN;

inline const ::std::string& itemtype_Name(itemtype value) {
  return ::google::protobuf::internal::NameOfEnum(
    itemtype_descriptor(), value);
}
inline bool itemtype_Parse(
    const ::std::string& name, itemtype* value) {
  return ::google::protobuf::internal::ParseNamedEnum<itemtype>(
    itemtype_descriptor(), name, value);
}
enum PacketType {
  ANMID = 0,
  ANTMID = 1,
  ANSMID = 2,
  MAID = 3,
  PMID = 4,
  ANMPID = 5,
  MPID = 6
};
const ::google::protobuf::EnumDescriptor* PacketType_descriptor();
bool PacketType_IsValid(int value);
const PacketType PacketType_MIN = ANMID;
const PacketType PacketType_MAX = MPID;

inline const ::std::string& PacketType_Name(PacketType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PacketType_descriptor(), value);
}
inline bool PacketType_Parse(
    const ::std::string& name, PacketType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PacketType>(
    PacketType_descriptor(), name, value);
}
// ===================================================================

class PublicContact : public ::google::protobuf::Message {
 public:
  PublicContact();
  virtual ~PublicContact();
  
  PublicContact(const PublicContact& from);
  
  inline PublicContact& operator=(const PublicContact& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PublicContact& default_instance();
  void Swap(PublicContact* other);
  
  // implements Message ----------------------------------------------
  
  PublicContact* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PublicContact& from);
  void MergeFrom(const PublicContact& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes pub_name = 1;
  inline bool has_pub_name() const;
  inline void clear_pub_name();
  static const int kPubNameFieldNumber = 1;
  inline const ::std::string& pub_name() const;
  inline void set_pub_name(const ::std::string& value);
  inline void set_pub_name(const char* value);
  inline void set_pub_name(const void* value, size_t size);
  inline ::std::string* mutable_pub_name();
  
  // required bytes pub_key = 2;
  inline bool has_pub_key() const;
  inline void clear_pub_key();
  static const int kPubKeyFieldNumber = 2;
  inline const ::std::string& pub_key() const;
  inline void set_pub_key(const ::std::string& value);
  inline void set_pub_key(const char* value);
  inline void set_pub_key(const void* value, size_t size);
  inline ::std::string* mutable_pub_key();
  
  // required bytes full_name = 3;
  inline bool has_full_name() const;
  inline void clear_full_name();
  static const int kFullNameFieldNumber = 3;
  inline const ::std::string& full_name() const;
  inline void set_full_name(const ::std::string& value);
  inline void set_full_name(const char* value);
  inline void set_full_name(const void* value, size_t size);
  inline ::std::string* mutable_full_name();
  
  // required bytes office_phone = 4;
  inline bool has_office_phone() const;
  inline void clear_office_phone();
  static const int kOfficePhoneFieldNumber = 4;
  inline const ::std::string& office_phone() const;
  inline void set_office_phone(const ::std::string& value);
  inline void set_office_phone(const char* value);
  inline void set_office_phone(const void* value, size_t size);
  inline ::std::string* mutable_office_phone();
  
  // required bytes birthday = 5;
  inline bool has_birthday() const;
  inline void clear_birthday();
  static const int kBirthdayFieldNumber = 5;
  inline const ::std::string& birthday() const;
  inline void set_birthday(const ::std::string& value);
  inline void set_birthday(const char* value);
  inline void set_birthday(const void* value, size_t size);
  inline ::std::string* mutable_birthday();
  
  // required bytes gender = 6;
  inline bool has_gender() const;
  inline void clear_gender();
  static const int kGenderFieldNumber = 6;
  inline const ::std::string& gender() const;
  inline void set_gender(const ::std::string& value);
  inline void set_gender(const char* value);
  inline void set_gender(const void* value, size_t size);
  inline ::std::string* mutable_gender();
  
  // required int32 language = 7;
  inline bool has_language() const;
  inline void clear_language();
  static const int kLanguageFieldNumber = 7;
  inline ::google::protobuf::int32 language() const;
  inline void set_language(::google::protobuf::int32 value);
  
  // required int32 country = 8;
  inline bool has_country() const;
  inline void clear_country();
  static const int kCountryFieldNumber = 8;
  inline ::google::protobuf::int32 country() const;
  inline void set_country(::google::protobuf::int32 value);
  
  // required bytes city = 9;
  inline bool has_city() const;
  inline void clear_city();
  static const int kCityFieldNumber = 9;
  inline const ::std::string& city() const;
  inline void set_city(const ::std::string& value);
  inline void set_city(const char* value);
  inline void set_city(const void* value, size_t size);
  inline ::std::string* mutable_city();
  
  // required bytes confirmed = 10;
  inline bool has_confirmed() const;
  inline void clear_confirmed();
  static const int kConfirmedFieldNumber = 10;
  inline const ::std::string& confirmed() const;
  inline void set_confirmed(const ::std::string& value);
  inline void set_confirmed(const char* value);
  inline void set_confirmed(const void* value, size_t size);
  inline ::std::string* mutable_confirmed();
  
  // required int32 rank = 11;
  inline bool has_rank() const;
  inline void clear_rank();
  static const int kRankFieldNumber = 11;
  inline ::google::protobuf::int32 rank() const;
  inline void set_rank(::google::protobuf::int32 value);
  
  // required int32 last_contact = 12;
  inline bool has_last_contact() const;
  inline void clear_last_contact();
  static const int kLastContactFieldNumber = 12;
  inline ::google::protobuf::int32 last_contact() const;
  inline void set_last_contact(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* pub_name_;
  static const ::std::string _default_pub_name_;
  ::std::string* pub_key_;
  static const ::std::string _default_pub_key_;
  ::std::string* full_name_;
  static const ::std::string _default_full_name_;
  ::std::string* office_phone_;
  static const ::std::string _default_office_phone_;
  ::std::string* birthday_;
  static const ::std::string _default_birthday_;
  ::std::string* gender_;
  static const ::std::string _default_gender_;
  ::google::protobuf::int32 language_;
  ::google::protobuf::int32 country_;
  ::std::string* city_;
  static const ::std::string _default_city_;
  ::std::string* confirmed_;
  static const ::std::string _default_confirmed_;
  ::google::protobuf::int32 rank_;
  ::google::protobuf::int32 last_contact_;
  friend void  protobuf_AddDesc_datamaps_2eproto();
  friend void protobuf_AssignDesc_datamaps_2eproto();
  friend void protobuf_ShutdownFile_datamaps_2eproto();
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static PublicContact* default_instance_;
};
// -------------------------------------------------------------------

class ShareParticipant : public ::google::protobuf::Message {
 public:
  ShareParticipant();
  virtual ~ShareParticipant();
  
  ShareParticipant(const ShareParticipant& from);
  
  inline ShareParticipant& operator=(const ShareParticipant& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ShareParticipant& default_instance();
  void Swap(ShareParticipant* other);
  
  // implements Message ----------------------------------------------
  
  ShareParticipant* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ShareParticipant& from);
  void MergeFrom(const ShareParticipant& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes public_name = 1;
  inline bool has_public_name() const;
  inline void clear_public_name();
  static const int kPublicNameFieldNumber = 1;
  inline const ::std::string& public_name() const;
  inline void set_public_name(const ::std::string& value);
  inline void set_public_name(const char* value);
  inline void set_public_name(const void* value, size_t size);
  inline ::std::string* mutable_public_name();
  
  // optional bytes public_name_pub_key = 2;
  inline bool has_public_name_pub_key() const;
  inline void clear_public_name_pub_key();
  static const int kPublicNamePubKeyFieldNumber = 2;
  inline const ::std::string& public_name_pub_key() const;
  inline void set_public_name_pub_key(const ::std::string& value);
  inline void set_public_name_pub_key(const char* value);
  inline void set_public_name_pub_key(const void* value, size_t size);
  inline ::std::string* mutable_public_name_pub_key();
  
  // required bytes role = 3;
  inline bool has_role() const;
  inline void clear_role();
  static const int kRoleFieldNumber = 3;
  inline const ::std::string& role() const;
  inline void set_role(const ::std::string& value);
  inline void set_role(const char* value);
  inline void set_role(const void* value, size_t size);
  inline ::std::string* mutable_role();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* public_name_;
  static const ::std::string _default_public_name_;
  ::std::string* public_name_pub_key_;
  static const ::std::string _default_public_name_pub_key_;
  ::std::string* role_;
  static const ::std::string _default_role_;
  friend void  protobuf_AddDesc_datamaps_2eproto();
  friend void protobuf_AssignDesc_datamaps_2eproto();
  friend void protobuf_ShutdownFile_datamaps_2eproto();
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ShareParticipant* default_instance_;
};
// -------------------------------------------------------------------

class Share : public ::google::protobuf::Message {
 public:
  Share();
  virtual ~Share();
  
  Share(const Share& from);
  
  inline Share& operator=(const Share& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Share& default_instance();
  void Swap(Share* other);
  
  // implements Message ----------------------------------------------
  
  Share* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Share& from);
  void MergeFrom(const Share& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const void* value, size_t size);
  inline ::std::string* mutable_name();
  
  // required bytes msid = 2;
  inline bool has_msid() const;
  inline void clear_msid();
  static const int kMsidFieldNumber = 2;
  inline const ::std::string& msid() const;
  inline void set_msid(const ::std::string& value);
  inline void set_msid(const char* value);
  inline void set_msid(const void* value, size_t size);
  inline ::std::string* mutable_msid();
  
  // required bytes msid_pub_key = 3;
  inline bool has_msid_pub_key() const;
  inline void clear_msid_pub_key();
  static const int kMsidPubKeyFieldNumber = 3;
  inline const ::std::string& msid_pub_key() const;
  inline void set_msid_pub_key(const ::std::string& value);
  inline void set_msid_pub_key(const char* value);
  inline void set_msid_pub_key(const void* value, size_t size);
  inline ::std::string* mutable_msid_pub_key();
  
  // optional bytes msid_pri_key = 4;
  inline bool has_msid_pri_key() const;
  inline void clear_msid_pri_key();
  static const int kMsidPriKeyFieldNumber = 4;
  inline const ::std::string& msid_pri_key() const;
  inline void set_msid_pri_key(const ::std::string& value);
  inline void set_msid_pri_key(const char* value);
  inline void set_msid_pri_key(const void* value, size_t size);
  inline ::std::string* mutable_msid_pri_key();
  
  // repeated .maidsafe.ShareParticipant participants = 5;
  inline int participants_size() const;
  inline void clear_participants();
  static const int kParticipantsFieldNumber = 5;
  inline const ::google::protobuf::RepeatedPtrField< ::maidsafe::ShareParticipant >& participants() const;
  inline ::google::protobuf::RepeatedPtrField< ::maidsafe::ShareParticipant >* mutable_participants();
  inline const ::maidsafe::ShareParticipant& participants(int index) const;
  inline ::maidsafe::ShareParticipant* mutable_participants(int index);
  inline ::maidsafe::ShareParticipant* add_participants();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::std::string* msid_;
  static const ::std::string _default_msid_;
  ::std::string* msid_pub_key_;
  static const ::std::string _default_msid_pub_key_;
  ::std::string* msid_pri_key_;
  static const ::std::string _default_msid_pri_key_;
  ::google::protobuf::RepeatedPtrField< ::maidsafe::ShareParticipant > participants_;
  friend void  protobuf_AddDesc_datamaps_2eproto();
  friend void protobuf_AssignDesc_datamaps_2eproto();
  friend void protobuf_ShutdownFile_datamaps_2eproto();
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Share* default_instance_;
};
// -------------------------------------------------------------------

class Key : public ::google::protobuf::Message {
 public:
  Key();
  virtual ~Key();
  
  Key(const Key& from);
  
  inline Key& operator=(const Key& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Key& default_instance();
  void Swap(Key* other);
  
  // implements Message ----------------------------------------------
  
  Key* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Key& from);
  void MergeFrom(const Key& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const void* value, size_t size);
  inline ::std::string* mutable_id();
  
  // required .maidsafe.PacketType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline maidsafe::PacketType type() const;
  inline void set_type(maidsafe::PacketType value);
  
  // required bytes private_key = 3;
  inline bool has_private_key() const;
  inline void clear_private_key();
  static const int kPrivateKeyFieldNumber = 3;
  inline const ::std::string& private_key() const;
  inline void set_private_key(const ::std::string& value);
  inline void set_private_key(const char* value);
  inline void set_private_key(const void* value, size_t size);
  inline ::std::string* mutable_private_key();
  
  // required bytes public_key = 4;
  inline bool has_public_key() const;
  inline void clear_public_key();
  static const int kPublicKeyFieldNumber = 4;
  inline const ::std::string& public_key() const;
  inline void set_public_key(const ::std::string& value);
  inline void set_public_key(const char* value);
  inline void set_public_key(const void* value, size_t size);
  inline ::std::string* mutable_public_key();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* id_;
  static const ::std::string _default_id_;
  int type_;
  ::std::string* private_key_;
  static const ::std::string _default_private_key_;
  ::std::string* public_key_;
  static const ::std::string _default_public_key_;
  friend void  protobuf_AddDesc_datamaps_2eproto();
  friend void protobuf_AssignDesc_datamaps_2eproto();
  friend void protobuf_ShutdownFile_datamaps_2eproto();
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Key* default_instance_;
};
// -------------------------------------------------------------------

class DataMap : public ::google::protobuf::Message {
 public:
  DataMap();
  virtual ~DataMap();
  
  DataMap(const DataMap& from);
  
  inline DataMap& operator=(const DataMap& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DataMap& default_instance();
  void Swap(DataMap* other);
  
  // implements Message ----------------------------------------------
  
  DataMap* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DataMap& from);
  void MergeFrom(const DataMap& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes file_hash = 1;
  inline bool has_file_hash() const;
  inline void clear_file_hash();
  static const int kFileHashFieldNumber = 1;
  inline const ::std::string& file_hash() const;
  inline void set_file_hash(const ::std::string& value);
  inline void set_file_hash(const char* value);
  inline void set_file_hash(const void* value, size_t size);
  inline ::std::string* mutable_file_hash();
  
  // optional bytes se_version = 2;
  inline bool has_se_version() const;
  inline void clear_se_version();
  static const int kSeVersionFieldNumber = 2;
  inline const ::std::string& se_version() const;
  inline void set_se_version(const ::std::string& value);
  inline void set_se_version(const char* value);
  inline void set_se_version(const void* value, size_t size);
  inline ::std::string* mutable_se_version();
  
  // repeated bytes chunk_name = 3;
  inline int chunk_name_size() const;
  inline void clear_chunk_name();
  static const int kChunkNameFieldNumber = 3;
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& chunk_name() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_chunk_name();
  inline const ::std::string& chunk_name(int index) const;
  inline ::std::string* mutable_chunk_name(int index);
  inline void set_chunk_name(int index, const ::std::string& value);
  inline void set_chunk_name(int index, const char* value);
  inline void set_chunk_name(int index, const void* value, size_t size);
  inline ::std::string* add_chunk_name();
  inline void add_chunk_name(const ::std::string& value);
  inline void add_chunk_name(const char* value);
  inline void add_chunk_name(const void* value, size_t size);
  
  // repeated bytes encrypted_chunk_name = 4;
  inline int encrypted_chunk_name_size() const;
  inline void clear_encrypted_chunk_name();
  static const int kEncryptedChunkNameFieldNumber = 4;
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& encrypted_chunk_name() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_encrypted_chunk_name();
  inline const ::std::string& encrypted_chunk_name(int index) const;
  inline ::std::string* mutable_encrypted_chunk_name(int index);
  inline void set_encrypted_chunk_name(int index, const ::std::string& value);
  inline void set_encrypted_chunk_name(int index, const char* value);
  inline void set_encrypted_chunk_name(int index, const void* value, size_t size);
  inline ::std::string* add_encrypted_chunk_name();
  inline void add_encrypted_chunk_name(const ::std::string& value);
  inline void add_encrypted_chunk_name(const char* value);
  inline void add_encrypted_chunk_name(const void* value, size_t size);
  
  // repeated uint64 chunk_size = 5;
  inline int chunk_size_size() const;
  inline void clear_chunk_size();
  static const int kChunkSizeFieldNumber = 5;
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >& chunk_size() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >* mutable_chunk_size();
  inline ::google::protobuf::uint64 chunk_size(int index) const;
  inline void set_chunk_size(int index, ::google::protobuf::uint64 value);
  inline void add_chunk_size(::google::protobuf::uint64 value);
  
  // optional bool compression_on = 6 [default = false];
  inline bool has_compression_on() const;
  inline void clear_compression_on();
  static const int kCompressionOnFieldNumber = 6;
  inline bool compression_on() const;
  inline void set_compression_on(bool value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* file_hash_;
  static const ::std::string _default_file_hash_;
  ::std::string* se_version_;
  static const ::std::string _default_se_version_;
  ::google::protobuf::RepeatedPtrField< ::std::string> chunk_name_;
  ::google::protobuf::RepeatedPtrField< ::std::string> encrypted_chunk_name_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > chunk_size_;
  bool compression_on_;
  friend void  protobuf_AddDesc_datamaps_2eproto();
  friend void protobuf_AssignDesc_datamaps_2eproto();
  friend void protobuf_ShutdownFile_datamaps_2eproto();
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static DataMap* default_instance_;
};
// -------------------------------------------------------------------

class MetaDataMap : public ::google::protobuf::Message {
 public:
  MetaDataMap();
  virtual ~MetaDataMap();
  
  MetaDataMap(const MetaDataMap& from);
  
  inline MetaDataMap& operator=(const MetaDataMap& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MetaDataMap& default_instance();
  void Swap(MetaDataMap* other);
  
  // implements Message ----------------------------------------------
  
  MetaDataMap* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MetaDataMap& from);
  void MergeFrom(const MetaDataMap& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // required bytes display_name = 2;
  inline bool has_display_name() const;
  inline void clear_display_name();
  static const int kDisplayNameFieldNumber = 2;
  inline const ::std::string& display_name() const;
  inline void set_display_name(const ::std::string& value);
  inline void set_display_name(const char* value);
  inline void set_display_name(const void* value, size_t size);
  inline ::std::string* mutable_display_name();
  
  // required .maidsafe.itemtype type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline maidsafe::itemtype type() const;
  inline void set_type(maidsafe::itemtype value);
  
  // repeated bytes file_hash = 4;
  inline int file_hash_size() const;
  inline void clear_file_hash();
  static const int kFileHashFieldNumber = 4;
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& file_hash() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_file_hash();
  inline const ::std::string& file_hash(int index) const;
  inline ::std::string* mutable_file_hash(int index);
  inline void set_file_hash(int index, const ::std::string& value);
  inline void set_file_hash(int index, const char* value);
  inline void set_file_hash(int index, const void* value, size_t size);
  inline ::std::string* add_file_hash();
  inline void add_file_hash(const ::std::string& value);
  inline void add_file_hash(const char* value);
  inline void add_file_hash(const void* value, size_t size);
  
  // optional bytes stats = 5;
  inline bool has_stats() const;
  inline void clear_stats();
  static const int kStatsFieldNumber = 5;
  inline const ::std::string& stats() const;
  inline void set_stats(const ::std::string& value);
  inline void set_stats(const char* value);
  inline void set_stats(const void* value, size_t size);
  inline ::std::string* mutable_stats();
  
  // optional bytes tag = 6;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 6;
  inline const ::std::string& tag() const;
  inline void set_tag(const ::std::string& value);
  inline void set_tag(const char* value);
  inline void set_tag(const void* value, size_t size);
  inline ::std::string* mutable_tag();
  
  // optional int32 file_size_high = 7;
  inline bool has_file_size_high() const;
  inline void clear_file_size_high();
  static const int kFileSizeHighFieldNumber = 7;
  inline ::google::protobuf::int32 file_size_high() const;
  inline void set_file_size_high(::google::protobuf::int32 value);
  
  // optional int32 file_size_low = 8;
  inline bool has_file_size_low() const;
  inline void clear_file_size_low();
  static const int kFileSizeLowFieldNumber = 8;
  inline ::google::protobuf::int32 file_size_low() const;
  inline void set_file_size_low(::google::protobuf::int32 value);
  
  // optional int32 creation_time = 9;
  inline bool has_creation_time() const;
  inline void clear_creation_time();
  static const int kCreationTimeFieldNumber = 9;
  inline ::google::protobuf::int32 creation_time() const;
  inline void set_creation_time(::google::protobuf::int32 value);
  
  // optional int32 last_modified = 10;
  inline bool has_last_modified() const;
  inline void clear_last_modified();
  static const int kLastModifiedFieldNumber = 10;
  inline ::google::protobuf::int32 last_modified() const;
  inline void set_last_modified(::google::protobuf::int32 value);
  
  // optional int32 last_access = 11;
  inline bool has_last_access() const;
  inline void clear_last_access();
  static const int kLastAccessFieldNumber = 11;
  inline ::google::protobuf::int32 last_access() const;
  inline void set_last_access(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 id_;
  ::std::string* display_name_;
  static const ::std::string _default_display_name_;
  int type_;
  ::google::protobuf::RepeatedPtrField< ::std::string> file_hash_;
  ::std::string* stats_;
  static const ::std::string _default_stats_;
  ::std::string* tag_;
  static const ::std::string _default_tag_;
  ::google::protobuf::int32 file_size_high_;
  ::google::protobuf::int32 file_size_low_;
  ::google::protobuf::int32 creation_time_;
  ::google::protobuf::int32 last_modified_;
  ::google::protobuf::int32 last_access_;
  friend void  protobuf_AddDesc_datamaps_2eproto();
  friend void protobuf_AssignDesc_datamaps_2eproto();
  friend void protobuf_ShutdownFile_datamaps_2eproto();
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MetaDataMap* default_instance_;
};
// -------------------------------------------------------------------

class Chunk : public ::google::protobuf::Message {
 public:
  Chunk();
  virtual ~Chunk();
  
  Chunk(const Chunk& from);
  
  inline Chunk& operator=(const Chunk& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Chunk& default_instance();
  void Swap(Chunk* other);
  
  // implements Message ----------------------------------------------
  
  Chunk* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Chunk& from);
  void MergeFrom(const Chunk& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bytes compression_type = 1;
  inline bool has_compression_type() const;
  inline void clear_compression_type();
  static const int kCompressionTypeFieldNumber = 1;
  inline const ::std::string& compression_type() const;
  inline void set_compression_type(const ::std::string& value);
  inline void set_compression_type(const char* value);
  inline void set_compression_type(const void* value, size_t size);
  inline ::std::string* mutable_compression_type();
  
  // repeated bytes chunklet = 2;
  inline int chunklet_size() const;
  inline void clear_chunklet();
  static const int kChunkletFieldNumber = 2;
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& chunklet() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_chunklet();
  inline const ::std::string& chunklet(int index) const;
  inline ::std::string* mutable_chunklet(int index);
  inline void set_chunklet(int index, const ::std::string& value);
  inline void set_chunklet(int index, const char* value);
  inline void set_chunklet(int index, const void* value, size_t size);
  inline ::std::string* add_chunklet();
  inline void add_chunklet(const ::std::string& value);
  inline void add_chunklet(const char* value);
  inline void add_chunklet(const void* value, size_t size);
  
  // repeated int32 pre_compression_chunklet_size = 3;
  inline int pre_compression_chunklet_size_size() const;
  inline void clear_pre_compression_chunklet_size();
  static const int kPreCompressionChunkletSizeFieldNumber = 3;
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >& pre_compression_chunklet_size() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >* mutable_pre_compression_chunklet_size();
  inline ::google::protobuf::int32 pre_compression_chunklet_size(int index) const;
  inline void set_pre_compression_chunklet_size(int index, ::google::protobuf::int32 value);
  inline void add_pre_compression_chunklet_size(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* compression_type_;
  static const ::std::string _default_compression_type_;
  ::google::protobuf::RepeatedPtrField< ::std::string> chunklet_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > pre_compression_chunklet_size_;
  friend void  protobuf_AddDesc_datamaps_2eproto();
  friend void protobuf_AssignDesc_datamaps_2eproto();
  friend void protobuf_ShutdownFile_datamaps_2eproto();
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Chunk* default_instance_;
};
// -------------------------------------------------------------------

class DataAtlas : public ::google::protobuf::Message {
 public:
  DataAtlas();
  virtual ~DataAtlas();
  
  DataAtlas(const DataAtlas& from);
  
  inline DataAtlas& operator=(const DataAtlas& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DataAtlas& default_instance();
  void Swap(DataAtlas* other);
  
  // implements Message ----------------------------------------------
  
  DataAtlas* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DataAtlas& from);
  void MergeFrom(const DataAtlas& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bytes root_db_key = 1;
  inline bool has_root_db_key() const;
  inline void clear_root_db_key();
  static const int kRootDbKeyFieldNumber = 1;
  inline const ::std::string& root_db_key() const;
  inline void set_root_db_key(const ::std::string& value);
  inline void set_root_db_key(const char* value);
  inline void set_root_db_key(const void* value, size_t size);
  inline ::std::string* mutable_root_db_key();
  
  // repeated .maidsafe.Key keys = 2;
  inline int keys_size() const;
  inline void clear_keys();
  static const int kKeysFieldNumber = 2;
  inline const ::google::protobuf::RepeatedPtrField< ::maidsafe::Key >& keys() const;
  inline ::google::protobuf::RepeatedPtrField< ::maidsafe::Key >* mutable_keys();
  inline const ::maidsafe::Key& keys(int index) const;
  inline ::maidsafe::Key* mutable_keys(int index);
  inline ::maidsafe::Key* add_keys();
  
  // repeated .maidsafe.MetaDataMap mdms = 3;
  inline int mdms_size() const;
  inline void clear_mdms();
  static const int kMdmsFieldNumber = 3;
  inline const ::google::protobuf::RepeatedPtrField< ::maidsafe::MetaDataMap >& mdms() const;
  inline ::google::protobuf::RepeatedPtrField< ::maidsafe::MetaDataMap >* mutable_mdms();
  inline const ::maidsafe::MetaDataMap& mdms(int index) const;
  inline ::maidsafe::MetaDataMap* mutable_mdms(int index);
  inline ::maidsafe::MetaDataMap* add_mdms();
  
  // repeated .maidsafe.DataMap dms = 4;
  inline int dms_size() const;
  inline void clear_dms();
  static const int kDmsFieldNumber = 4;
  inline const ::google::protobuf::RepeatedPtrField< ::maidsafe::DataMap >& dms() const;
  inline ::google::protobuf::RepeatedPtrField< ::maidsafe::DataMap >* mutable_dms();
  inline const ::maidsafe::DataMap& dms(int index) const;
  inline ::maidsafe::DataMap* mutable_dms(int index);
  inline ::maidsafe::DataMap* add_dms();
  
  // repeated .maidsafe.PublicContact contacts = 5;
  inline int contacts_size() const;
  inline void clear_contacts();
  static const int kContactsFieldNumber = 5;
  inline const ::google::protobuf::RepeatedPtrField< ::maidsafe::PublicContact >& contacts() const;
  inline ::google::protobuf::RepeatedPtrField< ::maidsafe::PublicContact >* mutable_contacts();
  inline const ::maidsafe::PublicContact& contacts(int index) const;
  inline ::maidsafe::PublicContact* mutable_contacts(int index);
  inline ::maidsafe::PublicContact* add_contacts();
  
  // repeated .maidsafe.Share shares = 6;
  inline int shares_size() const;
  inline void clear_shares();
  static const int kSharesFieldNumber = 6;
  inline const ::google::protobuf::RepeatedPtrField< ::maidsafe::Share >& shares() const;
  inline ::google::protobuf::RepeatedPtrField< ::maidsafe::Share >* mutable_shares();
  inline const ::maidsafe::Share& shares(int index) const;
  inline ::maidsafe::Share* mutable_shares(int index);
  inline ::maidsafe::Share* add_shares();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* root_db_key_;
  static const ::std::string _default_root_db_key_;
  ::google::protobuf::RepeatedPtrField< ::maidsafe::Key > keys_;
  ::google::protobuf::RepeatedPtrField< ::maidsafe::MetaDataMap > mdms_;
  ::google::protobuf::RepeatedPtrField< ::maidsafe::DataMap > dms_;
  ::google::protobuf::RepeatedPtrField< ::maidsafe::PublicContact > contacts_;
  ::google::protobuf::RepeatedPtrField< ::maidsafe::Share > shares_;
  friend void  protobuf_AddDesc_datamaps_2eproto();
  friend void protobuf_AssignDesc_datamaps_2eproto();
  friend void protobuf_ShutdownFile_datamaps_2eproto();
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static DataAtlas* default_instance_;
};
// ===================================================================


// ===================================================================


// ===================================================================

// PublicContact

// required bytes pub_name = 1;
inline bool PublicContact::has_pub_name() const {
  return _has_bit(0);
}
inline void PublicContact::clear_pub_name() {
  if (pub_name_ != &_default_pub_name_) {
    pub_name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& PublicContact::pub_name() const {
  return *pub_name_;
}
inline void PublicContact::set_pub_name(const ::std::string& value) {
  _set_bit(0);
  if (pub_name_ == &_default_pub_name_) {
    pub_name_ = new ::std::string;
  }
  pub_name_->assign(value);
}
inline void PublicContact::set_pub_name(const char* value) {
  _set_bit(0);
  if (pub_name_ == &_default_pub_name_) {
    pub_name_ = new ::std::string;
  }
  pub_name_->assign(value);
}
inline void PublicContact::set_pub_name(const void* value, size_t size) {
  _set_bit(0);
  if (pub_name_ == &_default_pub_name_) {
    pub_name_ = new ::std::string;
  }
  pub_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PublicContact::mutable_pub_name() {
  _set_bit(0);
  if (pub_name_ == &_default_pub_name_) {
    pub_name_ = new ::std::string;
  }
  return pub_name_;
}

// required bytes pub_key = 2;
inline bool PublicContact::has_pub_key() const {
  return _has_bit(1);
}
inline void PublicContact::clear_pub_key() {
  if (pub_key_ != &_default_pub_key_) {
    pub_key_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& PublicContact::pub_key() const {
  return *pub_key_;
}
inline void PublicContact::set_pub_key(const ::std::string& value) {
  _set_bit(1);
  if (pub_key_ == &_default_pub_key_) {
    pub_key_ = new ::std::string;
  }
  pub_key_->assign(value);
}
inline void PublicContact::set_pub_key(const char* value) {
  _set_bit(1);
  if (pub_key_ == &_default_pub_key_) {
    pub_key_ = new ::std::string;
  }
  pub_key_->assign(value);
}
inline void PublicContact::set_pub_key(const void* value, size_t size) {
  _set_bit(1);
  if (pub_key_ == &_default_pub_key_) {
    pub_key_ = new ::std::string;
  }
  pub_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PublicContact::mutable_pub_key() {
  _set_bit(1);
  if (pub_key_ == &_default_pub_key_) {
    pub_key_ = new ::std::string;
  }
  return pub_key_;
}

// required bytes full_name = 3;
inline bool PublicContact::has_full_name() const {
  return _has_bit(2);
}
inline void PublicContact::clear_full_name() {
  if (full_name_ != &_default_full_name_) {
    full_name_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& PublicContact::full_name() const {
  return *full_name_;
}
inline void PublicContact::set_full_name(const ::std::string& value) {
  _set_bit(2);
  if (full_name_ == &_default_full_name_) {
    full_name_ = new ::std::string;
  }
  full_name_->assign(value);
}
inline void PublicContact::set_full_name(const char* value) {
  _set_bit(2);
  if (full_name_ == &_default_full_name_) {
    full_name_ = new ::std::string;
  }
  full_name_->assign(value);
}
inline void PublicContact::set_full_name(const void* value, size_t size) {
  _set_bit(2);
  if (full_name_ == &_default_full_name_) {
    full_name_ = new ::std::string;
  }
  full_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PublicContact::mutable_full_name() {
  _set_bit(2);
  if (full_name_ == &_default_full_name_) {
    full_name_ = new ::std::string;
  }
  return full_name_;
}

// required bytes office_phone = 4;
inline bool PublicContact::has_office_phone() const {
  return _has_bit(3);
}
inline void PublicContact::clear_office_phone() {
  if (office_phone_ != &_default_office_phone_) {
    office_phone_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& PublicContact::office_phone() const {
  return *office_phone_;
}
inline void PublicContact::set_office_phone(const ::std::string& value) {
  _set_bit(3);
  if (office_phone_ == &_default_office_phone_) {
    office_phone_ = new ::std::string;
  }
  office_phone_->assign(value);
}
inline void PublicContact::set_office_phone(const char* value) {
  _set_bit(3);
  if (office_phone_ == &_default_office_phone_) {
    office_phone_ = new ::std::string;
  }
  office_phone_->assign(value);
}
inline void PublicContact::set_office_phone(const void* value, size_t size) {
  _set_bit(3);
  if (office_phone_ == &_default_office_phone_) {
    office_phone_ = new ::std::string;
  }
  office_phone_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PublicContact::mutable_office_phone() {
  _set_bit(3);
  if (office_phone_ == &_default_office_phone_) {
    office_phone_ = new ::std::string;
  }
  return office_phone_;
}

// required bytes birthday = 5;
inline bool PublicContact::has_birthday() const {
  return _has_bit(4);
}
inline void PublicContact::clear_birthday() {
  if (birthday_ != &_default_birthday_) {
    birthday_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& PublicContact::birthday() const {
  return *birthday_;
}
inline void PublicContact::set_birthday(const ::std::string& value) {
  _set_bit(4);
  if (birthday_ == &_default_birthday_) {
    birthday_ = new ::std::string;
  }
  birthday_->assign(value);
}
inline void PublicContact::set_birthday(const char* value) {
  _set_bit(4);
  if (birthday_ == &_default_birthday_) {
    birthday_ = new ::std::string;
  }
  birthday_->assign(value);
}
inline void PublicContact::set_birthday(const void* value, size_t size) {
  _set_bit(4);
  if (birthday_ == &_default_birthday_) {
    birthday_ = new ::std::string;
  }
  birthday_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PublicContact::mutable_birthday() {
  _set_bit(4);
  if (birthday_ == &_default_birthday_) {
    birthday_ = new ::std::string;
  }
  return birthday_;
}

// required bytes gender = 6;
inline bool PublicContact::has_gender() const {
  return _has_bit(5);
}
inline void PublicContact::clear_gender() {
  if (gender_ != &_default_gender_) {
    gender_->clear();
  }
  _clear_bit(5);
}
inline const ::std::string& PublicContact::gender() const {
  return *gender_;
}
inline void PublicContact::set_gender(const ::std::string& value) {
  _set_bit(5);
  if (gender_ == &_default_gender_) {
    gender_ = new ::std::string;
  }
  gender_->assign(value);
}
inline void PublicContact::set_gender(const char* value) {
  _set_bit(5);
  if (gender_ == &_default_gender_) {
    gender_ = new ::std::string;
  }
  gender_->assign(value);
}
inline void PublicContact::set_gender(const void* value, size_t size) {
  _set_bit(5);
  if (gender_ == &_default_gender_) {
    gender_ = new ::std::string;
  }
  gender_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PublicContact::mutable_gender() {
  _set_bit(5);
  if (gender_ == &_default_gender_) {
    gender_ = new ::std::string;
  }
  return gender_;
}

// required int32 language = 7;
inline bool PublicContact::has_language() const {
  return _has_bit(6);
}
inline void PublicContact::clear_language() {
  language_ = 0;
  _clear_bit(6);
}
inline ::google::protobuf::int32 PublicContact::language() const {
  return language_;
}
inline void PublicContact::set_language(::google::protobuf::int32 value) {
  _set_bit(6);
  language_ = value;
}

// required int32 country = 8;
inline bool PublicContact::has_country() const {
  return _has_bit(7);
}
inline void PublicContact::clear_country() {
  country_ = 0;
  _clear_bit(7);
}
inline ::google::protobuf::int32 PublicContact::country() const {
  return country_;
}
inline void PublicContact::set_country(::google::protobuf::int32 value) {
  _set_bit(7);
  country_ = value;
}

// required bytes city = 9;
inline bool PublicContact::has_city() const {
  return _has_bit(8);
}
inline void PublicContact::clear_city() {
  if (city_ != &_default_city_) {
    city_->clear();
  }
  _clear_bit(8);
}
inline const ::std::string& PublicContact::city() const {
  return *city_;
}
inline void PublicContact::set_city(const ::std::string& value) {
  _set_bit(8);
  if (city_ == &_default_city_) {
    city_ = new ::std::string;
  }
  city_->assign(value);
}
inline void PublicContact::set_city(const char* value) {
  _set_bit(8);
  if (city_ == &_default_city_) {
    city_ = new ::std::string;
  }
  city_->assign(value);
}
inline void PublicContact::set_city(const void* value, size_t size) {
  _set_bit(8);
  if (city_ == &_default_city_) {
    city_ = new ::std::string;
  }
  city_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PublicContact::mutable_city() {
  _set_bit(8);
  if (city_ == &_default_city_) {
    city_ = new ::std::string;
  }
  return city_;
}

// required bytes confirmed = 10;
inline bool PublicContact::has_confirmed() const {
  return _has_bit(9);
}
inline void PublicContact::clear_confirmed() {
  if (confirmed_ != &_default_confirmed_) {
    confirmed_->clear();
  }
  _clear_bit(9);
}
inline const ::std::string& PublicContact::confirmed() const {
  return *confirmed_;
}
inline void PublicContact::set_confirmed(const ::std::string& value) {
  _set_bit(9);
  if (confirmed_ == &_default_confirmed_) {
    confirmed_ = new ::std::string;
  }
  confirmed_->assign(value);
}
inline void PublicContact::set_confirmed(const char* value) {
  _set_bit(9);
  if (confirmed_ == &_default_confirmed_) {
    confirmed_ = new ::std::string;
  }
  confirmed_->assign(value);
}
inline void PublicContact::set_confirmed(const void* value, size_t size) {
  _set_bit(9);
  if (confirmed_ == &_default_confirmed_) {
    confirmed_ = new ::std::string;
  }
  confirmed_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PublicContact::mutable_confirmed() {
  _set_bit(9);
  if (confirmed_ == &_default_confirmed_) {
    confirmed_ = new ::std::string;
  }
  return confirmed_;
}

// required int32 rank = 11;
inline bool PublicContact::has_rank() const {
  return _has_bit(10);
}
inline void PublicContact::clear_rank() {
  rank_ = 0;
  _clear_bit(10);
}
inline ::google::protobuf::int32 PublicContact::rank() const {
  return rank_;
}
inline void PublicContact::set_rank(::google::protobuf::int32 value) {
  _set_bit(10);
  rank_ = value;
}

// required int32 last_contact = 12;
inline bool PublicContact::has_last_contact() const {
  return _has_bit(11);
}
inline void PublicContact::clear_last_contact() {
  last_contact_ = 0;
  _clear_bit(11);
}
inline ::google::protobuf::int32 PublicContact::last_contact() const {
  return last_contact_;
}
inline void PublicContact::set_last_contact(::google::protobuf::int32 value) {
  _set_bit(11);
  last_contact_ = value;
}

// -------------------------------------------------------------------

// ShareParticipant

// required bytes public_name = 1;
inline bool ShareParticipant::has_public_name() const {
  return _has_bit(0);
}
inline void ShareParticipant::clear_public_name() {
  if (public_name_ != &_default_public_name_) {
    public_name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& ShareParticipant::public_name() const {
  return *public_name_;
}
inline void ShareParticipant::set_public_name(const ::std::string& value) {
  _set_bit(0);
  if (public_name_ == &_default_public_name_) {
    public_name_ = new ::std::string;
  }
  public_name_->assign(value);
}
inline void ShareParticipant::set_public_name(const char* value) {
  _set_bit(0);
  if (public_name_ == &_default_public_name_) {
    public_name_ = new ::std::string;
  }
  public_name_->assign(value);
}
inline void ShareParticipant::set_public_name(const void* value, size_t size) {
  _set_bit(0);
  if (public_name_ == &_default_public_name_) {
    public_name_ = new ::std::string;
  }
  public_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ShareParticipant::mutable_public_name() {
  _set_bit(0);
  if (public_name_ == &_default_public_name_) {
    public_name_ = new ::std::string;
  }
  return public_name_;
}

// optional bytes public_name_pub_key = 2;
inline bool ShareParticipant::has_public_name_pub_key() const {
  return _has_bit(1);
}
inline void ShareParticipant::clear_public_name_pub_key() {
  if (public_name_pub_key_ != &_default_public_name_pub_key_) {
    public_name_pub_key_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& ShareParticipant::public_name_pub_key() const {
  return *public_name_pub_key_;
}
inline void ShareParticipant::set_public_name_pub_key(const ::std::string& value) {
  _set_bit(1);
  if (public_name_pub_key_ == &_default_public_name_pub_key_) {
    public_name_pub_key_ = new ::std::string;
  }
  public_name_pub_key_->assign(value);
}
inline void ShareParticipant::set_public_name_pub_key(const char* value) {
  _set_bit(1);
  if (public_name_pub_key_ == &_default_public_name_pub_key_) {
    public_name_pub_key_ = new ::std::string;
  }
  public_name_pub_key_->assign(value);
}
inline void ShareParticipant::set_public_name_pub_key(const void* value, size_t size) {
  _set_bit(1);
  if (public_name_pub_key_ == &_default_public_name_pub_key_) {
    public_name_pub_key_ = new ::std::string;
  }
  public_name_pub_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ShareParticipant::mutable_public_name_pub_key() {
  _set_bit(1);
  if (public_name_pub_key_ == &_default_public_name_pub_key_) {
    public_name_pub_key_ = new ::std::string;
  }
  return public_name_pub_key_;
}

// required bytes role = 3;
inline bool ShareParticipant::has_role() const {
  return _has_bit(2);
}
inline void ShareParticipant::clear_role() {
  if (role_ != &_default_role_) {
    role_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& ShareParticipant::role() const {
  return *role_;
}
inline void ShareParticipant::set_role(const ::std::string& value) {
  _set_bit(2);
  if (role_ == &_default_role_) {
    role_ = new ::std::string;
  }
  role_->assign(value);
}
inline void ShareParticipant::set_role(const char* value) {
  _set_bit(2);
  if (role_ == &_default_role_) {
    role_ = new ::std::string;
  }
  role_->assign(value);
}
inline void ShareParticipant::set_role(const void* value, size_t size) {
  _set_bit(2);
  if (role_ == &_default_role_) {
    role_ = new ::std::string;
  }
  role_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ShareParticipant::mutable_role() {
  _set_bit(2);
  if (role_ == &_default_role_) {
    role_ = new ::std::string;
  }
  return role_;
}

// -------------------------------------------------------------------

// Share

// required bytes name = 1;
inline bool Share::has_name() const {
  return _has_bit(0);
}
inline void Share::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& Share::name() const {
  return *name_;
}
inline void Share::set_name(const ::std::string& value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Share::set_name(const char* value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Share::set_name(const void* value, size_t size) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Share::mutable_name() {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// required bytes msid = 2;
inline bool Share::has_msid() const {
  return _has_bit(1);
}
inline void Share::clear_msid() {
  if (msid_ != &_default_msid_) {
    msid_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& Share::msid() const {
  return *msid_;
}
inline void Share::set_msid(const ::std::string& value) {
  _set_bit(1);
  if (msid_ == &_default_msid_) {
    msid_ = new ::std::string;
  }
  msid_->assign(value);
}
inline void Share::set_msid(const char* value) {
  _set_bit(1);
  if (msid_ == &_default_msid_) {
    msid_ = new ::std::string;
  }
  msid_->assign(value);
}
inline void Share::set_msid(const void* value, size_t size) {
  _set_bit(1);
  if (msid_ == &_default_msid_) {
    msid_ = new ::std::string;
  }
  msid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Share::mutable_msid() {
  _set_bit(1);
  if (msid_ == &_default_msid_) {
    msid_ = new ::std::string;
  }
  return msid_;
}

// required bytes msid_pub_key = 3;
inline bool Share::has_msid_pub_key() const {
  return _has_bit(2);
}
inline void Share::clear_msid_pub_key() {
  if (msid_pub_key_ != &_default_msid_pub_key_) {
    msid_pub_key_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& Share::msid_pub_key() const {
  return *msid_pub_key_;
}
inline void Share::set_msid_pub_key(const ::std::string& value) {
  _set_bit(2);
  if (msid_pub_key_ == &_default_msid_pub_key_) {
    msid_pub_key_ = new ::std::string;
  }
  msid_pub_key_->assign(value);
}
inline void Share::set_msid_pub_key(const char* value) {
  _set_bit(2);
  if (msid_pub_key_ == &_default_msid_pub_key_) {
    msid_pub_key_ = new ::std::string;
  }
  msid_pub_key_->assign(value);
}
inline void Share::set_msid_pub_key(const void* value, size_t size) {
  _set_bit(2);
  if (msid_pub_key_ == &_default_msid_pub_key_) {
    msid_pub_key_ = new ::std::string;
  }
  msid_pub_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Share::mutable_msid_pub_key() {
  _set_bit(2);
  if (msid_pub_key_ == &_default_msid_pub_key_) {
    msid_pub_key_ = new ::std::string;
  }
  return msid_pub_key_;
}

// optional bytes msid_pri_key = 4;
inline bool Share::has_msid_pri_key() const {
  return _has_bit(3);
}
inline void Share::clear_msid_pri_key() {
  if (msid_pri_key_ != &_default_msid_pri_key_) {
    msid_pri_key_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& Share::msid_pri_key() const {
  return *msid_pri_key_;
}
inline void Share::set_msid_pri_key(const ::std::string& value) {
  _set_bit(3);
  if (msid_pri_key_ == &_default_msid_pri_key_) {
    msid_pri_key_ = new ::std::string;
  }
  msid_pri_key_->assign(value);
}
inline void Share::set_msid_pri_key(const char* value) {
  _set_bit(3);
  if (msid_pri_key_ == &_default_msid_pri_key_) {
    msid_pri_key_ = new ::std::string;
  }
  msid_pri_key_->assign(value);
}
inline void Share::set_msid_pri_key(const void* value, size_t size) {
  _set_bit(3);
  if (msid_pri_key_ == &_default_msid_pri_key_) {
    msid_pri_key_ = new ::std::string;
  }
  msid_pri_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Share::mutable_msid_pri_key() {
  _set_bit(3);
  if (msid_pri_key_ == &_default_msid_pri_key_) {
    msid_pri_key_ = new ::std::string;
  }
  return msid_pri_key_;
}

// repeated .maidsafe.ShareParticipant participants = 5;
inline int Share::participants_size() const {
  return participants_.size();
}
inline void Share::clear_participants() {
  participants_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::maidsafe::ShareParticipant >&
Share::participants() const {
  return participants_;
}
inline ::google::protobuf::RepeatedPtrField< ::maidsafe::ShareParticipant >*
Share::mutable_participants() {
  return &participants_;
}
inline const ::maidsafe::ShareParticipant& Share::participants(int index) const {
  return participants_.Get(index);
}
inline ::maidsafe::ShareParticipant* Share::mutable_participants(int index) {
  return participants_.Mutable(index);
}
inline ::maidsafe::ShareParticipant* Share::add_participants() {
  return participants_.Add();
}

// -------------------------------------------------------------------

// Key

// required bytes id = 1;
inline bool Key::has_id() const {
  return _has_bit(0);
}
inline void Key::clear_id() {
  if (id_ != &_default_id_) {
    id_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& Key::id() const {
  return *id_;
}
inline void Key::set_id(const ::std::string& value) {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void Key::set_id(const char* value) {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void Key::set_id(const void* value, size_t size) {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Key::mutable_id() {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  return id_;
}

// required .maidsafe.PacketType type = 2;
inline bool Key::has_type() const {
  return _has_bit(1);
}
inline void Key::clear_type() {
  type_ = 0;
  _clear_bit(1);
}
inline maidsafe::PacketType Key::type() const {
  return static_cast< maidsafe::PacketType >(type_);
}
inline void Key::set_type(maidsafe::PacketType value) {
  GOOGLE_DCHECK(maidsafe::PacketType_IsValid(value));
  _set_bit(1);
  type_ = value;
}

// required bytes private_key = 3;
inline bool Key::has_private_key() const {
  return _has_bit(2);
}
inline void Key::clear_private_key() {
  if (private_key_ != &_default_private_key_) {
    private_key_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& Key::private_key() const {
  return *private_key_;
}
inline void Key::set_private_key(const ::std::string& value) {
  _set_bit(2);
  if (private_key_ == &_default_private_key_) {
    private_key_ = new ::std::string;
  }
  private_key_->assign(value);
}
inline void Key::set_private_key(const char* value) {
  _set_bit(2);
  if (private_key_ == &_default_private_key_) {
    private_key_ = new ::std::string;
  }
  private_key_->assign(value);
}
inline void Key::set_private_key(const void* value, size_t size) {
  _set_bit(2);
  if (private_key_ == &_default_private_key_) {
    private_key_ = new ::std::string;
  }
  private_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Key::mutable_private_key() {
  _set_bit(2);
  if (private_key_ == &_default_private_key_) {
    private_key_ = new ::std::string;
  }
  return private_key_;
}

// required bytes public_key = 4;
inline bool Key::has_public_key() const {
  return _has_bit(3);
}
inline void Key::clear_public_key() {
  if (public_key_ != &_default_public_key_) {
    public_key_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& Key::public_key() const {
  return *public_key_;
}
inline void Key::set_public_key(const ::std::string& value) {
  _set_bit(3);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void Key::set_public_key(const char* value) {
  _set_bit(3);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void Key::set_public_key(const void* value, size_t size) {
  _set_bit(3);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Key::mutable_public_key() {
  _set_bit(3);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  return public_key_;
}

// -------------------------------------------------------------------

// DataMap

// required bytes file_hash = 1;
inline bool DataMap::has_file_hash() const {
  return _has_bit(0);
}
inline void DataMap::clear_file_hash() {
  if (file_hash_ != &_default_file_hash_) {
    file_hash_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& DataMap::file_hash() const {
  return *file_hash_;
}
inline void DataMap::set_file_hash(const ::std::string& value) {
  _set_bit(0);
  if (file_hash_ == &_default_file_hash_) {
    file_hash_ = new ::std::string;
  }
  file_hash_->assign(value);
}
inline void DataMap::set_file_hash(const char* value) {
  _set_bit(0);
  if (file_hash_ == &_default_file_hash_) {
    file_hash_ = new ::std::string;
  }
  file_hash_->assign(value);
}
inline void DataMap::set_file_hash(const void* value, size_t size) {
  _set_bit(0);
  if (file_hash_ == &_default_file_hash_) {
    file_hash_ = new ::std::string;
  }
  file_hash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DataMap::mutable_file_hash() {
  _set_bit(0);
  if (file_hash_ == &_default_file_hash_) {
    file_hash_ = new ::std::string;
  }
  return file_hash_;
}

// optional bytes se_version = 2;
inline bool DataMap::has_se_version() const {
  return _has_bit(1);
}
inline void DataMap::clear_se_version() {
  if (se_version_ != &_default_se_version_) {
    se_version_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& DataMap::se_version() const {
  return *se_version_;
}
inline void DataMap::set_se_version(const ::std::string& value) {
  _set_bit(1);
  if (se_version_ == &_default_se_version_) {
    se_version_ = new ::std::string;
  }
  se_version_->assign(value);
}
inline void DataMap::set_se_version(const char* value) {
  _set_bit(1);
  if (se_version_ == &_default_se_version_) {
    se_version_ = new ::std::string;
  }
  se_version_->assign(value);
}
inline void DataMap::set_se_version(const void* value, size_t size) {
  _set_bit(1);
  if (se_version_ == &_default_se_version_) {
    se_version_ = new ::std::string;
  }
  se_version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DataMap::mutable_se_version() {
  _set_bit(1);
  if (se_version_ == &_default_se_version_) {
    se_version_ = new ::std::string;
  }
  return se_version_;
}

// repeated bytes chunk_name = 3;
inline int DataMap::chunk_name_size() const {
  return chunk_name_.size();
}
inline void DataMap::clear_chunk_name() {
  chunk_name_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
DataMap::chunk_name() const {
  return chunk_name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
DataMap::mutable_chunk_name() {
  return &chunk_name_;
}
inline const ::std::string& DataMap::chunk_name(int index) const {
  return chunk_name_.Get(index);
}
inline ::std::string* DataMap::mutable_chunk_name(int index) {
  return chunk_name_.Mutable(index);
}
inline void DataMap::set_chunk_name(int index, const ::std::string& value) {
  chunk_name_.Mutable(index)->assign(value);
}
inline void DataMap::set_chunk_name(int index, const char* value) {
  chunk_name_.Mutable(index)->assign(value);
}
inline void DataMap::set_chunk_name(int index, const void* value, size_t size) {
  chunk_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DataMap::add_chunk_name() {
  return chunk_name_.Add();
}
inline void DataMap::add_chunk_name(const ::std::string& value) {
  chunk_name_.Add()->assign(value);
}
inline void DataMap::add_chunk_name(const char* value) {
  chunk_name_.Add()->assign(value);
}
inline void DataMap::add_chunk_name(const void* value, size_t size) {
  chunk_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
}

// repeated bytes encrypted_chunk_name = 4;
inline int DataMap::encrypted_chunk_name_size() const {
  return encrypted_chunk_name_.size();
}
inline void DataMap::clear_encrypted_chunk_name() {
  encrypted_chunk_name_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
DataMap::encrypted_chunk_name() const {
  return encrypted_chunk_name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
DataMap::mutable_encrypted_chunk_name() {
  return &encrypted_chunk_name_;
}
inline const ::std::string& DataMap::encrypted_chunk_name(int index) const {
  return encrypted_chunk_name_.Get(index);
}
inline ::std::string* DataMap::mutable_encrypted_chunk_name(int index) {
  return encrypted_chunk_name_.Mutable(index);
}
inline void DataMap::set_encrypted_chunk_name(int index, const ::std::string& value) {
  encrypted_chunk_name_.Mutable(index)->assign(value);
}
inline void DataMap::set_encrypted_chunk_name(int index, const char* value) {
  encrypted_chunk_name_.Mutable(index)->assign(value);
}
inline void DataMap::set_encrypted_chunk_name(int index, const void* value, size_t size) {
  encrypted_chunk_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DataMap::add_encrypted_chunk_name() {
  return encrypted_chunk_name_.Add();
}
inline void DataMap::add_encrypted_chunk_name(const ::std::string& value) {
  encrypted_chunk_name_.Add()->assign(value);
}
inline void DataMap::add_encrypted_chunk_name(const char* value) {
  encrypted_chunk_name_.Add()->assign(value);
}
inline void DataMap::add_encrypted_chunk_name(const void* value, size_t size) {
  encrypted_chunk_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
}

// repeated uint64 chunk_size = 5;
inline int DataMap::chunk_size_size() const {
  return chunk_size_.size();
}
inline void DataMap::clear_chunk_size() {
  chunk_size_.Clear();
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
DataMap::chunk_size() const {
  return chunk_size_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
DataMap::mutable_chunk_size() {
  return &chunk_size_;
}
inline ::google::protobuf::uint64 DataMap::chunk_size(int index) const {
  return chunk_size_.Get(index);
}
inline void DataMap::set_chunk_size(int index, ::google::protobuf::uint64 value) {
  chunk_size_.Set(index, value);
}
inline void DataMap::add_chunk_size(::google::protobuf::uint64 value) {
  chunk_size_.Add(value);
}

// optional bool compression_on = 6 [default = false];
inline bool DataMap::has_compression_on() const {
  return _has_bit(5);
}
inline void DataMap::clear_compression_on() {
  compression_on_ = false;
  _clear_bit(5);
}
inline bool DataMap::compression_on() const {
  return compression_on_;
}
inline void DataMap::set_compression_on(bool value) {
  _set_bit(5);
  compression_on_ = value;
}

// -------------------------------------------------------------------

// MetaDataMap

// required int32 id = 1;
inline bool MetaDataMap::has_id() const {
  return _has_bit(0);
}
inline void MetaDataMap::clear_id() {
  id_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 MetaDataMap::id() const {
  return id_;
}
inline void MetaDataMap::set_id(::google::protobuf::int32 value) {
  _set_bit(0);
  id_ = value;
}

// required bytes display_name = 2;
inline bool MetaDataMap::has_display_name() const {
  return _has_bit(1);
}
inline void MetaDataMap::clear_display_name() {
  if (display_name_ != &_default_display_name_) {
    display_name_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& MetaDataMap::display_name() const {
  return *display_name_;
}
inline void MetaDataMap::set_display_name(const ::std::string& value) {
  _set_bit(1);
  if (display_name_ == &_default_display_name_) {
    display_name_ = new ::std::string;
  }
  display_name_->assign(value);
}
inline void MetaDataMap::set_display_name(const char* value) {
  _set_bit(1);
  if (display_name_ == &_default_display_name_) {
    display_name_ = new ::std::string;
  }
  display_name_->assign(value);
}
inline void MetaDataMap::set_display_name(const void* value, size_t size) {
  _set_bit(1);
  if (display_name_ == &_default_display_name_) {
    display_name_ = new ::std::string;
  }
  display_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MetaDataMap::mutable_display_name() {
  _set_bit(1);
  if (display_name_ == &_default_display_name_) {
    display_name_ = new ::std::string;
  }
  return display_name_;
}

// required .maidsafe.itemtype type = 3;
inline bool MetaDataMap::has_type() const {
  return _has_bit(2);
}
inline void MetaDataMap::clear_type() {
  type_ = 0;
  _clear_bit(2);
}
inline maidsafe::itemtype MetaDataMap::type() const {
  return static_cast< maidsafe::itemtype >(type_);
}
inline void MetaDataMap::set_type(maidsafe::itemtype value) {
  GOOGLE_DCHECK(maidsafe::itemtype_IsValid(value));
  _set_bit(2);
  type_ = value;
}

// repeated bytes file_hash = 4;
inline int MetaDataMap::file_hash_size() const {
  return file_hash_.size();
}
inline void MetaDataMap::clear_file_hash() {
  file_hash_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
MetaDataMap::file_hash() const {
  return file_hash_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
MetaDataMap::mutable_file_hash() {
  return &file_hash_;
}
inline const ::std::string& MetaDataMap::file_hash(int index) const {
  return file_hash_.Get(index);
}
inline ::std::string* MetaDataMap::mutable_file_hash(int index) {
  return file_hash_.Mutable(index);
}
inline void MetaDataMap::set_file_hash(int index, const ::std::string& value) {
  file_hash_.Mutable(index)->assign(value);
}
inline void MetaDataMap::set_file_hash(int index, const char* value) {
  file_hash_.Mutable(index)->assign(value);
}
inline void MetaDataMap::set_file_hash(int index, const void* value, size_t size) {
  file_hash_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MetaDataMap::add_file_hash() {
  return file_hash_.Add();
}
inline void MetaDataMap::add_file_hash(const ::std::string& value) {
  file_hash_.Add()->assign(value);
}
inline void MetaDataMap::add_file_hash(const char* value) {
  file_hash_.Add()->assign(value);
}
inline void MetaDataMap::add_file_hash(const void* value, size_t size) {
  file_hash_.Add()->assign(reinterpret_cast<const char*>(value), size);
}

// optional bytes stats = 5;
inline bool MetaDataMap::has_stats() const {
  return _has_bit(4);
}
inline void MetaDataMap::clear_stats() {
  if (stats_ != &_default_stats_) {
    stats_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& MetaDataMap::stats() const {
  return *stats_;
}
inline void MetaDataMap::set_stats(const ::std::string& value) {
  _set_bit(4);
  if (stats_ == &_default_stats_) {
    stats_ = new ::std::string;
  }
  stats_->assign(value);
}
inline void MetaDataMap::set_stats(const char* value) {
  _set_bit(4);
  if (stats_ == &_default_stats_) {
    stats_ = new ::std::string;
  }
  stats_->assign(value);
}
inline void MetaDataMap::set_stats(const void* value, size_t size) {
  _set_bit(4);
  if (stats_ == &_default_stats_) {
    stats_ = new ::std::string;
  }
  stats_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MetaDataMap::mutable_stats() {
  _set_bit(4);
  if (stats_ == &_default_stats_) {
    stats_ = new ::std::string;
  }
  return stats_;
}

// optional bytes tag = 6;
inline bool MetaDataMap::has_tag() const {
  return _has_bit(5);
}
inline void MetaDataMap::clear_tag() {
  if (tag_ != &_default_tag_) {
    tag_->clear();
  }
  _clear_bit(5);
}
inline const ::std::string& MetaDataMap::tag() const {
  return *tag_;
}
inline void MetaDataMap::set_tag(const ::std::string& value) {
  _set_bit(5);
  if (tag_ == &_default_tag_) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
}
inline void MetaDataMap::set_tag(const char* value) {
  _set_bit(5);
  if (tag_ == &_default_tag_) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
}
inline void MetaDataMap::set_tag(const void* value, size_t size) {
  _set_bit(5);
  if (tag_ == &_default_tag_) {
    tag_ = new ::std::string;
  }
  tag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MetaDataMap::mutable_tag() {
  _set_bit(5);
  if (tag_ == &_default_tag_) {
    tag_ = new ::std::string;
  }
  return tag_;
}

// optional int32 file_size_high = 7;
inline bool MetaDataMap::has_file_size_high() const {
  return _has_bit(6);
}
inline void MetaDataMap::clear_file_size_high() {
  file_size_high_ = 0;
  _clear_bit(6);
}
inline ::google::protobuf::int32 MetaDataMap::file_size_high() const {
  return file_size_high_;
}
inline void MetaDataMap::set_file_size_high(::google::protobuf::int32 value) {
  _set_bit(6);
  file_size_high_ = value;
}

// optional int32 file_size_low = 8;
inline bool MetaDataMap::has_file_size_low() const {
  return _has_bit(7);
}
inline void MetaDataMap::clear_file_size_low() {
  file_size_low_ = 0;
  _clear_bit(7);
}
inline ::google::protobuf::int32 MetaDataMap::file_size_low() const {
  return file_size_low_;
}
inline void MetaDataMap::set_file_size_low(::google::protobuf::int32 value) {
  _set_bit(7);
  file_size_low_ = value;
}

// optional int32 creation_time = 9;
inline bool MetaDataMap::has_creation_time() const {
  return _has_bit(8);
}
inline void MetaDataMap::clear_creation_time() {
  creation_time_ = 0;
  _clear_bit(8);
}
inline ::google::protobuf::int32 MetaDataMap::creation_time() const {
  return creation_time_;
}
inline void MetaDataMap::set_creation_time(::google::protobuf::int32 value) {
  _set_bit(8);
  creation_time_ = value;
}

// optional int32 last_modified = 10;
inline bool MetaDataMap::has_last_modified() const {
  return _has_bit(9);
}
inline void MetaDataMap::clear_last_modified() {
  last_modified_ = 0;
  _clear_bit(9);
}
inline ::google::protobuf::int32 MetaDataMap::last_modified() const {
  return last_modified_;
}
inline void MetaDataMap::set_last_modified(::google::protobuf::int32 value) {
  _set_bit(9);
  last_modified_ = value;
}

// optional int32 last_access = 11;
inline bool MetaDataMap::has_last_access() const {
  return _has_bit(10);
}
inline void MetaDataMap::clear_last_access() {
  last_access_ = 0;
  _clear_bit(10);
}
inline ::google::protobuf::int32 MetaDataMap::last_access() const {
  return last_access_;
}
inline void MetaDataMap::set_last_access(::google::protobuf::int32 value) {
  _set_bit(10);
  last_access_ = value;
}

// -------------------------------------------------------------------

// Chunk

// optional bytes compression_type = 1;
inline bool Chunk::has_compression_type() const {
  return _has_bit(0);
}
inline void Chunk::clear_compression_type() {
  if (compression_type_ != &_default_compression_type_) {
    compression_type_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& Chunk::compression_type() const {
  return *compression_type_;
}
inline void Chunk::set_compression_type(const ::std::string& value) {
  _set_bit(0);
  if (compression_type_ == &_default_compression_type_) {
    compression_type_ = new ::std::string;
  }
  compression_type_->assign(value);
}
inline void Chunk::set_compression_type(const char* value) {
  _set_bit(0);
  if (compression_type_ == &_default_compression_type_) {
    compression_type_ = new ::std::string;
  }
  compression_type_->assign(value);
}
inline void Chunk::set_compression_type(const void* value, size_t size) {
  _set_bit(0);
  if (compression_type_ == &_default_compression_type_) {
    compression_type_ = new ::std::string;
  }
  compression_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Chunk::mutable_compression_type() {
  _set_bit(0);
  if (compression_type_ == &_default_compression_type_) {
    compression_type_ = new ::std::string;
  }
  return compression_type_;
}

// repeated bytes chunklet = 2;
inline int Chunk::chunklet_size() const {
  return chunklet_.size();
}
inline void Chunk::clear_chunklet() {
  chunklet_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Chunk::chunklet() const {
  return chunklet_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Chunk::mutable_chunklet() {
  return &chunklet_;
}
inline const ::std::string& Chunk::chunklet(int index) const {
  return chunklet_.Get(index);
}
inline ::std::string* Chunk::mutable_chunklet(int index) {
  return chunklet_.Mutable(index);
}
inline void Chunk::set_chunklet(int index, const ::std::string& value) {
  chunklet_.Mutable(index)->assign(value);
}
inline void Chunk::set_chunklet(int index, const char* value) {
  chunklet_.Mutable(index)->assign(value);
}
inline void Chunk::set_chunklet(int index, const void* value, size_t size) {
  chunklet_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Chunk::add_chunklet() {
  return chunklet_.Add();
}
inline void Chunk::add_chunklet(const ::std::string& value) {
  chunklet_.Add()->assign(value);
}
inline void Chunk::add_chunklet(const char* value) {
  chunklet_.Add()->assign(value);
}
inline void Chunk::add_chunklet(const void* value, size_t size) {
  chunklet_.Add()->assign(reinterpret_cast<const char*>(value), size);
}

// repeated int32 pre_compression_chunklet_size = 3;
inline int Chunk::pre_compression_chunklet_size_size() const {
  return pre_compression_chunklet_size_.size();
}
inline void Chunk::clear_pre_compression_chunklet_size() {
  pre_compression_chunklet_size_.Clear();
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Chunk::pre_compression_chunklet_size() const {
  return pre_compression_chunklet_size_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Chunk::mutable_pre_compression_chunklet_size() {
  return &pre_compression_chunklet_size_;
}
inline ::google::protobuf::int32 Chunk::pre_compression_chunklet_size(int index) const {
  return pre_compression_chunklet_size_.Get(index);
}
inline void Chunk::set_pre_compression_chunklet_size(int index, ::google::protobuf::int32 value) {
  pre_compression_chunklet_size_.Set(index, value);
}
inline void Chunk::add_pre_compression_chunklet_size(::google::protobuf::int32 value) {
  pre_compression_chunklet_size_.Add(value);
}

// -------------------------------------------------------------------

// DataAtlas

// optional bytes root_db_key = 1;
inline bool DataAtlas::has_root_db_key() const {
  return _has_bit(0);
}
inline void DataAtlas::clear_root_db_key() {
  if (root_db_key_ != &_default_root_db_key_) {
    root_db_key_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& DataAtlas::root_db_key() const {
  return *root_db_key_;
}
inline void DataAtlas::set_root_db_key(const ::std::string& value) {
  _set_bit(0);
  if (root_db_key_ == &_default_root_db_key_) {
    root_db_key_ = new ::std::string;
  }
  root_db_key_->assign(value);
}
inline void DataAtlas::set_root_db_key(const char* value) {
  _set_bit(0);
  if (root_db_key_ == &_default_root_db_key_) {
    root_db_key_ = new ::std::string;
  }
  root_db_key_->assign(value);
}
inline void DataAtlas::set_root_db_key(const void* value, size_t size) {
  _set_bit(0);
  if (root_db_key_ == &_default_root_db_key_) {
    root_db_key_ = new ::std::string;
  }
  root_db_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DataAtlas::mutable_root_db_key() {
  _set_bit(0);
  if (root_db_key_ == &_default_root_db_key_) {
    root_db_key_ = new ::std::string;
  }
  return root_db_key_;
}

// repeated .maidsafe.Key keys = 2;
inline int DataAtlas::keys_size() const {
  return keys_.size();
}
inline void DataAtlas::clear_keys() {
  keys_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::maidsafe::Key >&
DataAtlas::keys() const {
  return keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::maidsafe::Key >*
DataAtlas::mutable_keys() {
  return &keys_;
}
inline const ::maidsafe::Key& DataAtlas::keys(int index) const {
  return keys_.Get(index);
}
inline ::maidsafe::Key* DataAtlas::mutable_keys(int index) {
  return keys_.Mutable(index);
}
inline ::maidsafe::Key* DataAtlas::add_keys() {
  return keys_.Add();
}

// repeated .maidsafe.MetaDataMap mdms = 3;
inline int DataAtlas::mdms_size() const {
  return mdms_.size();
}
inline void DataAtlas::clear_mdms() {
  mdms_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::maidsafe::MetaDataMap >&
DataAtlas::mdms() const {
  return mdms_;
}
inline ::google::protobuf::RepeatedPtrField< ::maidsafe::MetaDataMap >*
DataAtlas::mutable_mdms() {
  return &mdms_;
}
inline const ::maidsafe::MetaDataMap& DataAtlas::mdms(int index) const {
  return mdms_.Get(index);
}
inline ::maidsafe::MetaDataMap* DataAtlas::mutable_mdms(int index) {
  return mdms_.Mutable(index);
}
inline ::maidsafe::MetaDataMap* DataAtlas::add_mdms() {
  return mdms_.Add();
}

// repeated .maidsafe.DataMap dms = 4;
inline int DataAtlas::dms_size() const {
  return dms_.size();
}
inline void DataAtlas::clear_dms() {
  dms_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::maidsafe::DataMap >&
DataAtlas::dms() const {
  return dms_;
}
inline ::google::protobuf::RepeatedPtrField< ::maidsafe::DataMap >*
DataAtlas::mutable_dms() {
  return &dms_;
}
inline const ::maidsafe::DataMap& DataAtlas::dms(int index) const {
  return dms_.Get(index);
}
inline ::maidsafe::DataMap* DataAtlas::mutable_dms(int index) {
  return dms_.Mutable(index);
}
inline ::maidsafe::DataMap* DataAtlas::add_dms() {
  return dms_.Add();
}

// repeated .maidsafe.PublicContact contacts = 5;
inline int DataAtlas::contacts_size() const {
  return contacts_.size();
}
inline void DataAtlas::clear_contacts() {
  contacts_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::maidsafe::PublicContact >&
DataAtlas::contacts() const {
  return contacts_;
}
inline ::google::protobuf::RepeatedPtrField< ::maidsafe::PublicContact >*
DataAtlas::mutable_contacts() {
  return &contacts_;
}
inline const ::maidsafe::PublicContact& DataAtlas::contacts(int index) const {
  return contacts_.Get(index);
}
inline ::maidsafe::PublicContact* DataAtlas::mutable_contacts(int index) {
  return contacts_.Mutable(index);
}
inline ::maidsafe::PublicContact* DataAtlas::add_contacts() {
  return contacts_.Add();
}

// repeated .maidsafe.Share shares = 6;
inline int DataAtlas::shares_size() const {
  return shares_.size();
}
inline void DataAtlas::clear_shares() {
  shares_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::maidsafe::Share >&
DataAtlas::shares() const {
  return shares_;
}
inline ::google::protobuf::RepeatedPtrField< ::maidsafe::Share >*
DataAtlas::mutable_shares() {
  return &shares_;
}
inline const ::maidsafe::Share& DataAtlas::shares(int index) const {
  return shares_.Get(index);
}
inline ::maidsafe::Share* DataAtlas::mutable_shares(int index) {
  return shares_.Mutable(index);
}
inline ::maidsafe::Share* DataAtlas::add_shares() {
  return shares_.Add();
}


}  // namespace maidsafe
#endif  // PROTOBUF_datamaps_2eproto__INCLUDED
