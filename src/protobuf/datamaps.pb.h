// Generated by the protocol buffer compiler.  DO NOT EDIT!

#ifndef PROTOBUF_datamaps_2eproto__INCLUDED
#define PROTOBUF_datamaps_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2001000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2001000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>

namespace maidsafe {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_datamaps_2eproto();
void protobuf_AssignDesc_datamaps_2eproto();
void protobuf_ShutdownFile_datamaps_2eproto();

class Key;
class DataMap;
class MetaDataMap;
class Chunk;
class DataAtlas;

enum itemtype {
  REGULAR_FILE = 0,
  SMALL_FILE = 1,
  EMPTY_FILE = 2,
  LOCKED_FILE = 3,
  DIRECTORY = 4,
  EMPTY_DIRECTORY = 5,
  LINK = 6,
  NOT_FOR_PROCESSING = 7,
  UNKNOWN = 8
};
const ::google::protobuf::EnumDescriptor* itemtype_descriptor();
bool itemtype_IsValid(int value);
const itemtype itemtype_MIN = REGULAR_FILE;
const itemtype itemtype_MAX = UNKNOWN;

inline const ::std::string& itemtype_Name(itemtype value) {
  return ::google::protobuf::internal::NameOfEnum(
    itemtype_descriptor(), value);
}
inline bool itemtype_Parse(
    const ::std::string& name, itemtype* value) {
  return ::google::protobuf::internal::ParseNamedEnum<itemtype>(
    itemtype_descriptor(), name, value);
}
enum PacketType {
  ANMID = 0,
  ANTMID = 1,
  ANSMID = 2,
  MAID = 3,
  PMID = 4,
  ANMPID = 5,
  MPID = 6
};
const ::google::protobuf::EnumDescriptor* PacketType_descriptor();
bool PacketType_IsValid(int value);
const PacketType PacketType_MIN = ANMID;
const PacketType PacketType_MAX = MPID;

inline const ::std::string& PacketType_Name(PacketType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PacketType_descriptor(), value);
}
inline bool PacketType_Parse(
    const ::std::string& name, PacketType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PacketType>(
    PacketType_descriptor(), name, value);
}
// ===================================================================

class Key : public ::google::protobuf::Message {
 public:
  Key();
  virtual ~Key();
  
  Key(const Key& from);
  
  inline Key& operator=(const Key& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Key& default_instance();
  void Swap(Key* other);
  
  // implements Message ----------------------------------------------
  
  Key* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Key& from);
  void MergeFrom(const Key& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const void* value, size_t size);
  inline ::std::string* mutable_id();
  
  // required .maidsafe.PacketType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline maidsafe::PacketType type() const;
  inline void set_type(maidsafe::PacketType value);
  
  // required bytes private_key = 3;
  inline bool has_private_key() const;
  inline void clear_private_key();
  static const int kPrivateKeyFieldNumber = 3;
  inline const ::std::string& private_key() const;
  inline void set_private_key(const ::std::string& value);
  inline void set_private_key(const char* value);
  inline void set_private_key(const void* value, size_t size);
  inline ::std::string* mutable_private_key();
  
  // required bytes public_key = 4;
  inline bool has_public_key() const;
  inline void clear_public_key();
  static const int kPublicKeyFieldNumber = 4;
  inline const ::std::string& public_key() const;
  inline void set_public_key(const ::std::string& value);
  inline void set_public_key(const char* value);
  inline void set_public_key(const void* value, size_t size);
  inline ::std::string* mutable_public_key();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* id_;
  static const ::std::string _default_id_;
  int type_;
  ::std::string* private_key_;
  static const ::std::string _default_private_key_;
  ::std::string* public_key_;
  static const ::std::string _default_public_key_;
  friend void  protobuf_AddDesc_datamaps_2eproto();
  friend void protobuf_AssignDesc_datamaps_2eproto();
  friend void protobuf_ShutdownFile_datamaps_2eproto();
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Key* default_instance_;
};
// -------------------------------------------------------------------

class DataMap : public ::google::protobuf::Message {
 public:
  DataMap();
  virtual ~DataMap();
  
  DataMap(const DataMap& from);
  
  inline DataMap& operator=(const DataMap& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DataMap& default_instance();
  void Swap(DataMap* other);
  
  // implements Message ----------------------------------------------
  
  DataMap* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DataMap& from);
  void MergeFrom(const DataMap& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes file_hash = 1;
  inline bool has_file_hash() const;
  inline void clear_file_hash();
  static const int kFileHashFieldNumber = 1;
  inline const ::std::string& file_hash() const;
  inline void set_file_hash(const ::std::string& value);
  inline void set_file_hash(const char* value);
  inline void set_file_hash(const void* value, size_t size);
  inline ::std::string* mutable_file_hash();
  
  // optional bytes se_version = 2;
  inline bool has_se_version() const;
  inline void clear_se_version();
  static const int kSeVersionFieldNumber = 2;
  inline const ::std::string& se_version() const;
  inline void set_se_version(const ::std::string& value);
  inline void set_se_version(const char* value);
  inline void set_se_version(const void* value, size_t size);
  inline ::std::string* mutable_se_version();
  
  // repeated bytes chunk_name = 3;
  inline int chunk_name_size() const;
  inline void clear_chunk_name();
  static const int kChunkNameFieldNumber = 3;
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& chunk_name() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_chunk_name();
  inline const ::std::string& chunk_name(int index) const;
  inline ::std::string* mutable_chunk_name(int index);
  inline void set_chunk_name(int index, const ::std::string& value);
  inline void set_chunk_name(int index, const char* value);
  inline void set_chunk_name(int index, const void* value, size_t size);
  inline ::std::string* add_chunk_name();
  inline void add_chunk_name(const ::std::string& value);
  inline void add_chunk_name(const char* value);
  inline void add_chunk_name(const void* value, size_t size);
  
  // repeated bytes encrypted_chunk_name = 4;
  inline int encrypted_chunk_name_size() const;
  inline void clear_encrypted_chunk_name();
  static const int kEncryptedChunkNameFieldNumber = 4;
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& encrypted_chunk_name() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_encrypted_chunk_name();
  inline const ::std::string& encrypted_chunk_name(int index) const;
  inline ::std::string* mutable_encrypted_chunk_name(int index);
  inline void set_encrypted_chunk_name(int index, const ::std::string& value);
  inline void set_encrypted_chunk_name(int index, const char* value);
  inline void set_encrypted_chunk_name(int index, const void* value, size_t size);
  inline ::std::string* add_encrypted_chunk_name();
  inline void add_encrypted_chunk_name(const ::std::string& value);
  inline void add_encrypted_chunk_name(const char* value);
  inline void add_encrypted_chunk_name(const void* value, size_t size);
  
  // repeated uint64 chunk_size = 5;
  inline int chunk_size_size() const;
  inline void clear_chunk_size();
  static const int kChunkSizeFieldNumber = 5;
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >& chunk_size() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >* mutable_chunk_size();
  inline ::google::protobuf::uint64 chunk_size(int index) const;
  inline void set_chunk_size(int index, ::google::protobuf::uint64 value);
  inline void add_chunk_size(::google::protobuf::uint64 value);
  
  // optional bool compression_on = 6 [default = false];
  inline bool has_compression_on() const;
  inline void clear_compression_on();
  static const int kCompressionOnFieldNumber = 6;
  inline bool compression_on() const;
  inline void set_compression_on(bool value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* file_hash_;
  static const ::std::string _default_file_hash_;
  ::std::string* se_version_;
  static const ::std::string _default_se_version_;
  ::google::protobuf::RepeatedPtrField< ::std::string> chunk_name_;
  ::google::protobuf::RepeatedPtrField< ::std::string> encrypted_chunk_name_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > chunk_size_;
  bool compression_on_;
  friend void  protobuf_AddDesc_datamaps_2eproto();
  friend void protobuf_AssignDesc_datamaps_2eproto();
  friend void protobuf_ShutdownFile_datamaps_2eproto();
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static DataMap* default_instance_;
};
// -------------------------------------------------------------------

class MetaDataMap : public ::google::protobuf::Message {
 public:
  MetaDataMap();
  virtual ~MetaDataMap();
  
  MetaDataMap(const MetaDataMap& from);
  
  inline MetaDataMap& operator=(const MetaDataMap& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MetaDataMap& default_instance();
  void Swap(MetaDataMap* other);
  
  // implements Message ----------------------------------------------
  
  MetaDataMap* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MetaDataMap& from);
  void MergeFrom(const MetaDataMap& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // required bytes display_name = 2;
  inline bool has_display_name() const;
  inline void clear_display_name();
  static const int kDisplayNameFieldNumber = 2;
  inline const ::std::string& display_name() const;
  inline void set_display_name(const ::std::string& value);
  inline void set_display_name(const char* value);
  inline void set_display_name(const void* value, size_t size);
  inline ::std::string* mutable_display_name();
  
  // required .maidsafe.itemtype type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline maidsafe::itemtype type() const;
  inline void set_type(maidsafe::itemtype value);
  
  // repeated bytes file_hash = 4;
  inline int file_hash_size() const;
  inline void clear_file_hash();
  static const int kFileHashFieldNumber = 4;
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& file_hash() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_file_hash();
  inline const ::std::string& file_hash(int index) const;
  inline ::std::string* mutable_file_hash(int index);
  inline void set_file_hash(int index, const ::std::string& value);
  inline void set_file_hash(int index, const char* value);
  inline void set_file_hash(int index, const void* value, size_t size);
  inline ::std::string* add_file_hash();
  inline void add_file_hash(const ::std::string& value);
  inline void add_file_hash(const char* value);
  inline void add_file_hash(const void* value, size_t size);
  
  // optional bytes stats = 5;
  inline bool has_stats() const;
  inline void clear_stats();
  static const int kStatsFieldNumber = 5;
  inline const ::std::string& stats() const;
  inline void set_stats(const ::std::string& value);
  inline void set_stats(const char* value);
  inline void set_stats(const void* value, size_t size);
  inline ::std::string* mutable_stats();
  
  // optional bytes tag = 6;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 6;
  inline const ::std::string& tag() const;
  inline void set_tag(const ::std::string& value);
  inline void set_tag(const char* value);
  inline void set_tag(const void* value, size_t size);
  inline ::std::string* mutable_tag();
  
  // optional int32 file_size_high = 7;
  inline bool has_file_size_high() const;
  inline void clear_file_size_high();
  static const int kFileSizeHighFieldNumber = 7;
  inline ::google::protobuf::int32 file_size_high() const;
  inline void set_file_size_high(::google::protobuf::int32 value);
  
  // optional int32 file_size_low = 8;
  inline bool has_file_size_low() const;
  inline void clear_file_size_low();
  static const int kFileSizeLowFieldNumber = 8;
  inline ::google::protobuf::int32 file_size_low() const;
  inline void set_file_size_low(::google::protobuf::int32 value);
  
  // optional int32 creation_time = 9;
  inline bool has_creation_time() const;
  inline void clear_creation_time();
  static const int kCreationTimeFieldNumber = 9;
  inline ::google::protobuf::int32 creation_time() const;
  inline void set_creation_time(::google::protobuf::int32 value);
  
  // optional int32 last_modified = 10;
  inline bool has_last_modified() const;
  inline void clear_last_modified();
  static const int kLastModifiedFieldNumber = 10;
  inline ::google::protobuf::int32 last_modified() const;
  inline void set_last_modified(::google::protobuf::int32 value);
  
  // optional int32 last_access = 11;
  inline bool has_last_access() const;
  inline void clear_last_access();
  static const int kLastAccessFieldNumber = 11;
  inline ::google::protobuf::int32 last_access() const;
  inline void set_last_access(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 id_;
  ::std::string* display_name_;
  static const ::std::string _default_display_name_;
  int type_;
  ::google::protobuf::RepeatedPtrField< ::std::string> file_hash_;
  ::std::string* stats_;
  static const ::std::string _default_stats_;
  ::std::string* tag_;
  static const ::std::string _default_tag_;
  ::google::protobuf::int32 file_size_high_;
  ::google::protobuf::int32 file_size_low_;
  ::google::protobuf::int32 creation_time_;
  ::google::protobuf::int32 last_modified_;
  ::google::protobuf::int32 last_access_;
  friend void  protobuf_AddDesc_datamaps_2eproto();
  friend void protobuf_AssignDesc_datamaps_2eproto();
  friend void protobuf_ShutdownFile_datamaps_2eproto();
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static MetaDataMap* default_instance_;
};
// -------------------------------------------------------------------

class Chunk : public ::google::protobuf::Message {
 public:
  Chunk();
  virtual ~Chunk();
  
  Chunk(const Chunk& from);
  
  inline Chunk& operator=(const Chunk& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Chunk& default_instance();
  void Swap(Chunk* other);
  
  // implements Message ----------------------------------------------
  
  Chunk* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Chunk& from);
  void MergeFrom(const Chunk& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bytes compression_type = 1;
  inline bool has_compression_type() const;
  inline void clear_compression_type();
  static const int kCompressionTypeFieldNumber = 1;
  inline const ::std::string& compression_type() const;
  inline void set_compression_type(const ::std::string& value);
  inline void set_compression_type(const char* value);
  inline void set_compression_type(const void* value, size_t size);
  inline ::std::string* mutable_compression_type();
  
  // repeated bytes chunklet = 2;
  inline int chunklet_size() const;
  inline void clear_chunklet();
  static const int kChunkletFieldNumber = 2;
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& chunklet() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_chunklet();
  inline const ::std::string& chunklet(int index) const;
  inline ::std::string* mutable_chunklet(int index);
  inline void set_chunklet(int index, const ::std::string& value);
  inline void set_chunklet(int index, const char* value);
  inline void set_chunklet(int index, const void* value, size_t size);
  inline ::std::string* add_chunklet();
  inline void add_chunklet(const ::std::string& value);
  inline void add_chunklet(const char* value);
  inline void add_chunklet(const void* value, size_t size);
  
  // repeated int32 pre_compression_chunklet_size = 3;
  inline int pre_compression_chunklet_size_size() const;
  inline void clear_pre_compression_chunklet_size();
  static const int kPreCompressionChunkletSizeFieldNumber = 3;
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >& pre_compression_chunklet_size() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >* mutable_pre_compression_chunklet_size();
  inline ::google::protobuf::int32 pre_compression_chunklet_size(int index) const;
  inline void set_pre_compression_chunklet_size(int index, ::google::protobuf::int32 value);
  inline void add_pre_compression_chunklet_size(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* compression_type_;
  static const ::std::string _default_compression_type_;
  ::google::protobuf::RepeatedPtrField< ::std::string> chunklet_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > pre_compression_chunklet_size_;
  friend void  protobuf_AddDesc_datamaps_2eproto();
  friend void protobuf_AssignDesc_datamaps_2eproto();
  friend void protobuf_ShutdownFile_datamaps_2eproto();
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Chunk* default_instance_;
};
// -------------------------------------------------------------------

class DataAtlas : public ::google::protobuf::Message {
 public:
  DataAtlas();
  virtual ~DataAtlas();
  
  DataAtlas(const DataAtlas& from);
  
  inline DataAtlas& operator=(const DataAtlas& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DataAtlas& default_instance();
  void Swap(DataAtlas* other);
  
  // implements Message ----------------------------------------------
  
  DataAtlas* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DataAtlas& from);
  void MergeFrom(const DataAtlas& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bytes root_db_key = 1;
  inline bool has_root_db_key() const;
  inline void clear_root_db_key();
  static const int kRootDbKeyFieldNumber = 1;
  inline const ::std::string& root_db_key() const;
  inline void set_root_db_key(const ::std::string& value);
  inline void set_root_db_key(const char* value);
  inline void set_root_db_key(const void* value, size_t size);
  inline ::std::string* mutable_root_db_key();
  
  // repeated .maidsafe.Key keys = 2;
  inline int keys_size() const;
  inline void clear_keys();
  static const int kKeysFieldNumber = 2;
  inline const ::google::protobuf::RepeatedPtrField< ::maidsafe::Key >& keys() const;
  inline ::google::protobuf::RepeatedPtrField< ::maidsafe::Key >* mutable_keys();
  inline const ::maidsafe::Key& keys(int index) const;
  inline ::maidsafe::Key* mutable_keys(int index);
  inline ::maidsafe::Key* add_keys();
  
  // repeated .maidsafe.MetaDataMap mdms = 3;
  inline int mdms_size() const;
  inline void clear_mdms();
  static const int kMdmsFieldNumber = 3;
  inline const ::google::protobuf::RepeatedPtrField< ::maidsafe::MetaDataMap >& mdms() const;
  inline ::google::protobuf::RepeatedPtrField< ::maidsafe::MetaDataMap >* mutable_mdms();
  inline const ::maidsafe::MetaDataMap& mdms(int index) const;
  inline ::maidsafe::MetaDataMap* mutable_mdms(int index);
  inline ::maidsafe::MetaDataMap* add_mdms();
  
  // repeated .maidsafe.DataMap dms = 4;
  inline int dms_size() const;
  inline void clear_dms();
  static const int kDmsFieldNumber = 4;
  inline const ::google::protobuf::RepeatedPtrField< ::maidsafe::DataMap >& dms() const;
  inline ::google::protobuf::RepeatedPtrField< ::maidsafe::DataMap >* mutable_dms();
  inline const ::maidsafe::DataMap& dms(int index) const;
  inline ::maidsafe::DataMap* mutable_dms(int index);
  inline ::maidsafe::DataMap* add_dms();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* root_db_key_;
  static const ::std::string _default_root_db_key_;
  ::google::protobuf::RepeatedPtrField< ::maidsafe::Key > keys_;
  ::google::protobuf::RepeatedPtrField< ::maidsafe::MetaDataMap > mdms_;
  ::google::protobuf::RepeatedPtrField< ::maidsafe::DataMap > dms_;
  friend void  protobuf_AddDesc_datamaps_2eproto();
  friend void protobuf_AssignDesc_datamaps_2eproto();
  friend void protobuf_ShutdownFile_datamaps_2eproto();
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static DataAtlas* default_instance_;
};
// ===================================================================


// ===================================================================


// ===================================================================

// Key

// required bytes id = 1;
inline bool Key::has_id() const {
  return _has_bit(0);
}
inline void Key::clear_id() {
  if (id_ != &_default_id_) {
    id_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& Key::id() const {
  return *id_;
}
inline void Key::set_id(const ::std::string& value) {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void Key::set_id(const char* value) {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void Key::set_id(const void* value, size_t size) {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Key::mutable_id() {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  return id_;
}

// required .maidsafe.PacketType type = 2;
inline bool Key::has_type() const {
  return _has_bit(1);
}
inline void Key::clear_type() {
  type_ = 0;
  _clear_bit(1);
}
inline maidsafe::PacketType Key::type() const {
  return static_cast< maidsafe::PacketType >(type_);
}
inline void Key::set_type(maidsafe::PacketType value) {
  GOOGLE_DCHECK(maidsafe::PacketType_IsValid(value));
  _set_bit(1);
  type_ = value;
}

// required bytes private_key = 3;
inline bool Key::has_private_key() const {
  return _has_bit(2);
}
inline void Key::clear_private_key() {
  if (private_key_ != &_default_private_key_) {
    private_key_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& Key::private_key() const {
  return *private_key_;
}
inline void Key::set_private_key(const ::std::string& value) {
  _set_bit(2);
  if (private_key_ == &_default_private_key_) {
    private_key_ = new ::std::string;
  }
  private_key_->assign(value);
}
inline void Key::set_private_key(const char* value) {
  _set_bit(2);
  if (private_key_ == &_default_private_key_) {
    private_key_ = new ::std::string;
  }
  private_key_->assign(value);
}
inline void Key::set_private_key(const void* value, size_t size) {
  _set_bit(2);
  if (private_key_ == &_default_private_key_) {
    private_key_ = new ::std::string;
  }
  private_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Key::mutable_private_key() {
  _set_bit(2);
  if (private_key_ == &_default_private_key_) {
    private_key_ = new ::std::string;
  }
  return private_key_;
}

// required bytes public_key = 4;
inline bool Key::has_public_key() const {
  return _has_bit(3);
}
inline void Key::clear_public_key() {
  if (public_key_ != &_default_public_key_) {
    public_key_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& Key::public_key() const {
  return *public_key_;
}
inline void Key::set_public_key(const ::std::string& value) {
  _set_bit(3);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void Key::set_public_key(const char* value) {
  _set_bit(3);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void Key::set_public_key(const void* value, size_t size) {
  _set_bit(3);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Key::mutable_public_key() {
  _set_bit(3);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  return public_key_;
}

// -------------------------------------------------------------------

// DataMap

// required bytes file_hash = 1;
inline bool DataMap::has_file_hash() const {
  return _has_bit(0);
}
inline void DataMap::clear_file_hash() {
  if (file_hash_ != &_default_file_hash_) {
    file_hash_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& DataMap::file_hash() const {
  return *file_hash_;
}
inline void DataMap::set_file_hash(const ::std::string& value) {
  _set_bit(0);
  if (file_hash_ == &_default_file_hash_) {
    file_hash_ = new ::std::string;
  }
  file_hash_->assign(value);
}
inline void DataMap::set_file_hash(const char* value) {
  _set_bit(0);
  if (file_hash_ == &_default_file_hash_) {
    file_hash_ = new ::std::string;
  }
  file_hash_->assign(value);
}
inline void DataMap::set_file_hash(const void* value, size_t size) {
  _set_bit(0);
  if (file_hash_ == &_default_file_hash_) {
    file_hash_ = new ::std::string;
  }
  file_hash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DataMap::mutable_file_hash() {
  _set_bit(0);
  if (file_hash_ == &_default_file_hash_) {
    file_hash_ = new ::std::string;
  }
  return file_hash_;
}

// optional bytes se_version = 2;
inline bool DataMap::has_se_version() const {
  return _has_bit(1);
}
inline void DataMap::clear_se_version() {
  if (se_version_ != &_default_se_version_) {
    se_version_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& DataMap::se_version() const {
  return *se_version_;
}
inline void DataMap::set_se_version(const ::std::string& value) {
  _set_bit(1);
  if (se_version_ == &_default_se_version_) {
    se_version_ = new ::std::string;
  }
  se_version_->assign(value);
}
inline void DataMap::set_se_version(const char* value) {
  _set_bit(1);
  if (se_version_ == &_default_se_version_) {
    se_version_ = new ::std::string;
  }
  se_version_->assign(value);
}
inline void DataMap::set_se_version(const void* value, size_t size) {
  _set_bit(1);
  if (se_version_ == &_default_se_version_) {
    se_version_ = new ::std::string;
  }
  se_version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DataMap::mutable_se_version() {
  _set_bit(1);
  if (se_version_ == &_default_se_version_) {
    se_version_ = new ::std::string;
  }
  return se_version_;
}

// repeated bytes chunk_name = 3;
inline int DataMap::chunk_name_size() const {
  return chunk_name_.size();
}
inline void DataMap::clear_chunk_name() {
  chunk_name_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
DataMap::chunk_name() const {
  return chunk_name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
DataMap::mutable_chunk_name() {
  return &chunk_name_;
}
inline const ::std::string& DataMap::chunk_name(int index) const {
  return chunk_name_.Get(index);
}
inline ::std::string* DataMap::mutable_chunk_name(int index) {
  return chunk_name_.Mutable(index);
}
inline void DataMap::set_chunk_name(int index, const ::std::string& value) {
  chunk_name_.Mutable(index)->assign(value);
}
inline void DataMap::set_chunk_name(int index, const char* value) {
  chunk_name_.Mutable(index)->assign(value);
}
inline void DataMap::set_chunk_name(int index, const void* value, size_t size) {
  chunk_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DataMap::add_chunk_name() {
  return chunk_name_.Add();
}
inline void DataMap::add_chunk_name(const ::std::string& value) {
  chunk_name_.Add()->assign(value);
}
inline void DataMap::add_chunk_name(const char* value) {
  chunk_name_.Add()->assign(value);
}
inline void DataMap::add_chunk_name(const void* value, size_t size) {
  chunk_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
}

// repeated bytes encrypted_chunk_name = 4;
inline int DataMap::encrypted_chunk_name_size() const {
  return encrypted_chunk_name_.size();
}
inline void DataMap::clear_encrypted_chunk_name() {
  encrypted_chunk_name_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
DataMap::encrypted_chunk_name() const {
  return encrypted_chunk_name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
DataMap::mutable_encrypted_chunk_name() {
  return &encrypted_chunk_name_;
}
inline const ::std::string& DataMap::encrypted_chunk_name(int index) const {
  return encrypted_chunk_name_.Get(index);
}
inline ::std::string* DataMap::mutable_encrypted_chunk_name(int index) {
  return encrypted_chunk_name_.Mutable(index);
}
inline void DataMap::set_encrypted_chunk_name(int index, const ::std::string& value) {
  encrypted_chunk_name_.Mutable(index)->assign(value);
}
inline void DataMap::set_encrypted_chunk_name(int index, const char* value) {
  encrypted_chunk_name_.Mutable(index)->assign(value);
}
inline void DataMap::set_encrypted_chunk_name(int index, const void* value, size_t size) {
  encrypted_chunk_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DataMap::add_encrypted_chunk_name() {
  return encrypted_chunk_name_.Add();
}
inline void DataMap::add_encrypted_chunk_name(const ::std::string& value) {
  encrypted_chunk_name_.Add()->assign(value);
}
inline void DataMap::add_encrypted_chunk_name(const char* value) {
  encrypted_chunk_name_.Add()->assign(value);
}
inline void DataMap::add_encrypted_chunk_name(const void* value, size_t size) {
  encrypted_chunk_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
}

// repeated uint64 chunk_size = 5;
inline int DataMap::chunk_size_size() const {
  return chunk_size_.size();
}
inline void DataMap::clear_chunk_size() {
  chunk_size_.Clear();
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
DataMap::chunk_size() const {
  return chunk_size_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
DataMap::mutable_chunk_size() {
  return &chunk_size_;
}
inline ::google::protobuf::uint64 DataMap::chunk_size(int index) const {
  return chunk_size_.Get(index);
}
inline void DataMap::set_chunk_size(int index, ::google::protobuf::uint64 value) {
  chunk_size_.Set(index, value);
}
inline void DataMap::add_chunk_size(::google::protobuf::uint64 value) {
  chunk_size_.Add(value);
}

// optional bool compression_on = 6 [default = false];
inline bool DataMap::has_compression_on() const {
  return _has_bit(5);
}
inline void DataMap::clear_compression_on() {
  compression_on_ = false;
  _clear_bit(5);
}
inline bool DataMap::compression_on() const {
  return compression_on_;
}
inline void DataMap::set_compression_on(bool value) {
  _set_bit(5);
  compression_on_ = value;
}

// -------------------------------------------------------------------

// MetaDataMap

// required int32 id = 1;
inline bool MetaDataMap::has_id() const {
  return _has_bit(0);
}
inline void MetaDataMap::clear_id() {
  id_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 MetaDataMap::id() const {
  return id_;
}
inline void MetaDataMap::set_id(::google::protobuf::int32 value) {
  _set_bit(0);
  id_ = value;
}

// required bytes display_name = 2;
inline bool MetaDataMap::has_display_name() const {
  return _has_bit(1);
}
inline void MetaDataMap::clear_display_name() {
  if (display_name_ != &_default_display_name_) {
    display_name_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& MetaDataMap::display_name() const {
  return *display_name_;
}
inline void MetaDataMap::set_display_name(const ::std::string& value) {
  _set_bit(1);
  if (display_name_ == &_default_display_name_) {
    display_name_ = new ::std::string;
  }
  display_name_->assign(value);
}
inline void MetaDataMap::set_display_name(const char* value) {
  _set_bit(1);
  if (display_name_ == &_default_display_name_) {
    display_name_ = new ::std::string;
  }
  display_name_->assign(value);
}
inline void MetaDataMap::set_display_name(const void* value, size_t size) {
  _set_bit(1);
  if (display_name_ == &_default_display_name_) {
    display_name_ = new ::std::string;
  }
  display_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MetaDataMap::mutable_display_name() {
  _set_bit(1);
  if (display_name_ == &_default_display_name_) {
    display_name_ = new ::std::string;
  }
  return display_name_;
}

// required .maidsafe.itemtype type = 3;
inline bool MetaDataMap::has_type() const {
  return _has_bit(2);
}
inline void MetaDataMap::clear_type() {
  type_ = 0;
  _clear_bit(2);
}
inline maidsafe::itemtype MetaDataMap::type() const {
  return static_cast< maidsafe::itemtype >(type_);
}
inline void MetaDataMap::set_type(maidsafe::itemtype value) {
  GOOGLE_DCHECK(maidsafe::itemtype_IsValid(value));
  _set_bit(2);
  type_ = value;
}

// repeated bytes file_hash = 4;
inline int MetaDataMap::file_hash_size() const {
  return file_hash_.size();
}
inline void MetaDataMap::clear_file_hash() {
  file_hash_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
MetaDataMap::file_hash() const {
  return file_hash_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
MetaDataMap::mutable_file_hash() {
  return &file_hash_;
}
inline const ::std::string& MetaDataMap::file_hash(int index) const {
  return file_hash_.Get(index);
}
inline ::std::string* MetaDataMap::mutable_file_hash(int index) {
  return file_hash_.Mutable(index);
}
inline void MetaDataMap::set_file_hash(int index, const ::std::string& value) {
  file_hash_.Mutable(index)->assign(value);
}
inline void MetaDataMap::set_file_hash(int index, const char* value) {
  file_hash_.Mutable(index)->assign(value);
}
inline void MetaDataMap::set_file_hash(int index, const void* value, size_t size) {
  file_hash_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MetaDataMap::add_file_hash() {
  return file_hash_.Add();
}
inline void MetaDataMap::add_file_hash(const ::std::string& value) {
  file_hash_.Add()->assign(value);
}
inline void MetaDataMap::add_file_hash(const char* value) {
  file_hash_.Add()->assign(value);
}
inline void MetaDataMap::add_file_hash(const void* value, size_t size) {
  file_hash_.Add()->assign(reinterpret_cast<const char*>(value), size);
}

// optional bytes stats = 5;
inline bool MetaDataMap::has_stats() const {
  return _has_bit(4);
}
inline void MetaDataMap::clear_stats() {
  if (stats_ != &_default_stats_) {
    stats_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& MetaDataMap::stats() const {
  return *stats_;
}
inline void MetaDataMap::set_stats(const ::std::string& value) {
  _set_bit(4);
  if (stats_ == &_default_stats_) {
    stats_ = new ::std::string;
  }
  stats_->assign(value);
}
inline void MetaDataMap::set_stats(const char* value) {
  _set_bit(4);
  if (stats_ == &_default_stats_) {
    stats_ = new ::std::string;
  }
  stats_->assign(value);
}
inline void MetaDataMap::set_stats(const void* value, size_t size) {
  _set_bit(4);
  if (stats_ == &_default_stats_) {
    stats_ = new ::std::string;
  }
  stats_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MetaDataMap::mutable_stats() {
  _set_bit(4);
  if (stats_ == &_default_stats_) {
    stats_ = new ::std::string;
  }
  return stats_;
}

// optional bytes tag = 6;
inline bool MetaDataMap::has_tag() const {
  return _has_bit(5);
}
inline void MetaDataMap::clear_tag() {
  if (tag_ != &_default_tag_) {
    tag_->clear();
  }
  _clear_bit(5);
}
inline const ::std::string& MetaDataMap::tag() const {
  return *tag_;
}
inline void MetaDataMap::set_tag(const ::std::string& value) {
  _set_bit(5);
  if (tag_ == &_default_tag_) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
}
inline void MetaDataMap::set_tag(const char* value) {
  _set_bit(5);
  if (tag_ == &_default_tag_) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
}
inline void MetaDataMap::set_tag(const void* value, size_t size) {
  _set_bit(5);
  if (tag_ == &_default_tag_) {
    tag_ = new ::std::string;
  }
  tag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MetaDataMap::mutable_tag() {
  _set_bit(5);
  if (tag_ == &_default_tag_) {
    tag_ = new ::std::string;
  }
  return tag_;
}

// optional int32 file_size_high = 7;
inline bool MetaDataMap::has_file_size_high() const {
  return _has_bit(6);
}
inline void MetaDataMap::clear_file_size_high() {
  file_size_high_ = 0;
  _clear_bit(6);
}
inline ::google::protobuf::int32 MetaDataMap::file_size_high() const {
  return file_size_high_;
}
inline void MetaDataMap::set_file_size_high(::google::protobuf::int32 value) {
  _set_bit(6);
  file_size_high_ = value;
}

// optional int32 file_size_low = 8;
inline bool MetaDataMap::has_file_size_low() const {
  return _has_bit(7);
}
inline void MetaDataMap::clear_file_size_low() {
  file_size_low_ = 0;
  _clear_bit(7);
}
inline ::google::protobuf::int32 MetaDataMap::file_size_low() const {
  return file_size_low_;
}
inline void MetaDataMap::set_file_size_low(::google::protobuf::int32 value) {
  _set_bit(7);
  file_size_low_ = value;
}

// optional int32 creation_time = 9;
inline bool MetaDataMap::has_creation_time() const {
  return _has_bit(8);
}
inline void MetaDataMap::clear_creation_time() {
  creation_time_ = 0;
  _clear_bit(8);
}
inline ::google::protobuf::int32 MetaDataMap::creation_time() const {
  return creation_time_;
}
inline void MetaDataMap::set_creation_time(::google::protobuf::int32 value) {
  _set_bit(8);
  creation_time_ = value;
}

// optional int32 last_modified = 10;
inline bool MetaDataMap::has_last_modified() const {
  return _has_bit(9);
}
inline void MetaDataMap::clear_last_modified() {
  last_modified_ = 0;
  _clear_bit(9);
}
inline ::google::protobuf::int32 MetaDataMap::last_modified() const {
  return last_modified_;
}
inline void MetaDataMap::set_last_modified(::google::protobuf::int32 value) {
  _set_bit(9);
  last_modified_ = value;
}

// optional int32 last_access = 11;
inline bool MetaDataMap::has_last_access() const {
  return _has_bit(10);
}
inline void MetaDataMap::clear_last_access() {
  last_access_ = 0;
  _clear_bit(10);
}
inline ::google::protobuf::int32 MetaDataMap::last_access() const {
  return last_access_;
}
inline void MetaDataMap::set_last_access(::google::protobuf::int32 value) {
  _set_bit(10);
  last_access_ = value;
}

// -------------------------------------------------------------------

// Chunk

// optional bytes compression_type = 1;
inline bool Chunk::has_compression_type() const {
  return _has_bit(0);
}
inline void Chunk::clear_compression_type() {
  if (compression_type_ != &_default_compression_type_) {
    compression_type_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& Chunk::compression_type() const {
  return *compression_type_;
}
inline void Chunk::set_compression_type(const ::std::string& value) {
  _set_bit(0);
  if (compression_type_ == &_default_compression_type_) {
    compression_type_ = new ::std::string;
  }
  compression_type_->assign(value);
}
inline void Chunk::set_compression_type(const char* value) {
  _set_bit(0);
  if (compression_type_ == &_default_compression_type_) {
    compression_type_ = new ::std::string;
  }
  compression_type_->assign(value);
}
inline void Chunk::set_compression_type(const void* value, size_t size) {
  _set_bit(0);
  if (compression_type_ == &_default_compression_type_) {
    compression_type_ = new ::std::string;
  }
  compression_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Chunk::mutable_compression_type() {
  _set_bit(0);
  if (compression_type_ == &_default_compression_type_) {
    compression_type_ = new ::std::string;
  }
  return compression_type_;
}

// repeated bytes chunklet = 2;
inline int Chunk::chunklet_size() const {
  return chunklet_.size();
}
inline void Chunk::clear_chunklet() {
  chunklet_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Chunk::chunklet() const {
  return chunklet_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Chunk::mutable_chunklet() {
  return &chunklet_;
}
inline const ::std::string& Chunk::chunklet(int index) const {
  return chunklet_.Get(index);
}
inline ::std::string* Chunk::mutable_chunklet(int index) {
  return chunklet_.Mutable(index);
}
inline void Chunk::set_chunklet(int index, const ::std::string& value) {
  chunklet_.Mutable(index)->assign(value);
}
inline void Chunk::set_chunklet(int index, const char* value) {
  chunklet_.Mutable(index)->assign(value);
}
inline void Chunk::set_chunklet(int index, const void* value, size_t size) {
  chunklet_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Chunk::add_chunklet() {
  return chunklet_.Add();
}
inline void Chunk::add_chunklet(const ::std::string& value) {
  chunklet_.Add()->assign(value);
}
inline void Chunk::add_chunklet(const char* value) {
  chunklet_.Add()->assign(value);
}
inline void Chunk::add_chunklet(const void* value, size_t size) {
  chunklet_.Add()->assign(reinterpret_cast<const char*>(value), size);
}

// repeated int32 pre_compression_chunklet_size = 3;
inline int Chunk::pre_compression_chunklet_size_size() const {
  return pre_compression_chunklet_size_.size();
}
inline void Chunk::clear_pre_compression_chunklet_size() {
  pre_compression_chunklet_size_.Clear();
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Chunk::pre_compression_chunklet_size() const {
  return pre_compression_chunklet_size_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Chunk::mutable_pre_compression_chunklet_size() {
  return &pre_compression_chunklet_size_;
}
inline ::google::protobuf::int32 Chunk::pre_compression_chunklet_size(int index) const {
  return pre_compression_chunklet_size_.Get(index);
}
inline void Chunk::set_pre_compression_chunklet_size(int index, ::google::protobuf::int32 value) {
  pre_compression_chunklet_size_.Set(index, value);
}
inline void Chunk::add_pre_compression_chunklet_size(::google::protobuf::int32 value) {
  pre_compression_chunklet_size_.Add(value);
}

// -------------------------------------------------------------------

// DataAtlas

// optional bytes root_db_key = 1;
inline bool DataAtlas::has_root_db_key() const {
  return _has_bit(0);
}
inline void DataAtlas::clear_root_db_key() {
  if (root_db_key_ != &_default_root_db_key_) {
    root_db_key_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& DataAtlas::root_db_key() const {
  return *root_db_key_;
}
inline void DataAtlas::set_root_db_key(const ::std::string& value) {
  _set_bit(0);
  if (root_db_key_ == &_default_root_db_key_) {
    root_db_key_ = new ::std::string;
  }
  root_db_key_->assign(value);
}
inline void DataAtlas::set_root_db_key(const char* value) {
  _set_bit(0);
  if (root_db_key_ == &_default_root_db_key_) {
    root_db_key_ = new ::std::string;
  }
  root_db_key_->assign(value);
}
inline void DataAtlas::set_root_db_key(const void* value, size_t size) {
  _set_bit(0);
  if (root_db_key_ == &_default_root_db_key_) {
    root_db_key_ = new ::std::string;
  }
  root_db_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DataAtlas::mutable_root_db_key() {
  _set_bit(0);
  if (root_db_key_ == &_default_root_db_key_) {
    root_db_key_ = new ::std::string;
  }
  return root_db_key_;
}

// repeated .maidsafe.Key keys = 2;
inline int DataAtlas::keys_size() const {
  return keys_.size();
}
inline void DataAtlas::clear_keys() {
  keys_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::maidsafe::Key >&
DataAtlas::keys() const {
  return keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::maidsafe::Key >*
DataAtlas::mutable_keys() {
  return &keys_;
}
inline const ::maidsafe::Key& DataAtlas::keys(int index) const {
  return keys_.Get(index);
}
inline ::maidsafe::Key* DataAtlas::mutable_keys(int index) {
  return keys_.Mutable(index);
}
inline ::maidsafe::Key* DataAtlas::add_keys() {
  return keys_.Add();
}

// repeated .maidsafe.MetaDataMap mdms = 3;
inline int DataAtlas::mdms_size() const {
  return mdms_.size();
}
inline void DataAtlas::clear_mdms() {
  mdms_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::maidsafe::MetaDataMap >&
DataAtlas::mdms() const {
  return mdms_;
}
inline ::google::protobuf::RepeatedPtrField< ::maidsafe::MetaDataMap >*
DataAtlas::mutable_mdms() {
  return &mdms_;
}
inline const ::maidsafe::MetaDataMap& DataAtlas::mdms(int index) const {
  return mdms_.Get(index);
}
inline ::maidsafe::MetaDataMap* DataAtlas::mutable_mdms(int index) {
  return mdms_.Mutable(index);
}
inline ::maidsafe::MetaDataMap* DataAtlas::add_mdms() {
  return mdms_.Add();
}

// repeated .maidsafe.DataMap dms = 4;
inline int DataAtlas::dms_size() const {
  return dms_.size();
}
inline void DataAtlas::clear_dms() {
  dms_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::maidsafe::DataMap >&
DataAtlas::dms() const {
  return dms_;
}
inline ::google::protobuf::RepeatedPtrField< ::maidsafe::DataMap >*
DataAtlas::mutable_dms() {
  return &dms_;
}
inline const ::maidsafe::DataMap& DataAtlas::dms(int index) const {
  return dms_.Get(index);
}
inline ::maidsafe::DataMap* DataAtlas::mutable_dms(int index) {
  return dms_.Mutable(index);
}
inline ::maidsafe::DataMap* DataAtlas::add_dms() {
  return dms_.Add();
}


}  // namespace maidsafe
#endif  // PROTOBUF_datamaps_2eproto__INCLUDED
