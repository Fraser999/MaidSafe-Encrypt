// Generated by the protocol buffer compiler.  DO NOT EDIT!

#ifndef PROTOBUF_maidsafe_5fservice_5fmessages_2eproto__INCLUDED
#define PROTOBUF_maidsafe_5fservice_5fmessages_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2001000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2001000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>

namespace maidsafe {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();

class IOUAuthority;
class IOU;
class StorePrepRequest;
class StorePrepResponse;
class StoreRequest;
class StoreResponse;
class StoreIOURequest;
class StoreIOUResponse;
class IOUDoneRequest;
class IOUDoneResponse;
class RankAuthority;
class StoreReferenceRequest;
class StoreReferenceResponse;
class DeleteRequest;
class DeleteResponse;
class GetRequest;
class GetResponse;
class CheckChunkRequest;
class CheckChunkResponse;
class ValidityCheckRequest;
class ValidityCheckResponse;
class UpdateRequest;
class UpdateResponse;
class GetMessagesRequest;
class GetMessagesResponse;
class SwapChunkRequest;
class SwapChunkResponse;
class VaultCommunication;
class VaultStatusRequest;
class VaultStatusResponse;
class OwnVaultRequest;
class OwnVaultResponse;
class IsOwnedRequest;
class IsOwnedResponse;

enum OwnVaultResult {
  OWNED_SUCCESS = 0,
  VAULT_ALREADY_OWNED = 1,
  VAULT_IS_DOWN = 2,
  INVALID_RSA_KEYS = 3,
  NOT_ENOUGH_SPACE = 4,
  NO_SPACE_ALLOCATED = 5,
  INVALID_PORT = 6,
  FAILED_TO_START_VAULT = 7,
  INVALID_OWNREQUEST = 8,
  INVALID_PMID_NAME = 9
};
const ::google::protobuf::EnumDescriptor* OwnVaultResult_descriptor();
bool OwnVaultResult_IsValid(int value);
const OwnVaultResult OwnVaultResult_MIN = OWNED_SUCCESS;
const OwnVaultResult OwnVaultResult_MAX = INVALID_PMID_NAME;

inline const ::std::string& OwnVaultResult_Name(OwnVaultResult value) {
  return ::google::protobuf::internal::NameOfEnum(
    OwnVaultResult_descriptor(), value);
}
inline bool OwnVaultResult_Parse(
    const ::std::string& name, OwnVaultResult* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OwnVaultResult>(
    OwnVaultResult_descriptor(), name, value);
}
enum VaultStatus {
  NOT_OWNED = 0,
  OWNED = 1,
  DOWN = 2,
  ISOWNRPC_CANCELLED = 3
};
const ::google::protobuf::EnumDescriptor* VaultStatus_descriptor();
bool VaultStatus_IsValid(int value);
const VaultStatus VaultStatus_MIN = NOT_OWNED;
const VaultStatus VaultStatus_MAX = ISOWNRPC_CANCELLED;

inline const ::std::string& VaultStatus_Name(VaultStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    VaultStatus_descriptor(), value);
}
inline bool VaultStatus_Parse(
    const ::std::string& name, VaultStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VaultStatus>(
    VaultStatus_descriptor(), name, value);
}
// ===================================================================

class IOUAuthority : public ::google::protobuf::Message {
 public:
  IOUAuthority();
  virtual ~IOUAuthority();
  
  IOUAuthority(const IOUAuthority& from);
  
  inline IOUAuthority& operator=(const IOUAuthority& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const IOUAuthority& default_instance();
  void Swap(IOUAuthority* other);
  
  // implements Message ----------------------------------------------
  
  IOUAuthority* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IOUAuthority& from);
  void MergeFrom(const IOUAuthority& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint64 data_size = 1;
  inline bool has_data_size() const;
  inline void clear_data_size();
  static const int kDataSizeFieldNumber = 1;
  inline ::google::protobuf::uint64 data_size() const;
  inline void set_data_size(::google::protobuf::uint64 value);
  
  // required bytes pmid = 2;
  inline bool has_pmid() const;
  inline void clear_pmid();
  static const int kPmidFieldNumber = 2;
  inline const ::std::string& pmid() const;
  inline void set_pmid(const ::std::string& value);
  inline void set_pmid(const char* value);
  inline void set_pmid(const void* value, size_t size);
  inline ::std::string* mutable_pmid();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint64 data_size_;
  ::std::string* pmid_;
  static const ::std::string _default_pmid_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static IOUAuthority* default_instance_;
};
// -------------------------------------------------------------------

class IOU : public ::google::protobuf::Message {
 public:
  IOU();
  virtual ~IOU();
  
  IOU(const IOU& from);
  
  inline IOU& operator=(const IOU& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const IOU& default_instance();
  void Swap(IOU* other);
  
  // implements Message ----------------------------------------------
  
  IOU* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IOU& from);
  void MergeFrom(const IOU& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes serialised_iou_authority = 1;
  inline bool has_serialised_iou_authority() const;
  inline void clear_serialised_iou_authority();
  static const int kSerialisedIouAuthorityFieldNumber = 1;
  inline const ::std::string& serialised_iou_authority() const;
  inline void set_serialised_iou_authority(const ::std::string& value);
  inline void set_serialised_iou_authority(const char* value);
  inline void set_serialised_iou_authority(const void* value, size_t size);
  inline ::std::string* mutable_serialised_iou_authority();
  
  // required bytes signed_iou_authority = 2;
  inline bool has_signed_iou_authority() const;
  inline void clear_signed_iou_authority();
  static const int kSignedIouAuthorityFieldNumber = 2;
  inline const ::std::string& signed_iou_authority() const;
  inline void set_signed_iou_authority(const ::std::string& value);
  inline void set_signed_iou_authority(const char* value);
  inline void set_signed_iou_authority(const void* value, size_t size);
  inline ::std::string* mutable_signed_iou_authority();
  
  // required bytes signature = 3;
  inline bool has_signature() const;
  inline void clear_signature();
  static const int kSignatureFieldNumber = 3;
  inline const ::std::string& signature() const;
  inline void set_signature(const ::std::string& value);
  inline void set_signature(const char* value);
  inline void set_signature(const void* value, size_t size);
  inline ::std::string* mutable_signature();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* serialised_iou_authority_;
  static const ::std::string _default_serialised_iou_authority_;
  ::std::string* signed_iou_authority_;
  static const ::std::string _default_signed_iou_authority_;
  ::std::string* signature_;
  static const ::std::string _default_signature_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static IOU* default_instance_;
};
// -------------------------------------------------------------------

class StorePrepRequest : public ::google::protobuf::Message {
 public:
  StorePrepRequest();
  virtual ~StorePrepRequest();
  
  StorePrepRequest(const StorePrepRequest& from);
  
  inline StorePrepRequest& operator=(const StorePrepRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StorePrepRequest& default_instance();
  void Swap(StorePrepRequest* other);
  
  // implements Message ----------------------------------------------
  
  StorePrepRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StorePrepRequest& from);
  void MergeFrom(const StorePrepRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes chunkname = 1;
  inline bool has_chunkname() const;
  inline void clear_chunkname();
  static const int kChunknameFieldNumber = 1;
  inline const ::std::string& chunkname() const;
  inline void set_chunkname(const ::std::string& value);
  inline void set_chunkname(const char* value);
  inline void set_chunkname(const void* value, size_t size);
  inline ::std::string* mutable_chunkname();
  
  // required uint64 data_size = 2;
  inline bool has_data_size() const;
  inline void clear_data_size();
  static const int kDataSizeFieldNumber = 2;
  inline ::google::protobuf::uint64 data_size() const;
  inline void set_data_size(::google::protobuf::uint64 value);
  
  // required bytes pmid = 3;
  inline bool has_pmid() const;
  inline void clear_pmid();
  static const int kPmidFieldNumber = 3;
  inline const ::std::string& pmid() const;
  inline void set_pmid(const ::std::string& value);
  inline void set_pmid(const char* value);
  inline void set_pmid(const void* value, size_t size);
  inline ::std::string* mutable_pmid();
  
  // required bytes public_key = 4;
  inline bool has_public_key() const;
  inline void clear_public_key();
  static const int kPublicKeyFieldNumber = 4;
  inline const ::std::string& public_key() const;
  inline void set_public_key(const ::std::string& value);
  inline void set_public_key(const char* value);
  inline void set_public_key(const void* value, size_t size);
  inline ::std::string* mutable_public_key();
  
  // required bytes signed_public_key = 5;
  inline bool has_signed_public_key() const;
  inline void clear_signed_public_key();
  static const int kSignedPublicKeyFieldNumber = 5;
  inline const ::std::string& signed_public_key() const;
  inline void set_signed_public_key(const ::std::string& value);
  inline void set_signed_public_key(const char* value);
  inline void set_signed_public_key(const void* value, size_t size);
  inline ::std::string* mutable_signed_public_key();
  
  // required bytes signed_request = 6;
  inline bool has_signed_request() const;
  inline void clear_signed_request();
  static const int kSignedRequestFieldNumber = 6;
  inline const ::std::string& signed_request() const;
  inline void set_signed_request(const ::std::string& value);
  inline void set_signed_request(const char* value);
  inline void set_signed_request(const void* value, size_t size);
  inline ::std::string* mutable_signed_request();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* chunkname_;
  static const ::std::string _default_chunkname_;
  ::google::protobuf::uint64 data_size_;
  ::std::string* pmid_;
  static const ::std::string _default_pmid_;
  ::std::string* public_key_;
  static const ::std::string _default_public_key_;
  ::std::string* signed_public_key_;
  static const ::std::string _default_signed_public_key_;
  ::std::string* signed_request_;
  static const ::std::string _default_signed_request_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static StorePrepRequest* default_instance_;
};
// -------------------------------------------------------------------

class StorePrepResponse : public ::google::protobuf::Message {
 public:
  StorePrepResponse();
  virtual ~StorePrepResponse();
  
  StorePrepResponse(const StorePrepResponse& from);
  
  inline StorePrepResponse& operator=(const StorePrepResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StorePrepResponse& default_instance();
  void Swap(StorePrepResponse* other);
  
  // implements Message ----------------------------------------------
  
  StorePrepResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StorePrepResponse& from);
  void MergeFrom(const StorePrepResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);
  
  // optional bytes pmid_id = 2;
  inline bool has_pmid_id() const;
  inline void clear_pmid_id();
  static const int kPmidIdFieldNumber = 2;
  inline const ::std::string& pmid_id() const;
  inline void set_pmid_id(const ::std::string& value);
  inline void set_pmid_id(const char* value);
  inline void set_pmid_id(const void* value, size_t size);
  inline ::std::string* mutable_pmid_id();
  
  // optional bytes iou_authority = 3;
  inline bool has_iou_authority() const;
  inline void clear_iou_authority();
  static const int kIouAuthorityFieldNumber = 3;
  inline const ::std::string& iou_authority() const;
  inline void set_iou_authority(const ::std::string& value);
  inline void set_iou_authority(const char* value);
  inline void set_iou_authority(const void* value, size_t size);
  inline ::std::string* mutable_iou_authority();
  
  // optional bytes signed_iou_authority = 4;
  inline bool has_signed_iou_authority() const;
  inline void clear_signed_iou_authority();
  static const int kSignedIouAuthorityFieldNumber = 4;
  inline const ::std::string& signed_iou_authority() const;
  inline void set_signed_iou_authority(const ::std::string& value);
  inline void set_signed_iou_authority(const char* value);
  inline void set_signed_iou_authority(const void* value, size_t size);
  inline ::std::string* mutable_signed_iou_authority();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 result_;
  ::std::string* pmid_id_;
  static const ::std::string _default_pmid_id_;
  ::std::string* iou_authority_;
  static const ::std::string _default_iou_authority_;
  ::std::string* signed_iou_authority_;
  static const ::std::string _default_signed_iou_authority_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static StorePrepResponse* default_instance_;
};
// -------------------------------------------------------------------

class StoreRequest : public ::google::protobuf::Message {
 public:
  StoreRequest();
  virtual ~StoreRequest();
  
  StoreRequest(const StoreRequest& from);
  
  inline StoreRequest& operator=(const StoreRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StoreRequest& default_instance();
  void Swap(StoreRequest* other);
  
  // implements Message ----------------------------------------------
  
  StoreRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StoreRequest& from);
  void MergeFrom(const StoreRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes chunkname = 1;
  inline bool has_chunkname() const;
  inline void clear_chunkname();
  static const int kChunknameFieldNumber = 1;
  inline const ::std::string& chunkname() const;
  inline void set_chunkname(const ::std::string& value);
  inline void set_chunkname(const char* value);
  inline void set_chunkname(const void* value, size_t size);
  inline ::std::string* mutable_chunkname();
  
  // required bytes data = 2;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  
  // optional bytes pmid = 3;
  inline bool has_pmid() const;
  inline void clear_pmid();
  static const int kPmidFieldNumber = 3;
  inline const ::std::string& pmid() const;
  inline void set_pmid(const ::std::string& value);
  inline void set_pmid(const char* value);
  inline void set_pmid(const void* value, size_t size);
  inline ::std::string* mutable_pmid();
  
  // required bytes public_key = 4;
  inline bool has_public_key() const;
  inline void clear_public_key();
  static const int kPublicKeyFieldNumber = 4;
  inline const ::std::string& public_key() const;
  inline void set_public_key(const ::std::string& value);
  inline void set_public_key(const char* value);
  inline void set_public_key(const void* value, size_t size);
  inline ::std::string* mutable_public_key();
  
  // required bytes signed_public_key = 5;
  inline bool has_signed_public_key() const;
  inline void clear_signed_public_key();
  static const int kSignedPublicKeyFieldNumber = 5;
  inline const ::std::string& signed_public_key() const;
  inline void set_signed_public_key(const ::std::string& value);
  inline void set_signed_public_key(const char* value);
  inline void set_signed_public_key(const void* value, size_t size);
  inline ::std::string* mutable_signed_public_key();
  
  // required bytes signed_request = 6;
  inline bool has_signed_request() const;
  inline void clear_signed_request();
  static const int kSignedRequestFieldNumber = 6;
  inline const ::std::string& signed_request() const;
  inline void set_signed_request(const ::std::string& value);
  inline void set_signed_request(const char* value);
  inline void set_signed_request(const void* value, size_t size);
  inline ::std::string* mutable_signed_request();
  
  // required uint32 data_type = 7;
  inline bool has_data_type() const;
  inline void clear_data_type();
  static const int kDataTypeFieldNumber = 7;
  inline ::google::protobuf::uint32 data_type() const;
  inline void set_data_type(::google::protobuf::uint32 value);
  
  // optional uint32 offset = 8;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 8;
  inline ::google::protobuf::uint32 offset() const;
  inline void set_offset(::google::protobuf::uint32 value);
  
  // optional uint32 chunklet_size = 9;
  inline bool has_chunklet_size() const;
  inline void clear_chunklet_size();
  static const int kChunkletSizeFieldNumber = 9;
  inline ::google::protobuf::uint32 chunklet_size() const;
  inline void set_chunklet_size(::google::protobuf::uint32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* chunkname_;
  static const ::std::string _default_chunkname_;
  ::std::string* data_;
  static const ::std::string _default_data_;
  ::std::string* pmid_;
  static const ::std::string _default_pmid_;
  ::std::string* public_key_;
  static const ::std::string _default_public_key_;
  ::std::string* signed_public_key_;
  static const ::std::string _default_signed_public_key_;
  ::std::string* signed_request_;
  static const ::std::string _default_signed_request_;
  ::google::protobuf::uint32 data_type_;
  ::google::protobuf::uint32 offset_;
  ::google::protobuf::uint32 chunklet_size_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static StoreRequest* default_instance_;
};
// -------------------------------------------------------------------

class StoreResponse : public ::google::protobuf::Message {
 public:
  StoreResponse();
  virtual ~StoreResponse();
  
  StoreResponse(const StoreResponse& from);
  
  inline StoreResponse& operator=(const StoreResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StoreResponse& default_instance();
  void Swap(StoreResponse* other);
  
  // implements Message ----------------------------------------------
  
  StoreResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StoreResponse& from);
  void MergeFrom(const StoreResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);
  
  // optional bytes pmid_id = 2;
  inline bool has_pmid_id() const;
  inline void clear_pmid_id();
  static const int kPmidIdFieldNumber = 2;
  inline const ::std::string& pmid_id() const;
  inline void set_pmid_id(const ::std::string& value);
  inline void set_pmid_id(const char* value);
  inline void set_pmid_id(const void* value, size_t size);
  inline ::std::string* mutable_pmid_id();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 result_;
  ::std::string* pmid_id_;
  static const ::std::string _default_pmid_id_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static StoreResponse* default_instance_;
};
// -------------------------------------------------------------------

class StoreIOURequest : public ::google::protobuf::Message {
 public:
  StoreIOURequest();
  virtual ~StoreIOURequest();
  
  StoreIOURequest(const StoreIOURequest& from);
  
  inline StoreIOURequest& operator=(const StoreIOURequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StoreIOURequest& default_instance();
  void Swap(StoreIOURequest* other);
  
  // implements Message ----------------------------------------------
  
  StoreIOURequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StoreIOURequest& from);
  void MergeFrom(const StoreIOURequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes chunkname = 1;
  inline bool has_chunkname() const;
  inline void clear_chunkname();
  static const int kChunknameFieldNumber = 1;
  inline const ::std::string& chunkname() const;
  inline void set_chunkname(const ::std::string& value);
  inline void set_chunkname(const char* value);
  inline void set_chunkname(const void* value, size_t size);
  inline ::std::string* mutable_chunkname();
  
  // required uint64 data_size = 2;
  inline bool has_data_size() const;
  inline void clear_data_size();
  static const int kDataSizeFieldNumber = 2;
  inline ::google::protobuf::uint64 data_size() const;
  inline void set_data_size(::google::protobuf::uint64 value);
  
  // required bytes collector_pmid = 3;
  inline bool has_collector_pmid() const;
  inline void clear_collector_pmid();
  static const int kCollectorPmidFieldNumber = 3;
  inline const ::std::string& collector_pmid() const;
  inline void set_collector_pmid(const ::std::string& value);
  inline void set_collector_pmid(const char* value);
  inline void set_collector_pmid(const void* value, size_t size);
  inline ::std::string* mutable_collector_pmid();
  
  // required bytes iou = 4;
  inline bool has_iou() const;
  inline void clear_iou();
  static const int kIouFieldNumber = 4;
  inline const ::std::string& iou() const;
  inline void set_iou(const ::std::string& value);
  inline void set_iou(const char* value);
  inline void set_iou(const void* value, size_t size);
  inline ::std::string* mutable_iou();
  
  // required bytes own_pmid = 5;
  inline bool has_own_pmid() const;
  inline void clear_own_pmid();
  static const int kOwnPmidFieldNumber = 5;
  inline const ::std::string& own_pmid() const;
  inline void set_own_pmid(const ::std::string& value);
  inline void set_own_pmid(const char* value);
  inline void set_own_pmid(const void* value, size_t size);
  inline ::std::string* mutable_own_pmid();
  
  // required bytes public_key = 6;
  inline bool has_public_key() const;
  inline void clear_public_key();
  static const int kPublicKeyFieldNumber = 6;
  inline const ::std::string& public_key() const;
  inline void set_public_key(const ::std::string& value);
  inline void set_public_key(const char* value);
  inline void set_public_key(const void* value, size_t size);
  inline ::std::string* mutable_public_key();
  
  // required bytes signed_public_key = 7;
  inline bool has_signed_public_key() const;
  inline void clear_signed_public_key();
  static const int kSignedPublicKeyFieldNumber = 7;
  inline const ::std::string& signed_public_key() const;
  inline void set_signed_public_key(const ::std::string& value);
  inline void set_signed_public_key(const char* value);
  inline void set_signed_public_key(const void* value, size_t size);
  inline ::std::string* mutable_signed_public_key();
  
  // required bytes signed_request = 8;
  inline bool has_signed_request() const;
  inline void clear_signed_request();
  static const int kSignedRequestFieldNumber = 8;
  inline const ::std::string& signed_request() const;
  inline void set_signed_request(const ::std::string& value);
  inline void set_signed_request(const char* value);
  inline void set_signed_request(const void* value, size_t size);
  inline ::std::string* mutable_signed_request();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* chunkname_;
  static const ::std::string _default_chunkname_;
  ::google::protobuf::uint64 data_size_;
  ::std::string* collector_pmid_;
  static const ::std::string _default_collector_pmid_;
  ::std::string* iou_;
  static const ::std::string _default_iou_;
  ::std::string* own_pmid_;
  static const ::std::string _default_own_pmid_;
  ::std::string* public_key_;
  static const ::std::string _default_public_key_;
  ::std::string* signed_public_key_;
  static const ::std::string _default_signed_public_key_;
  ::std::string* signed_request_;
  static const ::std::string _default_signed_request_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static StoreIOURequest* default_instance_;
};
// -------------------------------------------------------------------

class StoreIOUResponse : public ::google::protobuf::Message {
 public:
  StoreIOUResponse();
  virtual ~StoreIOUResponse();
  
  StoreIOUResponse(const StoreIOUResponse& from);
  
  inline StoreIOUResponse& operator=(const StoreIOUResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StoreIOUResponse& default_instance();
  void Swap(StoreIOUResponse* other);
  
  // implements Message ----------------------------------------------
  
  StoreIOUResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StoreIOUResponse& from);
  void MergeFrom(const StoreIOUResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);
  
  // optional bytes pmid_id = 2;
  inline bool has_pmid_id() const;
  inline void clear_pmid_id();
  static const int kPmidIdFieldNumber = 2;
  inline const ::std::string& pmid_id() const;
  inline void set_pmid_id(const ::std::string& value);
  inline void set_pmid_id(const char* value);
  inline void set_pmid_id(const void* value, size_t size);
  inline ::std::string* mutable_pmid_id();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 result_;
  ::std::string* pmid_id_;
  static const ::std::string _default_pmid_id_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static StoreIOUResponse* default_instance_;
};
// -------------------------------------------------------------------

class IOUDoneRequest : public ::google::protobuf::Message {
 public:
  IOUDoneRequest();
  virtual ~IOUDoneRequest();
  
  IOUDoneRequest(const IOUDoneRequest& from);
  
  inline IOUDoneRequest& operator=(const IOUDoneRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const IOUDoneRequest& default_instance();
  void Swap(IOUDoneRequest* other);
  
  // implements Message ----------------------------------------------
  
  IOUDoneRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IOUDoneRequest& from);
  void MergeFrom(const IOUDoneRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes chunkname = 1;
  inline bool has_chunkname() const;
  inline void clear_chunkname();
  static const int kChunknameFieldNumber = 1;
  inline const ::std::string& chunkname() const;
  inline void set_chunkname(const ::std::string& value);
  inline void set_chunkname(const char* value);
  inline void set_chunkname(const void* value, size_t size);
  inline ::std::string* mutable_chunkname();
  
  // required bytes public_key = 2;
  inline bool has_public_key() const;
  inline void clear_public_key();
  static const int kPublicKeyFieldNumber = 2;
  inline const ::std::string& public_key() const;
  inline void set_public_key(const ::std::string& value);
  inline void set_public_key(const char* value);
  inline void set_public_key(const void* value, size_t size);
  inline ::std::string* mutable_public_key();
  
  // required bytes signed_public_key = 3;
  inline bool has_signed_public_key() const;
  inline void clear_signed_public_key();
  static const int kSignedPublicKeyFieldNumber = 3;
  inline const ::std::string& signed_public_key() const;
  inline void set_signed_public_key(const ::std::string& value);
  inline void set_signed_public_key(const char* value);
  inline void set_signed_public_key(const void* value, size_t size);
  inline ::std::string* mutable_signed_public_key();
  
  // required bytes signed_request = 4;
  inline bool has_signed_request() const;
  inline void clear_signed_request();
  static const int kSignedRequestFieldNumber = 4;
  inline const ::std::string& signed_request() const;
  inline void set_signed_request(const ::std::string& value);
  inline void set_signed_request(const char* value);
  inline void set_signed_request(const void* value, size_t size);
  inline ::std::string* mutable_signed_request();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* chunkname_;
  static const ::std::string _default_chunkname_;
  ::std::string* public_key_;
  static const ::std::string _default_public_key_;
  ::std::string* signed_public_key_;
  static const ::std::string _default_signed_public_key_;
  ::std::string* signed_request_;
  static const ::std::string _default_signed_request_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static IOUDoneRequest* default_instance_;
};
// -------------------------------------------------------------------

class IOUDoneResponse : public ::google::protobuf::Message {
 public:
  IOUDoneResponse();
  virtual ~IOUDoneResponse();
  
  IOUDoneResponse(const IOUDoneResponse& from);
  
  inline IOUDoneResponse& operator=(const IOUDoneResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const IOUDoneResponse& default_instance();
  void Swap(IOUDoneResponse* other);
  
  // implements Message ----------------------------------------------
  
  IOUDoneResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IOUDoneResponse& from);
  void MergeFrom(const IOUDoneResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);
  
  // optional bytes pmid_id = 2;
  inline bool has_pmid_id() const;
  inline void clear_pmid_id();
  static const int kPmidIdFieldNumber = 2;
  inline const ::std::string& pmid_id() const;
  inline void set_pmid_id(const ::std::string& value);
  inline void set_pmid_id(const char* value);
  inline void set_pmid_id(const void* value, size_t size);
  inline ::std::string* mutable_pmid_id();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 result_;
  ::std::string* pmid_id_;
  static const ::std::string _default_pmid_id_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static IOUDoneResponse* default_instance_;
};
// -------------------------------------------------------------------

class RankAuthority : public ::google::protobuf::Message {
 public:
  RankAuthority();
  virtual ~RankAuthority();
  
  RankAuthority(const RankAuthority& from);
  
  inline RankAuthority& operator=(const RankAuthority& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RankAuthority& default_instance();
  void Swap(RankAuthority* other);
  
  // implements Message ----------------------------------------------
  
  RankAuthority* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RankAuthority& from);
  void MergeFrom(const RankAuthority& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes chunkname = 1;
  inline bool has_chunkname() const;
  inline void clear_chunkname();
  static const int kChunknameFieldNumber = 1;
  inline const ::std::string& chunkname() const;
  inline void set_chunkname(const ::std::string& value);
  inline void set_chunkname(const char* value);
  inline void set_chunkname(const void* value, size_t size);
  inline ::std::string* mutable_chunkname();
  
  // required uint64 data_size = 2;
  inline bool has_data_size() const;
  inline void clear_data_size();
  static const int kDataSizeFieldNumber = 2;
  inline ::google::protobuf::uint64 data_size() const;
  inline void set_data_size(::google::protobuf::uint64 value);
  
  // required bytes pmid = 3;
  inline bool has_pmid() const;
  inline void clear_pmid();
  static const int kPmidFieldNumber = 3;
  inline const ::std::string& pmid() const;
  inline void set_pmid(const ::std::string& value);
  inline void set_pmid(const char* value);
  inline void set_pmid(const void* value, size_t size);
  inline ::std::string* mutable_pmid();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* chunkname_;
  static const ::std::string _default_chunkname_;
  ::google::protobuf::uint64 data_size_;
  ::std::string* pmid_;
  static const ::std::string _default_pmid_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static RankAuthority* default_instance_;
};
// -------------------------------------------------------------------

class StoreReferenceRequest : public ::google::protobuf::Message {
 public:
  StoreReferenceRequest();
  virtual ~StoreReferenceRequest();
  
  StoreReferenceRequest(const StoreReferenceRequest& from);
  
  inline StoreReferenceRequest& operator=(const StoreReferenceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StoreReferenceRequest& default_instance();
  void Swap(StoreReferenceRequest* other);
  
  // implements Message ----------------------------------------------
  
  StoreReferenceRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StoreReferenceRequest& from);
  void MergeFrom(const StoreReferenceRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes chunkname = 1;
  inline bool has_chunkname() const;
  inline void clear_chunkname();
  static const int kChunknameFieldNumber = 1;
  inline const ::std::string& chunkname() const;
  inline void set_chunkname(const ::std::string& value);
  inline void set_chunkname(const char* value);
  inline void set_chunkname(const void* value, size_t size);
  inline ::std::string* mutable_chunkname();
  
  // required bytes pmid = 2;
  inline bool has_pmid() const;
  inline void clear_pmid();
  static const int kPmidFieldNumber = 2;
  inline const ::std::string& pmid() const;
  inline void set_pmid(const ::std::string& value);
  inline void set_pmid(const char* value);
  inline void set_pmid(const void* value, size_t size);
  inline ::std::string* mutable_pmid();
  
  // required bytes signed_pmid = 3;
  inline bool has_signed_pmid() const;
  inline void clear_signed_pmid();
  static const int kSignedPmidFieldNumber = 3;
  inline const ::std::string& signed_pmid() const;
  inline void set_signed_pmid(const ::std::string& value);
  inline void set_signed_pmid(const char* value);
  inline void set_signed_pmid(const void* value, size_t size);
  inline ::std::string* mutable_signed_pmid();
  
  // required bytes public_key = 4;
  inline bool has_public_key() const;
  inline void clear_public_key();
  static const int kPublicKeyFieldNumber = 4;
  inline const ::std::string& public_key() const;
  inline void set_public_key(const ::std::string& value);
  inline void set_public_key(const char* value);
  inline void set_public_key(const void* value, size_t size);
  inline ::std::string* mutable_public_key();
  
  // required bytes signed_public_key = 5;
  inline bool has_signed_public_key() const;
  inline void clear_signed_public_key();
  static const int kSignedPublicKeyFieldNumber = 5;
  inline const ::std::string& signed_public_key() const;
  inline void set_signed_public_key(const ::std::string& value);
  inline void set_signed_public_key(const char* value);
  inline void set_signed_public_key(const void* value, size_t size);
  inline ::std::string* mutable_signed_public_key();
  
  // required bytes signed_request = 6;
  inline bool has_signed_request() const;
  inline void clear_signed_request();
  static const int kSignedRequestFieldNumber = 6;
  inline const ::std::string& signed_request() const;
  inline void set_signed_request(const ::std::string& value);
  inline void set_signed_request(const char* value);
  inline void set_signed_request(const void* value, size_t size);
  inline ::std::string* mutable_signed_request();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* chunkname_;
  static const ::std::string _default_chunkname_;
  ::std::string* pmid_;
  static const ::std::string _default_pmid_;
  ::std::string* signed_pmid_;
  static const ::std::string _default_signed_pmid_;
  ::std::string* public_key_;
  static const ::std::string _default_public_key_;
  ::std::string* signed_public_key_;
  static const ::std::string _default_signed_public_key_;
  ::std::string* signed_request_;
  static const ::std::string _default_signed_request_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static StoreReferenceRequest* default_instance_;
};
// -------------------------------------------------------------------

class StoreReferenceResponse : public ::google::protobuf::Message {
 public:
  StoreReferenceResponse();
  virtual ~StoreReferenceResponse();
  
  StoreReferenceResponse(const StoreReferenceResponse& from);
  
  inline StoreReferenceResponse& operator=(const StoreReferenceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StoreReferenceResponse& default_instance();
  void Swap(StoreReferenceResponse* other);
  
  // implements Message ----------------------------------------------
  
  StoreReferenceResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StoreReferenceResponse& from);
  void MergeFrom(const StoreReferenceResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);
  
  // optional bytes rank_authority = 2;
  inline bool has_rank_authority() const;
  inline void clear_rank_authority();
  static const int kRankAuthorityFieldNumber = 2;
  inline const ::std::string& rank_authority() const;
  inline void set_rank_authority(const ::std::string& value);
  inline void set_rank_authority(const char* value);
  inline void set_rank_authority(const void* value, size_t size);
  inline ::std::string* mutable_rank_authority();
  
  // optional bytes signed_rank_authority = 3;
  inline bool has_signed_rank_authority() const;
  inline void clear_signed_rank_authority();
  static const int kSignedRankAuthorityFieldNumber = 3;
  inline const ::std::string& signed_rank_authority() const;
  inline void set_signed_rank_authority(const ::std::string& value);
  inline void set_signed_rank_authority(const char* value);
  inline void set_signed_rank_authority(const void* value, size_t size);
  inline ::std::string* mutable_signed_rank_authority();
  
  // optional bytes iou = 4;
  inline bool has_iou() const;
  inline void clear_iou();
  static const int kIouFieldNumber = 4;
  inline const ::std::string& iou() const;
  inline void set_iou(const ::std::string& value);
  inline void set_iou(const char* value);
  inline void set_iou(const void* value, size_t size);
  inline ::std::string* mutable_iou();
  
  // optional bytes pmid_id = 5;
  inline bool has_pmid_id() const;
  inline void clear_pmid_id();
  static const int kPmidIdFieldNumber = 5;
  inline const ::std::string& pmid_id() const;
  inline void set_pmid_id(const ::std::string& value);
  inline void set_pmid_id(const char* value);
  inline void set_pmid_id(const void* value, size_t size);
  inline ::std::string* mutable_pmid_id();
  
  // optional bytes public_key = 6;
  inline bool has_public_key() const;
  inline void clear_public_key();
  static const int kPublicKeyFieldNumber = 6;
  inline const ::std::string& public_key() const;
  inline void set_public_key(const ::std::string& value);
  inline void set_public_key(const char* value);
  inline void set_public_key(const void* value, size_t size);
  inline ::std::string* mutable_public_key();
  
  // optional bytes signed_public_key = 7;
  inline bool has_signed_public_key() const;
  inline void clear_signed_public_key();
  static const int kSignedPublicKeyFieldNumber = 7;
  inline const ::std::string& signed_public_key() const;
  inline void set_signed_public_key(const ::std::string& value);
  inline void set_signed_public_key(const char* value);
  inline void set_signed_public_key(const void* value, size_t size);
  inline ::std::string* mutable_signed_public_key();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 result_;
  ::std::string* rank_authority_;
  static const ::std::string _default_rank_authority_;
  ::std::string* signed_rank_authority_;
  static const ::std::string _default_signed_rank_authority_;
  ::std::string* iou_;
  static const ::std::string _default_iou_;
  ::std::string* pmid_id_;
  static const ::std::string _default_pmid_id_;
  ::std::string* public_key_;
  static const ::std::string _default_public_key_;
  ::std::string* signed_public_key_;
  static const ::std::string _default_signed_public_key_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static StoreReferenceResponse* default_instance_;
};
// -------------------------------------------------------------------

class DeleteRequest : public ::google::protobuf::Message {
 public:
  DeleteRequest();
  virtual ~DeleteRequest();
  
  DeleteRequest(const DeleteRequest& from);
  
  inline DeleteRequest& operator=(const DeleteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteRequest& default_instance();
  void Swap(DeleteRequest* other);
  
  // implements Message ----------------------------------------------
  
  DeleteRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeleteRequest& from);
  void MergeFrom(const DeleteRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes chunkname = 1;
  inline bool has_chunkname() const;
  inline void clear_chunkname();
  static const int kChunknameFieldNumber = 1;
  inline const ::std::string& chunkname() const;
  inline void set_chunkname(const ::std::string& value);
  inline void set_chunkname(const char* value);
  inline void set_chunkname(const void* value, size_t size);
  inline ::std::string* mutable_chunkname();
  
  // required bytes public_key = 2;
  inline bool has_public_key() const;
  inline void clear_public_key();
  static const int kPublicKeyFieldNumber = 2;
  inline const ::std::string& public_key() const;
  inline void set_public_key(const ::std::string& value);
  inline void set_public_key(const char* value);
  inline void set_public_key(const void* value, size_t size);
  inline ::std::string* mutable_public_key();
  
  // required bytes signed_public_key = 3;
  inline bool has_signed_public_key() const;
  inline void clear_signed_public_key();
  static const int kSignedPublicKeyFieldNumber = 3;
  inline const ::std::string& signed_public_key() const;
  inline void set_signed_public_key(const ::std::string& value);
  inline void set_signed_public_key(const char* value);
  inline void set_signed_public_key(const void* value, size_t size);
  inline ::std::string* mutable_signed_public_key();
  
  // required bytes signed_request = 4;
  inline bool has_signed_request() const;
  inline void clear_signed_request();
  static const int kSignedRequestFieldNumber = 4;
  inline const ::std::string& signed_request() const;
  inline void set_signed_request(const ::std::string& value);
  inline void set_signed_request(const char* value);
  inline void set_signed_request(const void* value, size_t size);
  inline ::std::string* mutable_signed_request();
  
  // required int32 data_type = 5;
  inline bool has_data_type() const;
  inline void clear_data_type();
  static const int kDataTypeFieldNumber = 5;
  inline ::google::protobuf::int32 data_type() const;
  inline void set_data_type(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* chunkname_;
  static const ::std::string _default_chunkname_;
  ::std::string* public_key_;
  static const ::std::string _default_public_key_;
  ::std::string* signed_public_key_;
  static const ::std::string _default_signed_public_key_;
  ::std::string* signed_request_;
  static const ::std::string _default_signed_request_;
  ::google::protobuf::int32 data_type_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static DeleteRequest* default_instance_;
};
// -------------------------------------------------------------------

class DeleteResponse : public ::google::protobuf::Message {
 public:
  DeleteResponse();
  virtual ~DeleteResponse();
  
  DeleteResponse(const DeleteResponse& from);
  
  inline DeleteResponse& operator=(const DeleteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteResponse& default_instance();
  void Swap(DeleteResponse* other);
  
  // implements Message ----------------------------------------------
  
  DeleteResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeleteResponse& from);
  void MergeFrom(const DeleteResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);
  
  // optional bytes pmid_id = 2;
  inline bool has_pmid_id() const;
  inline void clear_pmid_id();
  static const int kPmidIdFieldNumber = 2;
  inline const ::std::string& pmid_id() const;
  inline void set_pmid_id(const ::std::string& value);
  inline void set_pmid_id(const char* value);
  inline void set_pmid_id(const void* value, size_t size);
  inline ::std::string* mutable_pmid_id();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 result_;
  ::std::string* pmid_id_;
  static const ::std::string _default_pmid_id_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static DeleteResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetRequest : public ::google::protobuf::Message {
 public:
  GetRequest();
  virtual ~GetRequest();
  
  GetRequest(const GetRequest& from);
  
  inline GetRequest& operator=(const GetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetRequest& default_instance();
  void Swap(GetRequest* other);
  
  // implements Message ----------------------------------------------
  
  GetRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetRequest& from);
  void MergeFrom(const GetRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes chunkname = 1;
  inline bool has_chunkname() const;
  inline void clear_chunkname();
  static const int kChunknameFieldNumber = 1;
  inline const ::std::string& chunkname() const;
  inline void set_chunkname(const ::std::string& value);
  inline void set_chunkname(const char* value);
  inline void set_chunkname(const void* value, size_t size);
  inline ::std::string* mutable_chunkname();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* chunkname_;
  static const ::std::string _default_chunkname_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static GetRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetResponse : public ::google::protobuf::Message {
 public:
  GetResponse();
  virtual ~GetResponse();
  
  GetResponse(const GetResponse& from);
  
  inline GetResponse& operator=(const GetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetResponse& default_instance();
  void Swap(GetResponse* other);
  
  // implements Message ----------------------------------------------
  
  GetResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetResponse& from);
  void MergeFrom(const GetResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);
  
  // optional bytes content = 2;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 2;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const void* value, size_t size);
  inline ::std::string* mutable_content();
  
  // optional bytes pmid_id = 3;
  inline bool has_pmid_id() const;
  inline void clear_pmid_id();
  static const int kPmidIdFieldNumber = 3;
  inline const ::std::string& pmid_id() const;
  inline void set_pmid_id(const ::std::string& value);
  inline void set_pmid_id(const char* value);
  inline void set_pmid_id(const void* value, size_t size);
  inline ::std::string* mutable_pmid_id();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 result_;
  ::std::string* content_;
  static const ::std::string _default_content_;
  ::std::string* pmid_id_;
  static const ::std::string _default_pmid_id_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static GetResponse* default_instance_;
};
// -------------------------------------------------------------------

class CheckChunkRequest : public ::google::protobuf::Message {
 public:
  CheckChunkRequest();
  virtual ~CheckChunkRequest();
  
  CheckChunkRequest(const CheckChunkRequest& from);
  
  inline CheckChunkRequest& operator=(const CheckChunkRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CheckChunkRequest& default_instance();
  void Swap(CheckChunkRequest* other);
  
  // implements Message ----------------------------------------------
  
  CheckChunkRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CheckChunkRequest& from);
  void MergeFrom(const CheckChunkRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes chunkname = 1;
  inline bool has_chunkname() const;
  inline void clear_chunkname();
  static const int kChunknameFieldNumber = 1;
  inline const ::std::string& chunkname() const;
  inline void set_chunkname(const ::std::string& value);
  inline void set_chunkname(const char* value);
  inline void set_chunkname(const void* value, size_t size);
  inline ::std::string* mutable_chunkname();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* chunkname_;
  static const ::std::string _default_chunkname_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static CheckChunkRequest* default_instance_;
};
// -------------------------------------------------------------------

class CheckChunkResponse : public ::google::protobuf::Message {
 public:
  CheckChunkResponse();
  virtual ~CheckChunkResponse();
  
  CheckChunkResponse(const CheckChunkResponse& from);
  
  inline CheckChunkResponse& operator=(const CheckChunkResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CheckChunkResponse& default_instance();
  void Swap(CheckChunkResponse* other);
  
  // implements Message ----------------------------------------------
  
  CheckChunkResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CheckChunkResponse& from);
  void MergeFrom(const CheckChunkResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);
  
  // required bytes pmid_id = 2;
  inline bool has_pmid_id() const;
  inline void clear_pmid_id();
  static const int kPmidIdFieldNumber = 2;
  inline const ::std::string& pmid_id() const;
  inline void set_pmid_id(const ::std::string& value);
  inline void set_pmid_id(const char* value);
  inline void set_pmid_id(const void* value, size_t size);
  inline ::std::string* mutable_pmid_id();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 result_;
  ::std::string* pmid_id_;
  static const ::std::string _default_pmid_id_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static CheckChunkResponse* default_instance_;
};
// -------------------------------------------------------------------

class ValidityCheckRequest : public ::google::protobuf::Message {
 public:
  ValidityCheckRequest();
  virtual ~ValidityCheckRequest();
  
  ValidityCheckRequest(const ValidityCheckRequest& from);
  
  inline ValidityCheckRequest& operator=(const ValidityCheckRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ValidityCheckRequest& default_instance();
  void Swap(ValidityCheckRequest* other);
  
  // implements Message ----------------------------------------------
  
  ValidityCheckRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ValidityCheckRequest& from);
  void MergeFrom(const ValidityCheckRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes chunkname = 1;
  inline bool has_chunkname() const;
  inline void clear_chunkname();
  static const int kChunknameFieldNumber = 1;
  inline const ::std::string& chunkname() const;
  inline void set_chunkname(const ::std::string& value);
  inline void set_chunkname(const char* value);
  inline void set_chunkname(const void* value, size_t size);
  inline ::std::string* mutable_chunkname();
  
  // required bytes random_data = 2;
  inline bool has_random_data() const;
  inline void clear_random_data();
  static const int kRandomDataFieldNumber = 2;
  inline const ::std::string& random_data() const;
  inline void set_random_data(const ::std::string& value);
  inline void set_random_data(const char* value);
  inline void set_random_data(const void* value, size_t size);
  inline ::std::string* mutable_random_data();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* chunkname_;
  static const ::std::string _default_chunkname_;
  ::std::string* random_data_;
  static const ::std::string _default_random_data_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ValidityCheckRequest* default_instance_;
};
// -------------------------------------------------------------------

class ValidityCheckResponse : public ::google::protobuf::Message {
 public:
  ValidityCheckResponse();
  virtual ~ValidityCheckResponse();
  
  ValidityCheckResponse(const ValidityCheckResponse& from);
  
  inline ValidityCheckResponse& operator=(const ValidityCheckResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ValidityCheckResponse& default_instance();
  void Swap(ValidityCheckResponse* other);
  
  // implements Message ----------------------------------------------
  
  ValidityCheckResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ValidityCheckResponse& from);
  void MergeFrom(const ValidityCheckResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);
  
  // optional bytes hash_content = 2;
  inline bool has_hash_content() const;
  inline void clear_hash_content();
  static const int kHashContentFieldNumber = 2;
  inline const ::std::string& hash_content() const;
  inline void set_hash_content(const ::std::string& value);
  inline void set_hash_content(const char* value);
  inline void set_hash_content(const void* value, size_t size);
  inline ::std::string* mutable_hash_content();
  
  // required bytes pmid_id = 3;
  inline bool has_pmid_id() const;
  inline void clear_pmid_id();
  static const int kPmidIdFieldNumber = 3;
  inline const ::std::string& pmid_id() const;
  inline void set_pmid_id(const ::std::string& value);
  inline void set_pmid_id(const char* value);
  inline void set_pmid_id(const void* value, size_t size);
  inline ::std::string* mutable_pmid_id();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 result_;
  ::std::string* hash_content_;
  static const ::std::string _default_hash_content_;
  ::std::string* pmid_id_;
  static const ::std::string _default_pmid_id_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ValidityCheckResponse* default_instance_;
};
// -------------------------------------------------------------------

class UpdateRequest : public ::google::protobuf::Message {
 public:
  UpdateRequest();
  virtual ~UpdateRequest();
  
  UpdateRequest(const UpdateRequest& from);
  
  inline UpdateRequest& operator=(const UpdateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateRequest& default_instance();
  void Swap(UpdateRequest* other);
  
  // implements Message ----------------------------------------------
  
  UpdateRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdateRequest& from);
  void MergeFrom(const UpdateRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes chunkname = 1;
  inline bool has_chunkname() const;
  inline void clear_chunkname();
  static const int kChunknameFieldNumber = 1;
  inline const ::std::string& chunkname() const;
  inline void set_chunkname(const ::std::string& value);
  inline void set_chunkname(const char* value);
  inline void set_chunkname(const void* value, size_t size);
  inline ::std::string* mutable_chunkname();
  
  // required bytes data = 2;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  
  // required bytes public_key = 3;
  inline bool has_public_key() const;
  inline void clear_public_key();
  static const int kPublicKeyFieldNumber = 3;
  inline const ::std::string& public_key() const;
  inline void set_public_key(const ::std::string& value);
  inline void set_public_key(const char* value);
  inline void set_public_key(const void* value, size_t size);
  inline ::std::string* mutable_public_key();
  
  // required bytes signed_public_key = 4;
  inline bool has_signed_public_key() const;
  inline void clear_signed_public_key();
  static const int kSignedPublicKeyFieldNumber = 4;
  inline const ::std::string& signed_public_key() const;
  inline void set_signed_public_key(const ::std::string& value);
  inline void set_signed_public_key(const char* value);
  inline void set_signed_public_key(const void* value, size_t size);
  inline ::std::string* mutable_signed_public_key();
  
  // required bytes signed_request = 5;
  inline bool has_signed_request() const;
  inline void clear_signed_request();
  static const int kSignedRequestFieldNumber = 5;
  inline const ::std::string& signed_request() const;
  inline void set_signed_request(const ::std::string& value);
  inline void set_signed_request(const char* value);
  inline void set_signed_request(const void* value, size_t size);
  inline ::std::string* mutable_signed_request();
  
  // required int32 data_type = 6;
  inline bool has_data_type() const;
  inline void clear_data_type();
  static const int kDataTypeFieldNumber = 6;
  inline ::google::protobuf::int32 data_type() const;
  inline void set_data_type(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* chunkname_;
  static const ::std::string _default_chunkname_;
  ::std::string* data_;
  static const ::std::string _default_data_;
  ::std::string* public_key_;
  static const ::std::string _default_public_key_;
  ::std::string* signed_public_key_;
  static const ::std::string _default_signed_public_key_;
  ::std::string* signed_request_;
  static const ::std::string _default_signed_request_;
  ::google::protobuf::int32 data_type_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static UpdateRequest* default_instance_;
};
// -------------------------------------------------------------------

class UpdateResponse : public ::google::protobuf::Message {
 public:
  UpdateResponse();
  virtual ~UpdateResponse();
  
  UpdateResponse(const UpdateResponse& from);
  
  inline UpdateResponse& operator=(const UpdateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateResponse& default_instance();
  void Swap(UpdateResponse* other);
  
  // implements Message ----------------------------------------------
  
  UpdateResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdateResponse& from);
  void MergeFrom(const UpdateResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);
  
  // optional bytes pmid_id = 2;
  inline bool has_pmid_id() const;
  inline void clear_pmid_id();
  static const int kPmidIdFieldNumber = 2;
  inline const ::std::string& pmid_id() const;
  inline void set_pmid_id(const ::std::string& value);
  inline void set_pmid_id(const char* value);
  inline void set_pmid_id(const void* value, size_t size);
  inline ::std::string* mutable_pmid_id();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 result_;
  ::std::string* pmid_id_;
  static const ::std::string _default_pmid_id_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static UpdateResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetMessagesRequest : public ::google::protobuf::Message {
 public:
  GetMessagesRequest();
  virtual ~GetMessagesRequest();
  
  GetMessagesRequest(const GetMessagesRequest& from);
  
  inline GetMessagesRequest& operator=(const GetMessagesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetMessagesRequest& default_instance();
  void Swap(GetMessagesRequest* other);
  
  // implements Message ----------------------------------------------
  
  GetMessagesRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetMessagesRequest& from);
  void MergeFrom(const GetMessagesRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes buffer_packet_name = 1;
  inline bool has_buffer_packet_name() const;
  inline void clear_buffer_packet_name();
  static const int kBufferPacketNameFieldNumber = 1;
  inline const ::std::string& buffer_packet_name() const;
  inline void set_buffer_packet_name(const ::std::string& value);
  inline void set_buffer_packet_name(const char* value);
  inline void set_buffer_packet_name(const void* value, size_t size);
  inline ::std::string* mutable_buffer_packet_name();
  
  // required bytes public_key = 2;
  inline bool has_public_key() const;
  inline void clear_public_key();
  static const int kPublicKeyFieldNumber = 2;
  inline const ::std::string& public_key() const;
  inline void set_public_key(const ::std::string& value);
  inline void set_public_key(const char* value);
  inline void set_public_key(const void* value, size_t size);
  inline ::std::string* mutable_public_key();
  
  // required bytes signed_public_key = 3;
  inline bool has_signed_public_key() const;
  inline void clear_signed_public_key();
  static const int kSignedPublicKeyFieldNumber = 3;
  inline const ::std::string& signed_public_key() const;
  inline void set_signed_public_key(const ::std::string& value);
  inline void set_signed_public_key(const char* value);
  inline void set_signed_public_key(const void* value, size_t size);
  inline ::std::string* mutable_signed_public_key();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* buffer_packet_name_;
  static const ::std::string _default_buffer_packet_name_;
  ::std::string* public_key_;
  static const ::std::string _default_public_key_;
  ::std::string* signed_public_key_;
  static const ::std::string _default_signed_public_key_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static GetMessagesRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetMessagesResponse : public ::google::protobuf::Message {
 public:
  GetMessagesResponse();
  virtual ~GetMessagesResponse();
  
  GetMessagesResponse(const GetMessagesResponse& from);
  
  inline GetMessagesResponse& operator=(const GetMessagesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetMessagesResponse& default_instance();
  void Swap(GetMessagesResponse* other);
  
  // implements Message ----------------------------------------------
  
  GetMessagesResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetMessagesResponse& from);
  void MergeFrom(const GetMessagesResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);
  
  // repeated bytes messages = 2;
  inline int messages_size() const;
  inline void clear_messages();
  static const int kMessagesFieldNumber = 2;
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& messages() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_messages();
  inline const ::std::string& messages(int index) const;
  inline ::std::string* mutable_messages(int index);
  inline void set_messages(int index, const ::std::string& value);
  inline void set_messages(int index, const char* value);
  inline void set_messages(int index, const void* value, size_t size);
  inline ::std::string* add_messages();
  inline void add_messages(const ::std::string& value);
  inline void add_messages(const char* value);
  inline void add_messages(const void* value, size_t size);
  
  // optional bytes pmid_id = 3;
  inline bool has_pmid_id() const;
  inline void clear_pmid_id();
  static const int kPmidIdFieldNumber = 3;
  inline const ::std::string& pmid_id() const;
  inline void set_pmid_id(const ::std::string& value);
  inline void set_pmid_id(const char* value);
  inline void set_pmid_id(const void* value, size_t size);
  inline ::std::string* mutable_pmid_id();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 result_;
  ::google::protobuf::RepeatedPtrField< ::std::string> messages_;
  ::std::string* pmid_id_;
  static const ::std::string _default_pmid_id_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static GetMessagesResponse* default_instance_;
};
// -------------------------------------------------------------------

class SwapChunkRequest : public ::google::protobuf::Message {
 public:
  SwapChunkRequest();
  virtual ~SwapChunkRequest();
  
  SwapChunkRequest(const SwapChunkRequest& from);
  
  inline SwapChunkRequest& operator=(const SwapChunkRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SwapChunkRequest& default_instance();
  void Swap(SwapChunkRequest* other);
  
  // implements Message ----------------------------------------------
  
  SwapChunkRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SwapChunkRequest& from);
  void MergeFrom(const SwapChunkRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 request_type = 1;
  inline bool has_request_type() const;
  inline void clear_request_type();
  static const int kRequestTypeFieldNumber = 1;
  inline ::google::protobuf::int32 request_type() const;
  inline void set_request_type(::google::protobuf::int32 value);
  
  // required bytes chunkname1 = 2;
  inline bool has_chunkname1() const;
  inline void clear_chunkname1();
  static const int kChunkname1FieldNumber = 2;
  inline const ::std::string& chunkname1() const;
  inline void set_chunkname1(const ::std::string& value);
  inline void set_chunkname1(const char* value);
  inline void set_chunkname1(const void* value, size_t size);
  inline ::std::string* mutable_chunkname1();
  
  // optional bytes chunkcontent1 = 3;
  inline bool has_chunkcontent1() const;
  inline void clear_chunkcontent1();
  static const int kChunkcontent1FieldNumber = 3;
  inline const ::std::string& chunkcontent1() const;
  inline void set_chunkcontent1(const ::std::string& value);
  inline void set_chunkcontent1(const char* value);
  inline void set_chunkcontent1(const void* value, size_t size);
  inline ::std::string* mutable_chunkcontent1();
  
  // optional int32 size1 = 4;
  inline bool has_size1() const;
  inline void clear_size1();
  static const int kSize1FieldNumber = 4;
  inline ::google::protobuf::int32 size1() const;
  inline void set_size1(::google::protobuf::int32 value);
  
  // optional bytes chunkname2 = 5;
  inline bool has_chunkname2() const;
  inline void clear_chunkname2();
  static const int kChunkname2FieldNumber = 5;
  inline const ::std::string& chunkname2() const;
  inline void set_chunkname2(const ::std::string& value);
  inline void set_chunkname2(const char* value);
  inline void set_chunkname2(const void* value, size_t size);
  inline ::std::string* mutable_chunkname2();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 request_type_;
  ::std::string* chunkname1_;
  static const ::std::string _default_chunkname1_;
  ::std::string* chunkcontent1_;
  static const ::std::string _default_chunkcontent1_;
  ::google::protobuf::int32 size1_;
  ::std::string* chunkname2_;
  static const ::std::string _default_chunkname2_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static SwapChunkRequest* default_instance_;
};
// -------------------------------------------------------------------

class SwapChunkResponse : public ::google::protobuf::Message {
 public:
  SwapChunkResponse();
  virtual ~SwapChunkResponse();
  
  SwapChunkResponse(const SwapChunkResponse& from);
  
  inline SwapChunkResponse& operator=(const SwapChunkResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SwapChunkResponse& default_instance();
  void Swap(SwapChunkResponse* other);
  
  // implements Message ----------------------------------------------
  
  SwapChunkResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SwapChunkResponse& from);
  void MergeFrom(const SwapChunkResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 request_type = 1;
  inline bool has_request_type() const;
  inline void clear_request_type();
  static const int kRequestTypeFieldNumber = 1;
  inline ::google::protobuf::int32 request_type() const;
  inline void set_request_type(::google::protobuf::int32 value);
  
  // required uint32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);
  
  // optional bytes chunkname1 = 3;
  inline bool has_chunkname1() const;
  inline void clear_chunkname1();
  static const int kChunkname1FieldNumber = 3;
  inline const ::std::string& chunkname1() const;
  inline void set_chunkname1(const ::std::string& value);
  inline void set_chunkname1(const char* value);
  inline void set_chunkname1(const void* value, size_t size);
  inline ::std::string* mutable_chunkname1();
  
  // optional bytes chunkcontent1 = 4;
  inline bool has_chunkcontent1() const;
  inline void clear_chunkcontent1();
  static const int kChunkcontent1FieldNumber = 4;
  inline const ::std::string& chunkcontent1() const;
  inline void set_chunkcontent1(const ::std::string& value);
  inline void set_chunkcontent1(const char* value);
  inline void set_chunkcontent1(const void* value, size_t size);
  inline ::std::string* mutable_chunkcontent1();
  
  // optional int32 size1 = 5;
  inline bool has_size1() const;
  inline void clear_size1();
  static const int kSize1FieldNumber = 5;
  inline ::google::protobuf::int32 size1() const;
  inline void set_size1(::google::protobuf::int32 value);
  
  // optional bytes chunkname2 = 6;
  inline bool has_chunkname2() const;
  inline void clear_chunkname2();
  static const int kChunkname2FieldNumber = 6;
  inline const ::std::string& chunkname2() const;
  inline void set_chunkname2(const ::std::string& value);
  inline void set_chunkname2(const char* value);
  inline void set_chunkname2(const void* value, size_t size);
  inline ::std::string* mutable_chunkname2();
  
  // optional bytes chunkcontent2 = 7;
  inline bool has_chunkcontent2() const;
  inline void clear_chunkcontent2();
  static const int kChunkcontent2FieldNumber = 7;
  inline const ::std::string& chunkcontent2() const;
  inline void set_chunkcontent2(const ::std::string& value);
  inline void set_chunkcontent2(const char* value);
  inline void set_chunkcontent2(const void* value, size_t size);
  inline ::std::string* mutable_chunkcontent2();
  
  // optional int32 size2 = 8;
  inline bool has_size2() const;
  inline void clear_size2();
  static const int kSize2FieldNumber = 8;
  inline ::google::protobuf::int32 size2() const;
  inline void set_size2(::google::protobuf::int32 value);
  
  // required bytes pmid_id = 9;
  inline bool has_pmid_id() const;
  inline void clear_pmid_id();
  static const int kPmidIdFieldNumber = 9;
  inline const ::std::string& pmid_id() const;
  inline void set_pmid_id(const ::std::string& value);
  inline void set_pmid_id(const char* value);
  inline void set_pmid_id(const void* value, size_t size);
  inline ::std::string* mutable_pmid_id();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 request_type_;
  ::google::protobuf::uint32 result_;
  ::std::string* chunkname1_;
  static const ::std::string _default_chunkname1_;
  ::std::string* chunkcontent1_;
  static const ::std::string _default_chunkcontent1_;
  ::google::protobuf::int32 size1_;
  ::std::string* chunkname2_;
  static const ::std::string _default_chunkname2_;
  ::std::string* chunkcontent2_;
  static const ::std::string _default_chunkcontent2_;
  ::google::protobuf::int32 size2_;
  ::std::string* pmid_id_;
  static const ::std::string _default_pmid_id_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static SwapChunkResponse* default_instance_;
};
// -------------------------------------------------------------------

class VaultCommunication : public ::google::protobuf::Message {
 public:
  VaultCommunication();
  virtual ~VaultCommunication();
  
  VaultCommunication(const VaultCommunication& from);
  
  inline VaultCommunication& operator=(const VaultCommunication& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const VaultCommunication& default_instance();
  void Swap(VaultCommunication* other);
  
  // implements Message ----------------------------------------------
  
  VaultCommunication* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VaultCommunication& from);
  void MergeFrom(const VaultCommunication& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bytes chunkstore = 1;
  inline bool has_chunkstore() const;
  inline void clear_chunkstore();
  static const int kChunkstoreFieldNumber = 1;
  inline const ::std::string& chunkstore() const;
  inline void set_chunkstore(const ::std::string& value);
  inline void set_chunkstore(const char* value);
  inline void set_chunkstore(const void* value, size_t size);
  inline ::std::string* mutable_chunkstore();
  
  // optional uint64 offered_space = 2;
  inline bool has_offered_space() const;
  inline void clear_offered_space();
  static const int kOfferedSpaceFieldNumber = 2;
  inline ::google::protobuf::uint64 offered_space() const;
  inline void set_offered_space(::google::protobuf::uint64 value);
  
  // optional uint64 free_space = 3;
  inline bool has_free_space() const;
  inline void clear_free_space();
  static const int kFreeSpaceFieldNumber = 3;
  inline ::google::protobuf::uint64 free_space() const;
  inline void set_free_space(::google::protobuf::uint64 value);
  
  // required uint32 timestamp = 4;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 4;
  inline ::google::protobuf::uint32 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* chunkstore_;
  static const ::std::string _default_chunkstore_;
  ::google::protobuf::uint64 offered_space_;
  ::google::protobuf::uint64 free_space_;
  ::google::protobuf::uint32 timestamp_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static VaultCommunication* default_instance_;
};
// -------------------------------------------------------------------

class VaultStatusRequest : public ::google::protobuf::Message {
 public:
  VaultStatusRequest();
  virtual ~VaultStatusRequest();
  
  VaultStatusRequest(const VaultStatusRequest& from);
  
  inline VaultStatusRequest& operator=(const VaultStatusRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const VaultStatusRequest& default_instance();
  void Swap(VaultStatusRequest* other);
  
  // implements Message ----------------------------------------------
  
  VaultStatusRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VaultStatusRequest& from);
  void MergeFrom(const VaultStatusRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes encrypted_request = 1;
  inline bool has_encrypted_request() const;
  inline void clear_encrypted_request();
  static const int kEncryptedRequestFieldNumber = 1;
  inline const ::std::string& encrypted_request() const;
  inline void set_encrypted_request(const ::std::string& value);
  inline void set_encrypted_request(const char* value);
  inline void set_encrypted_request(const void* value, size_t size);
  inline ::std::string* mutable_encrypted_request();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* encrypted_request_;
  static const ::std::string _default_encrypted_request_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static VaultStatusRequest* default_instance_;
};
// -------------------------------------------------------------------

class VaultStatusResponse : public ::google::protobuf::Message {
 public:
  VaultStatusResponse();
  virtual ~VaultStatusResponse();
  
  VaultStatusResponse(const VaultStatusResponse& from);
  
  inline VaultStatusResponse& operator=(const VaultStatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const VaultStatusResponse& default_instance();
  void Swap(VaultStatusResponse* other);
  
  // implements Message ----------------------------------------------
  
  VaultStatusResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VaultStatusResponse& from);
  void MergeFrom(const VaultStatusResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);
  
  // optional bytes encrypted_response = 2;
  inline bool has_encrypted_response() const;
  inline void clear_encrypted_response();
  static const int kEncryptedResponseFieldNumber = 2;
  inline const ::std::string& encrypted_response() const;
  inline void set_encrypted_response(const ::std::string& value);
  inline void set_encrypted_response(const char* value);
  inline void set_encrypted_response(const void* value, size_t size);
  inline ::std::string* mutable_encrypted_response();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 result_;
  ::std::string* encrypted_response_;
  static const ::std::string _default_encrypted_response_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static VaultStatusResponse* default_instance_;
};
// -------------------------------------------------------------------

class OwnVaultRequest : public ::google::protobuf::Message {
 public:
  OwnVaultRequest();
  virtual ~OwnVaultRequest();
  
  OwnVaultRequest(const OwnVaultRequest& from);
  
  inline OwnVaultRequest& operator=(const OwnVaultRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OwnVaultRequest& default_instance();
  void Swap(OwnVaultRequest* other);
  
  // implements Message ----------------------------------------------
  
  OwnVaultRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OwnVaultRequest& from);
  void MergeFrom(const OwnVaultRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes public_key = 1;
  inline bool has_public_key() const;
  inline void clear_public_key();
  static const int kPublicKeyFieldNumber = 1;
  inline const ::std::string& public_key() const;
  inline void set_public_key(const ::std::string& value);
  inline void set_public_key(const char* value);
  inline void set_public_key(const void* value, size_t size);
  inline ::std::string* mutable_public_key();
  
  // required bytes private_key = 2;
  inline bool has_private_key() const;
  inline void clear_private_key();
  static const int kPrivateKeyFieldNumber = 2;
  inline const ::std::string& private_key() const;
  inline void set_private_key(const ::std::string& value);
  inline void set_private_key(const char* value);
  inline void set_private_key(const void* value, size_t size);
  inline ::std::string* mutable_private_key();
  
  // required bytes signed_public_key = 3;
  inline bool has_signed_public_key() const;
  inline void clear_signed_public_key();
  static const int kSignedPublicKeyFieldNumber = 3;
  inline const ::std::string& signed_public_key() const;
  inline void set_signed_public_key(const ::std::string& value);
  inline void set_signed_public_key(const char* value);
  inline void set_signed_public_key(const void* value, size_t size);
  inline ::std::string* mutable_signed_public_key();
  
  // required bytes chunkstore_dir = 4;
  inline bool has_chunkstore_dir() const;
  inline void clear_chunkstore_dir();
  static const int kChunkstoreDirFieldNumber = 4;
  inline const ::std::string& chunkstore_dir() const;
  inline void set_chunkstore_dir(const ::std::string& value);
  inline void set_chunkstore_dir(const char* value);
  inline void set_chunkstore_dir(const void* value, size_t size);
  inline ::std::string* mutable_chunkstore_dir();
  
  // required uint32 port = 5;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 5;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);
  
  // required uint64 space = 6;
  inline bool has_space() const;
  inline void clear_space();
  static const int kSpaceFieldNumber = 6;
  inline ::google::protobuf::uint64 space() const;
  inline void set_space(::google::protobuf::uint64 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* public_key_;
  static const ::std::string _default_public_key_;
  ::std::string* private_key_;
  static const ::std::string _default_private_key_;
  ::std::string* signed_public_key_;
  static const ::std::string _default_signed_public_key_;
  ::std::string* chunkstore_dir_;
  static const ::std::string _default_chunkstore_dir_;
  ::google::protobuf::uint32 port_;
  ::google::protobuf::uint64 space_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static OwnVaultRequest* default_instance_;
};
// -------------------------------------------------------------------

class OwnVaultResponse : public ::google::protobuf::Message {
 public:
  OwnVaultResponse();
  virtual ~OwnVaultResponse();
  
  OwnVaultResponse(const OwnVaultResponse& from);
  
  inline OwnVaultResponse& operator=(const OwnVaultResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OwnVaultResponse& default_instance();
  void Swap(OwnVaultResponse* other);
  
  // implements Message ----------------------------------------------
  
  OwnVaultResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OwnVaultResponse& from);
  void MergeFrom(const OwnVaultResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .maidsafe.OwnVaultResult result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline maidsafe::OwnVaultResult result() const;
  inline void set_result(maidsafe::OwnVaultResult value);
  
  // optional bytes pmid_name = 2;
  inline bool has_pmid_name() const;
  inline void clear_pmid_name();
  static const int kPmidNameFieldNumber = 2;
  inline const ::std::string& pmid_name() const;
  inline void set_pmid_name(const ::std::string& value);
  inline void set_pmid_name(const char* value);
  inline void set_pmid_name(const void* value, size_t size);
  inline ::std::string* mutable_pmid_name();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  int result_;
  ::std::string* pmid_name_;
  static const ::std::string _default_pmid_name_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static OwnVaultResponse* default_instance_;
};
// -------------------------------------------------------------------

class IsOwnedRequest : public ::google::protobuf::Message {
 public:
  IsOwnedRequest();
  virtual ~IsOwnedRequest();
  
  IsOwnedRequest(const IsOwnedRequest& from);
  
  inline IsOwnedRequest& operator=(const IsOwnedRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const IsOwnedRequest& default_instance();
  void Swap(IsOwnedRequest* other);
  
  // implements Message ----------------------------------------------
  
  IsOwnedRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IsOwnedRequest& from);
  void MergeFrom(const IsOwnedRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[1];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static IsOwnedRequest* default_instance_;
};
// -------------------------------------------------------------------

class IsOwnedResponse : public ::google::protobuf::Message {
 public:
  IsOwnedResponse();
  virtual ~IsOwnedResponse();
  
  IsOwnedResponse(const IsOwnedResponse& from);
  
  inline IsOwnedResponse& operator=(const IsOwnedResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const IsOwnedResponse& default_instance();
  void Swap(IsOwnedResponse* other);
  
  // implements Message ----------------------------------------------
  
  IsOwnedResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IsOwnedResponse& from);
  void MergeFrom(const IsOwnedResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .maidsafe.VaultStatus status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline maidsafe::VaultStatus status() const;
  inline void set_status(maidsafe::VaultStatus value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  int status_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static IsOwnedResponse* default_instance_;
};
// ===================================================================


// ===================================================================


// ===================================================================

// IOUAuthority

// required uint64 data_size = 1;
inline bool IOUAuthority::has_data_size() const {
  return _has_bit(0);
}
inline void IOUAuthority::clear_data_size() {
  data_size_ = GOOGLE_ULONGLONG(0);
  _clear_bit(0);
}
inline ::google::protobuf::uint64 IOUAuthority::data_size() const {
  return data_size_;
}
inline void IOUAuthority::set_data_size(::google::protobuf::uint64 value) {
  _set_bit(0);
  data_size_ = value;
}

// required bytes pmid = 2;
inline bool IOUAuthority::has_pmid() const {
  return _has_bit(1);
}
inline void IOUAuthority::clear_pmid() {
  if (pmid_ != &_default_pmid_) {
    pmid_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& IOUAuthority::pmid() const {
  return *pmid_;
}
inline void IOUAuthority::set_pmid(const ::std::string& value) {
  _set_bit(1);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(value);
}
inline void IOUAuthority::set_pmid(const char* value) {
  _set_bit(1);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(value);
}
inline void IOUAuthority::set_pmid(const void* value, size_t size) {
  _set_bit(1);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IOUAuthority::mutable_pmid() {
  _set_bit(1);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  return pmid_;
}

// -------------------------------------------------------------------

// IOU

// required bytes serialised_iou_authority = 1;
inline bool IOU::has_serialised_iou_authority() const {
  return _has_bit(0);
}
inline void IOU::clear_serialised_iou_authority() {
  if (serialised_iou_authority_ != &_default_serialised_iou_authority_) {
    serialised_iou_authority_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& IOU::serialised_iou_authority() const {
  return *serialised_iou_authority_;
}
inline void IOU::set_serialised_iou_authority(const ::std::string& value) {
  _set_bit(0);
  if (serialised_iou_authority_ == &_default_serialised_iou_authority_) {
    serialised_iou_authority_ = new ::std::string;
  }
  serialised_iou_authority_->assign(value);
}
inline void IOU::set_serialised_iou_authority(const char* value) {
  _set_bit(0);
  if (serialised_iou_authority_ == &_default_serialised_iou_authority_) {
    serialised_iou_authority_ = new ::std::string;
  }
  serialised_iou_authority_->assign(value);
}
inline void IOU::set_serialised_iou_authority(const void* value, size_t size) {
  _set_bit(0);
  if (serialised_iou_authority_ == &_default_serialised_iou_authority_) {
    serialised_iou_authority_ = new ::std::string;
  }
  serialised_iou_authority_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IOU::mutable_serialised_iou_authority() {
  _set_bit(0);
  if (serialised_iou_authority_ == &_default_serialised_iou_authority_) {
    serialised_iou_authority_ = new ::std::string;
  }
  return serialised_iou_authority_;
}

// required bytes signed_iou_authority = 2;
inline bool IOU::has_signed_iou_authority() const {
  return _has_bit(1);
}
inline void IOU::clear_signed_iou_authority() {
  if (signed_iou_authority_ != &_default_signed_iou_authority_) {
    signed_iou_authority_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& IOU::signed_iou_authority() const {
  return *signed_iou_authority_;
}
inline void IOU::set_signed_iou_authority(const ::std::string& value) {
  _set_bit(1);
  if (signed_iou_authority_ == &_default_signed_iou_authority_) {
    signed_iou_authority_ = new ::std::string;
  }
  signed_iou_authority_->assign(value);
}
inline void IOU::set_signed_iou_authority(const char* value) {
  _set_bit(1);
  if (signed_iou_authority_ == &_default_signed_iou_authority_) {
    signed_iou_authority_ = new ::std::string;
  }
  signed_iou_authority_->assign(value);
}
inline void IOU::set_signed_iou_authority(const void* value, size_t size) {
  _set_bit(1);
  if (signed_iou_authority_ == &_default_signed_iou_authority_) {
    signed_iou_authority_ = new ::std::string;
  }
  signed_iou_authority_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IOU::mutable_signed_iou_authority() {
  _set_bit(1);
  if (signed_iou_authority_ == &_default_signed_iou_authority_) {
    signed_iou_authority_ = new ::std::string;
  }
  return signed_iou_authority_;
}

// required bytes signature = 3;
inline bool IOU::has_signature() const {
  return _has_bit(2);
}
inline void IOU::clear_signature() {
  if (signature_ != &_default_signature_) {
    signature_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& IOU::signature() const {
  return *signature_;
}
inline void IOU::set_signature(const ::std::string& value) {
  _set_bit(2);
  if (signature_ == &_default_signature_) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void IOU::set_signature(const char* value) {
  _set_bit(2);
  if (signature_ == &_default_signature_) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void IOU::set_signature(const void* value, size_t size) {
  _set_bit(2);
  if (signature_ == &_default_signature_) {
    signature_ = new ::std::string;
  }
  signature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IOU::mutable_signature() {
  _set_bit(2);
  if (signature_ == &_default_signature_) {
    signature_ = new ::std::string;
  }
  return signature_;
}

// -------------------------------------------------------------------

// StorePrepRequest

// required bytes chunkname = 1;
inline bool StorePrepRequest::has_chunkname() const {
  return _has_bit(0);
}
inline void StorePrepRequest::clear_chunkname() {
  if (chunkname_ != &_default_chunkname_) {
    chunkname_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& StorePrepRequest::chunkname() const {
  return *chunkname_;
}
inline void StorePrepRequest::set_chunkname(const ::std::string& value) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(value);
}
inline void StorePrepRequest::set_chunkname(const char* value) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(value);
}
inline void StorePrepRequest::set_chunkname(const void* value, size_t size) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StorePrepRequest::mutable_chunkname() {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  return chunkname_;
}

// required uint64 data_size = 2;
inline bool StorePrepRequest::has_data_size() const {
  return _has_bit(1);
}
inline void StorePrepRequest::clear_data_size() {
  data_size_ = GOOGLE_ULONGLONG(0);
  _clear_bit(1);
}
inline ::google::protobuf::uint64 StorePrepRequest::data_size() const {
  return data_size_;
}
inline void StorePrepRequest::set_data_size(::google::protobuf::uint64 value) {
  _set_bit(1);
  data_size_ = value;
}

// required bytes pmid = 3;
inline bool StorePrepRequest::has_pmid() const {
  return _has_bit(2);
}
inline void StorePrepRequest::clear_pmid() {
  if (pmid_ != &_default_pmid_) {
    pmid_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& StorePrepRequest::pmid() const {
  return *pmid_;
}
inline void StorePrepRequest::set_pmid(const ::std::string& value) {
  _set_bit(2);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(value);
}
inline void StorePrepRequest::set_pmid(const char* value) {
  _set_bit(2);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(value);
}
inline void StorePrepRequest::set_pmid(const void* value, size_t size) {
  _set_bit(2);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StorePrepRequest::mutable_pmid() {
  _set_bit(2);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  return pmid_;
}

// required bytes public_key = 4;
inline bool StorePrepRequest::has_public_key() const {
  return _has_bit(3);
}
inline void StorePrepRequest::clear_public_key() {
  if (public_key_ != &_default_public_key_) {
    public_key_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& StorePrepRequest::public_key() const {
  return *public_key_;
}
inline void StorePrepRequest::set_public_key(const ::std::string& value) {
  _set_bit(3);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void StorePrepRequest::set_public_key(const char* value) {
  _set_bit(3);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void StorePrepRequest::set_public_key(const void* value, size_t size) {
  _set_bit(3);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StorePrepRequest::mutable_public_key() {
  _set_bit(3);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  return public_key_;
}

// required bytes signed_public_key = 5;
inline bool StorePrepRequest::has_signed_public_key() const {
  return _has_bit(4);
}
inline void StorePrepRequest::clear_signed_public_key() {
  if (signed_public_key_ != &_default_signed_public_key_) {
    signed_public_key_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& StorePrepRequest::signed_public_key() const {
  return *signed_public_key_;
}
inline void StorePrepRequest::set_signed_public_key(const ::std::string& value) {
  _set_bit(4);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  signed_public_key_->assign(value);
}
inline void StorePrepRequest::set_signed_public_key(const char* value) {
  _set_bit(4);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  signed_public_key_->assign(value);
}
inline void StorePrepRequest::set_signed_public_key(const void* value, size_t size) {
  _set_bit(4);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  signed_public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StorePrepRequest::mutable_signed_public_key() {
  _set_bit(4);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  return signed_public_key_;
}

// required bytes signed_request = 6;
inline bool StorePrepRequest::has_signed_request() const {
  return _has_bit(5);
}
inline void StorePrepRequest::clear_signed_request() {
  if (signed_request_ != &_default_signed_request_) {
    signed_request_->clear();
  }
  _clear_bit(5);
}
inline const ::std::string& StorePrepRequest::signed_request() const {
  return *signed_request_;
}
inline void StorePrepRequest::set_signed_request(const ::std::string& value) {
  _set_bit(5);
  if (signed_request_ == &_default_signed_request_) {
    signed_request_ = new ::std::string;
  }
  signed_request_->assign(value);
}
inline void StorePrepRequest::set_signed_request(const char* value) {
  _set_bit(5);
  if (signed_request_ == &_default_signed_request_) {
    signed_request_ = new ::std::string;
  }
  signed_request_->assign(value);
}
inline void StorePrepRequest::set_signed_request(const void* value, size_t size) {
  _set_bit(5);
  if (signed_request_ == &_default_signed_request_) {
    signed_request_ = new ::std::string;
  }
  signed_request_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StorePrepRequest::mutable_signed_request() {
  _set_bit(5);
  if (signed_request_ == &_default_signed_request_) {
    signed_request_ = new ::std::string;
  }
  return signed_request_;
}

// -------------------------------------------------------------------

// StorePrepResponse

// required uint32 result = 1;
inline bool StorePrepResponse::has_result() const {
  return _has_bit(0);
}
inline void StorePrepResponse::clear_result() {
  result_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 StorePrepResponse::result() const {
  return result_;
}
inline void StorePrepResponse::set_result(::google::protobuf::uint32 value) {
  _set_bit(0);
  result_ = value;
}

// optional bytes pmid_id = 2;
inline bool StorePrepResponse::has_pmid_id() const {
  return _has_bit(1);
}
inline void StorePrepResponse::clear_pmid_id() {
  if (pmid_id_ != &_default_pmid_id_) {
    pmid_id_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& StorePrepResponse::pmid_id() const {
  return *pmid_id_;
}
inline void StorePrepResponse::set_pmid_id(const ::std::string& value) {
  _set_bit(1);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  pmid_id_->assign(value);
}
inline void StorePrepResponse::set_pmid_id(const char* value) {
  _set_bit(1);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  pmid_id_->assign(value);
}
inline void StorePrepResponse::set_pmid_id(const void* value, size_t size) {
  _set_bit(1);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  pmid_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StorePrepResponse::mutable_pmid_id() {
  _set_bit(1);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  return pmid_id_;
}

// optional bytes iou_authority = 3;
inline bool StorePrepResponse::has_iou_authority() const {
  return _has_bit(2);
}
inline void StorePrepResponse::clear_iou_authority() {
  if (iou_authority_ != &_default_iou_authority_) {
    iou_authority_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& StorePrepResponse::iou_authority() const {
  return *iou_authority_;
}
inline void StorePrepResponse::set_iou_authority(const ::std::string& value) {
  _set_bit(2);
  if (iou_authority_ == &_default_iou_authority_) {
    iou_authority_ = new ::std::string;
  }
  iou_authority_->assign(value);
}
inline void StorePrepResponse::set_iou_authority(const char* value) {
  _set_bit(2);
  if (iou_authority_ == &_default_iou_authority_) {
    iou_authority_ = new ::std::string;
  }
  iou_authority_->assign(value);
}
inline void StorePrepResponse::set_iou_authority(const void* value, size_t size) {
  _set_bit(2);
  if (iou_authority_ == &_default_iou_authority_) {
    iou_authority_ = new ::std::string;
  }
  iou_authority_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StorePrepResponse::mutable_iou_authority() {
  _set_bit(2);
  if (iou_authority_ == &_default_iou_authority_) {
    iou_authority_ = new ::std::string;
  }
  return iou_authority_;
}

// optional bytes signed_iou_authority = 4;
inline bool StorePrepResponse::has_signed_iou_authority() const {
  return _has_bit(3);
}
inline void StorePrepResponse::clear_signed_iou_authority() {
  if (signed_iou_authority_ != &_default_signed_iou_authority_) {
    signed_iou_authority_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& StorePrepResponse::signed_iou_authority() const {
  return *signed_iou_authority_;
}
inline void StorePrepResponse::set_signed_iou_authority(const ::std::string& value) {
  _set_bit(3);
  if (signed_iou_authority_ == &_default_signed_iou_authority_) {
    signed_iou_authority_ = new ::std::string;
  }
  signed_iou_authority_->assign(value);
}
inline void StorePrepResponse::set_signed_iou_authority(const char* value) {
  _set_bit(3);
  if (signed_iou_authority_ == &_default_signed_iou_authority_) {
    signed_iou_authority_ = new ::std::string;
  }
  signed_iou_authority_->assign(value);
}
inline void StorePrepResponse::set_signed_iou_authority(const void* value, size_t size) {
  _set_bit(3);
  if (signed_iou_authority_ == &_default_signed_iou_authority_) {
    signed_iou_authority_ = new ::std::string;
  }
  signed_iou_authority_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StorePrepResponse::mutable_signed_iou_authority() {
  _set_bit(3);
  if (signed_iou_authority_ == &_default_signed_iou_authority_) {
    signed_iou_authority_ = new ::std::string;
  }
  return signed_iou_authority_;
}

// -------------------------------------------------------------------

// StoreRequest

// required bytes chunkname = 1;
inline bool StoreRequest::has_chunkname() const {
  return _has_bit(0);
}
inline void StoreRequest::clear_chunkname() {
  if (chunkname_ != &_default_chunkname_) {
    chunkname_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& StoreRequest::chunkname() const {
  return *chunkname_;
}
inline void StoreRequest::set_chunkname(const ::std::string& value) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(value);
}
inline void StoreRequest::set_chunkname(const char* value) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(value);
}
inline void StoreRequest::set_chunkname(const void* value, size_t size) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreRequest::mutable_chunkname() {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  return chunkname_;
}

// required bytes data = 2;
inline bool StoreRequest::has_data() const {
  return _has_bit(1);
}
inline void StoreRequest::clear_data() {
  if (data_ != &_default_data_) {
    data_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& StoreRequest::data() const {
  return *data_;
}
inline void StoreRequest::set_data(const ::std::string& value) {
  _set_bit(1);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void StoreRequest::set_data(const char* value) {
  _set_bit(1);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void StoreRequest::set_data(const void* value, size_t size) {
  _set_bit(1);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreRequest::mutable_data() {
  _set_bit(1);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  return data_;
}

// optional bytes pmid = 3;
inline bool StoreRequest::has_pmid() const {
  return _has_bit(2);
}
inline void StoreRequest::clear_pmid() {
  if (pmid_ != &_default_pmid_) {
    pmid_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& StoreRequest::pmid() const {
  return *pmid_;
}
inline void StoreRequest::set_pmid(const ::std::string& value) {
  _set_bit(2);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(value);
}
inline void StoreRequest::set_pmid(const char* value) {
  _set_bit(2);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(value);
}
inline void StoreRequest::set_pmid(const void* value, size_t size) {
  _set_bit(2);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreRequest::mutable_pmid() {
  _set_bit(2);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  return pmid_;
}

// required bytes public_key = 4;
inline bool StoreRequest::has_public_key() const {
  return _has_bit(3);
}
inline void StoreRequest::clear_public_key() {
  if (public_key_ != &_default_public_key_) {
    public_key_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& StoreRequest::public_key() const {
  return *public_key_;
}
inline void StoreRequest::set_public_key(const ::std::string& value) {
  _set_bit(3);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void StoreRequest::set_public_key(const char* value) {
  _set_bit(3);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void StoreRequest::set_public_key(const void* value, size_t size) {
  _set_bit(3);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreRequest::mutable_public_key() {
  _set_bit(3);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  return public_key_;
}

// required bytes signed_public_key = 5;
inline bool StoreRequest::has_signed_public_key() const {
  return _has_bit(4);
}
inline void StoreRequest::clear_signed_public_key() {
  if (signed_public_key_ != &_default_signed_public_key_) {
    signed_public_key_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& StoreRequest::signed_public_key() const {
  return *signed_public_key_;
}
inline void StoreRequest::set_signed_public_key(const ::std::string& value) {
  _set_bit(4);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  signed_public_key_->assign(value);
}
inline void StoreRequest::set_signed_public_key(const char* value) {
  _set_bit(4);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  signed_public_key_->assign(value);
}
inline void StoreRequest::set_signed_public_key(const void* value, size_t size) {
  _set_bit(4);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  signed_public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreRequest::mutable_signed_public_key() {
  _set_bit(4);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  return signed_public_key_;
}

// required bytes signed_request = 6;
inline bool StoreRequest::has_signed_request() const {
  return _has_bit(5);
}
inline void StoreRequest::clear_signed_request() {
  if (signed_request_ != &_default_signed_request_) {
    signed_request_->clear();
  }
  _clear_bit(5);
}
inline const ::std::string& StoreRequest::signed_request() const {
  return *signed_request_;
}
inline void StoreRequest::set_signed_request(const ::std::string& value) {
  _set_bit(5);
  if (signed_request_ == &_default_signed_request_) {
    signed_request_ = new ::std::string;
  }
  signed_request_->assign(value);
}
inline void StoreRequest::set_signed_request(const char* value) {
  _set_bit(5);
  if (signed_request_ == &_default_signed_request_) {
    signed_request_ = new ::std::string;
  }
  signed_request_->assign(value);
}
inline void StoreRequest::set_signed_request(const void* value, size_t size) {
  _set_bit(5);
  if (signed_request_ == &_default_signed_request_) {
    signed_request_ = new ::std::string;
  }
  signed_request_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreRequest::mutable_signed_request() {
  _set_bit(5);
  if (signed_request_ == &_default_signed_request_) {
    signed_request_ = new ::std::string;
  }
  return signed_request_;
}

// required uint32 data_type = 7;
inline bool StoreRequest::has_data_type() const {
  return _has_bit(6);
}
inline void StoreRequest::clear_data_type() {
  data_type_ = 0u;
  _clear_bit(6);
}
inline ::google::protobuf::uint32 StoreRequest::data_type() const {
  return data_type_;
}
inline void StoreRequest::set_data_type(::google::protobuf::uint32 value) {
  _set_bit(6);
  data_type_ = value;
}

// optional uint32 offset = 8;
inline bool StoreRequest::has_offset() const {
  return _has_bit(7);
}
inline void StoreRequest::clear_offset() {
  offset_ = 0u;
  _clear_bit(7);
}
inline ::google::protobuf::uint32 StoreRequest::offset() const {
  return offset_;
}
inline void StoreRequest::set_offset(::google::protobuf::uint32 value) {
  _set_bit(7);
  offset_ = value;
}

// optional uint32 chunklet_size = 9;
inline bool StoreRequest::has_chunklet_size() const {
  return _has_bit(8);
}
inline void StoreRequest::clear_chunklet_size() {
  chunklet_size_ = 0u;
  _clear_bit(8);
}
inline ::google::protobuf::uint32 StoreRequest::chunklet_size() const {
  return chunklet_size_;
}
inline void StoreRequest::set_chunklet_size(::google::protobuf::uint32 value) {
  _set_bit(8);
  chunklet_size_ = value;
}

// -------------------------------------------------------------------

// StoreResponse

// required uint32 result = 1;
inline bool StoreResponse::has_result() const {
  return _has_bit(0);
}
inline void StoreResponse::clear_result() {
  result_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 StoreResponse::result() const {
  return result_;
}
inline void StoreResponse::set_result(::google::protobuf::uint32 value) {
  _set_bit(0);
  result_ = value;
}

// optional bytes pmid_id = 2;
inline bool StoreResponse::has_pmid_id() const {
  return _has_bit(1);
}
inline void StoreResponse::clear_pmid_id() {
  if (pmid_id_ != &_default_pmid_id_) {
    pmid_id_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& StoreResponse::pmid_id() const {
  return *pmid_id_;
}
inline void StoreResponse::set_pmid_id(const ::std::string& value) {
  _set_bit(1);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  pmid_id_->assign(value);
}
inline void StoreResponse::set_pmid_id(const char* value) {
  _set_bit(1);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  pmid_id_->assign(value);
}
inline void StoreResponse::set_pmid_id(const void* value, size_t size) {
  _set_bit(1);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  pmid_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreResponse::mutable_pmid_id() {
  _set_bit(1);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  return pmid_id_;
}

// -------------------------------------------------------------------

// StoreIOURequest

// required bytes chunkname = 1;
inline bool StoreIOURequest::has_chunkname() const {
  return _has_bit(0);
}
inline void StoreIOURequest::clear_chunkname() {
  if (chunkname_ != &_default_chunkname_) {
    chunkname_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& StoreIOURequest::chunkname() const {
  return *chunkname_;
}
inline void StoreIOURequest::set_chunkname(const ::std::string& value) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(value);
}
inline void StoreIOURequest::set_chunkname(const char* value) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(value);
}
inline void StoreIOURequest::set_chunkname(const void* value, size_t size) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreIOURequest::mutable_chunkname() {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  return chunkname_;
}

// required uint64 data_size = 2;
inline bool StoreIOURequest::has_data_size() const {
  return _has_bit(1);
}
inline void StoreIOURequest::clear_data_size() {
  data_size_ = GOOGLE_ULONGLONG(0);
  _clear_bit(1);
}
inline ::google::protobuf::uint64 StoreIOURequest::data_size() const {
  return data_size_;
}
inline void StoreIOURequest::set_data_size(::google::protobuf::uint64 value) {
  _set_bit(1);
  data_size_ = value;
}

// required bytes collector_pmid = 3;
inline bool StoreIOURequest::has_collector_pmid() const {
  return _has_bit(2);
}
inline void StoreIOURequest::clear_collector_pmid() {
  if (collector_pmid_ != &_default_collector_pmid_) {
    collector_pmid_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& StoreIOURequest::collector_pmid() const {
  return *collector_pmid_;
}
inline void StoreIOURequest::set_collector_pmid(const ::std::string& value) {
  _set_bit(2);
  if (collector_pmid_ == &_default_collector_pmid_) {
    collector_pmid_ = new ::std::string;
  }
  collector_pmid_->assign(value);
}
inline void StoreIOURequest::set_collector_pmid(const char* value) {
  _set_bit(2);
  if (collector_pmid_ == &_default_collector_pmid_) {
    collector_pmid_ = new ::std::string;
  }
  collector_pmid_->assign(value);
}
inline void StoreIOURequest::set_collector_pmid(const void* value, size_t size) {
  _set_bit(2);
  if (collector_pmid_ == &_default_collector_pmid_) {
    collector_pmid_ = new ::std::string;
  }
  collector_pmid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreIOURequest::mutable_collector_pmid() {
  _set_bit(2);
  if (collector_pmid_ == &_default_collector_pmid_) {
    collector_pmid_ = new ::std::string;
  }
  return collector_pmid_;
}

// required bytes iou = 4;
inline bool StoreIOURequest::has_iou() const {
  return _has_bit(3);
}
inline void StoreIOURequest::clear_iou() {
  if (iou_ != &_default_iou_) {
    iou_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& StoreIOURequest::iou() const {
  return *iou_;
}
inline void StoreIOURequest::set_iou(const ::std::string& value) {
  _set_bit(3);
  if (iou_ == &_default_iou_) {
    iou_ = new ::std::string;
  }
  iou_->assign(value);
}
inline void StoreIOURequest::set_iou(const char* value) {
  _set_bit(3);
  if (iou_ == &_default_iou_) {
    iou_ = new ::std::string;
  }
  iou_->assign(value);
}
inline void StoreIOURequest::set_iou(const void* value, size_t size) {
  _set_bit(3);
  if (iou_ == &_default_iou_) {
    iou_ = new ::std::string;
  }
  iou_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreIOURequest::mutable_iou() {
  _set_bit(3);
  if (iou_ == &_default_iou_) {
    iou_ = new ::std::string;
  }
  return iou_;
}

// required bytes own_pmid = 5;
inline bool StoreIOURequest::has_own_pmid() const {
  return _has_bit(4);
}
inline void StoreIOURequest::clear_own_pmid() {
  if (own_pmid_ != &_default_own_pmid_) {
    own_pmid_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& StoreIOURequest::own_pmid() const {
  return *own_pmid_;
}
inline void StoreIOURequest::set_own_pmid(const ::std::string& value) {
  _set_bit(4);
  if (own_pmid_ == &_default_own_pmid_) {
    own_pmid_ = new ::std::string;
  }
  own_pmid_->assign(value);
}
inline void StoreIOURequest::set_own_pmid(const char* value) {
  _set_bit(4);
  if (own_pmid_ == &_default_own_pmid_) {
    own_pmid_ = new ::std::string;
  }
  own_pmid_->assign(value);
}
inline void StoreIOURequest::set_own_pmid(const void* value, size_t size) {
  _set_bit(4);
  if (own_pmid_ == &_default_own_pmid_) {
    own_pmid_ = new ::std::string;
  }
  own_pmid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreIOURequest::mutable_own_pmid() {
  _set_bit(4);
  if (own_pmid_ == &_default_own_pmid_) {
    own_pmid_ = new ::std::string;
  }
  return own_pmid_;
}

// required bytes public_key = 6;
inline bool StoreIOURequest::has_public_key() const {
  return _has_bit(5);
}
inline void StoreIOURequest::clear_public_key() {
  if (public_key_ != &_default_public_key_) {
    public_key_->clear();
  }
  _clear_bit(5);
}
inline const ::std::string& StoreIOURequest::public_key() const {
  return *public_key_;
}
inline void StoreIOURequest::set_public_key(const ::std::string& value) {
  _set_bit(5);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void StoreIOURequest::set_public_key(const char* value) {
  _set_bit(5);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void StoreIOURequest::set_public_key(const void* value, size_t size) {
  _set_bit(5);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreIOURequest::mutable_public_key() {
  _set_bit(5);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  return public_key_;
}

// required bytes signed_public_key = 7;
inline bool StoreIOURequest::has_signed_public_key() const {
  return _has_bit(6);
}
inline void StoreIOURequest::clear_signed_public_key() {
  if (signed_public_key_ != &_default_signed_public_key_) {
    signed_public_key_->clear();
  }
  _clear_bit(6);
}
inline const ::std::string& StoreIOURequest::signed_public_key() const {
  return *signed_public_key_;
}
inline void StoreIOURequest::set_signed_public_key(const ::std::string& value) {
  _set_bit(6);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  signed_public_key_->assign(value);
}
inline void StoreIOURequest::set_signed_public_key(const char* value) {
  _set_bit(6);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  signed_public_key_->assign(value);
}
inline void StoreIOURequest::set_signed_public_key(const void* value, size_t size) {
  _set_bit(6);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  signed_public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreIOURequest::mutable_signed_public_key() {
  _set_bit(6);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  return signed_public_key_;
}

// required bytes signed_request = 8;
inline bool StoreIOURequest::has_signed_request() const {
  return _has_bit(7);
}
inline void StoreIOURequest::clear_signed_request() {
  if (signed_request_ != &_default_signed_request_) {
    signed_request_->clear();
  }
  _clear_bit(7);
}
inline const ::std::string& StoreIOURequest::signed_request() const {
  return *signed_request_;
}
inline void StoreIOURequest::set_signed_request(const ::std::string& value) {
  _set_bit(7);
  if (signed_request_ == &_default_signed_request_) {
    signed_request_ = new ::std::string;
  }
  signed_request_->assign(value);
}
inline void StoreIOURequest::set_signed_request(const char* value) {
  _set_bit(7);
  if (signed_request_ == &_default_signed_request_) {
    signed_request_ = new ::std::string;
  }
  signed_request_->assign(value);
}
inline void StoreIOURequest::set_signed_request(const void* value, size_t size) {
  _set_bit(7);
  if (signed_request_ == &_default_signed_request_) {
    signed_request_ = new ::std::string;
  }
  signed_request_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreIOURequest::mutable_signed_request() {
  _set_bit(7);
  if (signed_request_ == &_default_signed_request_) {
    signed_request_ = new ::std::string;
  }
  return signed_request_;
}

// -------------------------------------------------------------------

// StoreIOUResponse

// required uint32 result = 1;
inline bool StoreIOUResponse::has_result() const {
  return _has_bit(0);
}
inline void StoreIOUResponse::clear_result() {
  result_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 StoreIOUResponse::result() const {
  return result_;
}
inline void StoreIOUResponse::set_result(::google::protobuf::uint32 value) {
  _set_bit(0);
  result_ = value;
}

// optional bytes pmid_id = 2;
inline bool StoreIOUResponse::has_pmid_id() const {
  return _has_bit(1);
}
inline void StoreIOUResponse::clear_pmid_id() {
  if (pmid_id_ != &_default_pmid_id_) {
    pmid_id_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& StoreIOUResponse::pmid_id() const {
  return *pmid_id_;
}
inline void StoreIOUResponse::set_pmid_id(const ::std::string& value) {
  _set_bit(1);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  pmid_id_->assign(value);
}
inline void StoreIOUResponse::set_pmid_id(const char* value) {
  _set_bit(1);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  pmid_id_->assign(value);
}
inline void StoreIOUResponse::set_pmid_id(const void* value, size_t size) {
  _set_bit(1);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  pmid_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreIOUResponse::mutable_pmid_id() {
  _set_bit(1);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  return pmid_id_;
}

// -------------------------------------------------------------------

// IOUDoneRequest

// required bytes chunkname = 1;
inline bool IOUDoneRequest::has_chunkname() const {
  return _has_bit(0);
}
inline void IOUDoneRequest::clear_chunkname() {
  if (chunkname_ != &_default_chunkname_) {
    chunkname_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& IOUDoneRequest::chunkname() const {
  return *chunkname_;
}
inline void IOUDoneRequest::set_chunkname(const ::std::string& value) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(value);
}
inline void IOUDoneRequest::set_chunkname(const char* value) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(value);
}
inline void IOUDoneRequest::set_chunkname(const void* value, size_t size) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IOUDoneRequest::mutable_chunkname() {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  return chunkname_;
}

// required bytes public_key = 2;
inline bool IOUDoneRequest::has_public_key() const {
  return _has_bit(1);
}
inline void IOUDoneRequest::clear_public_key() {
  if (public_key_ != &_default_public_key_) {
    public_key_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& IOUDoneRequest::public_key() const {
  return *public_key_;
}
inline void IOUDoneRequest::set_public_key(const ::std::string& value) {
  _set_bit(1);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void IOUDoneRequest::set_public_key(const char* value) {
  _set_bit(1);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void IOUDoneRequest::set_public_key(const void* value, size_t size) {
  _set_bit(1);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IOUDoneRequest::mutable_public_key() {
  _set_bit(1);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  return public_key_;
}

// required bytes signed_public_key = 3;
inline bool IOUDoneRequest::has_signed_public_key() const {
  return _has_bit(2);
}
inline void IOUDoneRequest::clear_signed_public_key() {
  if (signed_public_key_ != &_default_signed_public_key_) {
    signed_public_key_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& IOUDoneRequest::signed_public_key() const {
  return *signed_public_key_;
}
inline void IOUDoneRequest::set_signed_public_key(const ::std::string& value) {
  _set_bit(2);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  signed_public_key_->assign(value);
}
inline void IOUDoneRequest::set_signed_public_key(const char* value) {
  _set_bit(2);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  signed_public_key_->assign(value);
}
inline void IOUDoneRequest::set_signed_public_key(const void* value, size_t size) {
  _set_bit(2);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  signed_public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IOUDoneRequest::mutable_signed_public_key() {
  _set_bit(2);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  return signed_public_key_;
}

// required bytes signed_request = 4;
inline bool IOUDoneRequest::has_signed_request() const {
  return _has_bit(3);
}
inline void IOUDoneRequest::clear_signed_request() {
  if (signed_request_ != &_default_signed_request_) {
    signed_request_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& IOUDoneRequest::signed_request() const {
  return *signed_request_;
}
inline void IOUDoneRequest::set_signed_request(const ::std::string& value) {
  _set_bit(3);
  if (signed_request_ == &_default_signed_request_) {
    signed_request_ = new ::std::string;
  }
  signed_request_->assign(value);
}
inline void IOUDoneRequest::set_signed_request(const char* value) {
  _set_bit(3);
  if (signed_request_ == &_default_signed_request_) {
    signed_request_ = new ::std::string;
  }
  signed_request_->assign(value);
}
inline void IOUDoneRequest::set_signed_request(const void* value, size_t size) {
  _set_bit(3);
  if (signed_request_ == &_default_signed_request_) {
    signed_request_ = new ::std::string;
  }
  signed_request_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IOUDoneRequest::mutable_signed_request() {
  _set_bit(3);
  if (signed_request_ == &_default_signed_request_) {
    signed_request_ = new ::std::string;
  }
  return signed_request_;
}

// -------------------------------------------------------------------

// IOUDoneResponse

// required uint32 result = 1;
inline bool IOUDoneResponse::has_result() const {
  return _has_bit(0);
}
inline void IOUDoneResponse::clear_result() {
  result_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 IOUDoneResponse::result() const {
  return result_;
}
inline void IOUDoneResponse::set_result(::google::protobuf::uint32 value) {
  _set_bit(0);
  result_ = value;
}

// optional bytes pmid_id = 2;
inline bool IOUDoneResponse::has_pmid_id() const {
  return _has_bit(1);
}
inline void IOUDoneResponse::clear_pmid_id() {
  if (pmid_id_ != &_default_pmid_id_) {
    pmid_id_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& IOUDoneResponse::pmid_id() const {
  return *pmid_id_;
}
inline void IOUDoneResponse::set_pmid_id(const ::std::string& value) {
  _set_bit(1);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  pmid_id_->assign(value);
}
inline void IOUDoneResponse::set_pmid_id(const char* value) {
  _set_bit(1);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  pmid_id_->assign(value);
}
inline void IOUDoneResponse::set_pmid_id(const void* value, size_t size) {
  _set_bit(1);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  pmid_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IOUDoneResponse::mutable_pmid_id() {
  _set_bit(1);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  return pmid_id_;
}

// -------------------------------------------------------------------

// RankAuthority

// required bytes chunkname = 1;
inline bool RankAuthority::has_chunkname() const {
  return _has_bit(0);
}
inline void RankAuthority::clear_chunkname() {
  if (chunkname_ != &_default_chunkname_) {
    chunkname_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& RankAuthority::chunkname() const {
  return *chunkname_;
}
inline void RankAuthority::set_chunkname(const ::std::string& value) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(value);
}
inline void RankAuthority::set_chunkname(const char* value) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(value);
}
inline void RankAuthority::set_chunkname(const void* value, size_t size) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RankAuthority::mutable_chunkname() {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  return chunkname_;
}

// required uint64 data_size = 2;
inline bool RankAuthority::has_data_size() const {
  return _has_bit(1);
}
inline void RankAuthority::clear_data_size() {
  data_size_ = GOOGLE_ULONGLONG(0);
  _clear_bit(1);
}
inline ::google::protobuf::uint64 RankAuthority::data_size() const {
  return data_size_;
}
inline void RankAuthority::set_data_size(::google::protobuf::uint64 value) {
  _set_bit(1);
  data_size_ = value;
}

// required bytes pmid = 3;
inline bool RankAuthority::has_pmid() const {
  return _has_bit(2);
}
inline void RankAuthority::clear_pmid() {
  if (pmid_ != &_default_pmid_) {
    pmid_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& RankAuthority::pmid() const {
  return *pmid_;
}
inline void RankAuthority::set_pmid(const ::std::string& value) {
  _set_bit(2);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(value);
}
inline void RankAuthority::set_pmid(const char* value) {
  _set_bit(2);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(value);
}
inline void RankAuthority::set_pmid(const void* value, size_t size) {
  _set_bit(2);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RankAuthority::mutable_pmid() {
  _set_bit(2);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  return pmid_;
}

// -------------------------------------------------------------------

// StoreReferenceRequest

// required bytes chunkname = 1;
inline bool StoreReferenceRequest::has_chunkname() const {
  return _has_bit(0);
}
inline void StoreReferenceRequest::clear_chunkname() {
  if (chunkname_ != &_default_chunkname_) {
    chunkname_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& StoreReferenceRequest::chunkname() const {
  return *chunkname_;
}
inline void StoreReferenceRequest::set_chunkname(const ::std::string& value) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(value);
}
inline void StoreReferenceRequest::set_chunkname(const char* value) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(value);
}
inline void StoreReferenceRequest::set_chunkname(const void* value, size_t size) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreReferenceRequest::mutable_chunkname() {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  return chunkname_;
}

// required bytes pmid = 2;
inline bool StoreReferenceRequest::has_pmid() const {
  return _has_bit(1);
}
inline void StoreReferenceRequest::clear_pmid() {
  if (pmid_ != &_default_pmid_) {
    pmid_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& StoreReferenceRequest::pmid() const {
  return *pmid_;
}
inline void StoreReferenceRequest::set_pmid(const ::std::string& value) {
  _set_bit(1);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(value);
}
inline void StoreReferenceRequest::set_pmid(const char* value) {
  _set_bit(1);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(value);
}
inline void StoreReferenceRequest::set_pmid(const void* value, size_t size) {
  _set_bit(1);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreReferenceRequest::mutable_pmid() {
  _set_bit(1);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  return pmid_;
}

// required bytes signed_pmid = 3;
inline bool StoreReferenceRequest::has_signed_pmid() const {
  return _has_bit(2);
}
inline void StoreReferenceRequest::clear_signed_pmid() {
  if (signed_pmid_ != &_default_signed_pmid_) {
    signed_pmid_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& StoreReferenceRequest::signed_pmid() const {
  return *signed_pmid_;
}
inline void StoreReferenceRequest::set_signed_pmid(const ::std::string& value) {
  _set_bit(2);
  if (signed_pmid_ == &_default_signed_pmid_) {
    signed_pmid_ = new ::std::string;
  }
  signed_pmid_->assign(value);
}
inline void StoreReferenceRequest::set_signed_pmid(const char* value) {
  _set_bit(2);
  if (signed_pmid_ == &_default_signed_pmid_) {
    signed_pmid_ = new ::std::string;
  }
  signed_pmid_->assign(value);
}
inline void StoreReferenceRequest::set_signed_pmid(const void* value, size_t size) {
  _set_bit(2);
  if (signed_pmid_ == &_default_signed_pmid_) {
    signed_pmid_ = new ::std::string;
  }
  signed_pmid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreReferenceRequest::mutable_signed_pmid() {
  _set_bit(2);
  if (signed_pmid_ == &_default_signed_pmid_) {
    signed_pmid_ = new ::std::string;
  }
  return signed_pmid_;
}

// required bytes public_key = 4;
inline bool StoreReferenceRequest::has_public_key() const {
  return _has_bit(3);
}
inline void StoreReferenceRequest::clear_public_key() {
  if (public_key_ != &_default_public_key_) {
    public_key_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& StoreReferenceRequest::public_key() const {
  return *public_key_;
}
inline void StoreReferenceRequest::set_public_key(const ::std::string& value) {
  _set_bit(3);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void StoreReferenceRequest::set_public_key(const char* value) {
  _set_bit(3);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void StoreReferenceRequest::set_public_key(const void* value, size_t size) {
  _set_bit(3);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreReferenceRequest::mutable_public_key() {
  _set_bit(3);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  return public_key_;
}

// required bytes signed_public_key = 5;
inline bool StoreReferenceRequest::has_signed_public_key() const {
  return _has_bit(4);
}
inline void StoreReferenceRequest::clear_signed_public_key() {
  if (signed_public_key_ != &_default_signed_public_key_) {
    signed_public_key_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& StoreReferenceRequest::signed_public_key() const {
  return *signed_public_key_;
}
inline void StoreReferenceRequest::set_signed_public_key(const ::std::string& value) {
  _set_bit(4);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  signed_public_key_->assign(value);
}
inline void StoreReferenceRequest::set_signed_public_key(const char* value) {
  _set_bit(4);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  signed_public_key_->assign(value);
}
inline void StoreReferenceRequest::set_signed_public_key(const void* value, size_t size) {
  _set_bit(4);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  signed_public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreReferenceRequest::mutable_signed_public_key() {
  _set_bit(4);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  return signed_public_key_;
}

// required bytes signed_request = 6;
inline bool StoreReferenceRequest::has_signed_request() const {
  return _has_bit(5);
}
inline void StoreReferenceRequest::clear_signed_request() {
  if (signed_request_ != &_default_signed_request_) {
    signed_request_->clear();
  }
  _clear_bit(5);
}
inline const ::std::string& StoreReferenceRequest::signed_request() const {
  return *signed_request_;
}
inline void StoreReferenceRequest::set_signed_request(const ::std::string& value) {
  _set_bit(5);
  if (signed_request_ == &_default_signed_request_) {
    signed_request_ = new ::std::string;
  }
  signed_request_->assign(value);
}
inline void StoreReferenceRequest::set_signed_request(const char* value) {
  _set_bit(5);
  if (signed_request_ == &_default_signed_request_) {
    signed_request_ = new ::std::string;
  }
  signed_request_->assign(value);
}
inline void StoreReferenceRequest::set_signed_request(const void* value, size_t size) {
  _set_bit(5);
  if (signed_request_ == &_default_signed_request_) {
    signed_request_ = new ::std::string;
  }
  signed_request_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreReferenceRequest::mutable_signed_request() {
  _set_bit(5);
  if (signed_request_ == &_default_signed_request_) {
    signed_request_ = new ::std::string;
  }
  return signed_request_;
}

// -------------------------------------------------------------------

// StoreReferenceResponse

// required uint32 result = 1;
inline bool StoreReferenceResponse::has_result() const {
  return _has_bit(0);
}
inline void StoreReferenceResponse::clear_result() {
  result_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 StoreReferenceResponse::result() const {
  return result_;
}
inline void StoreReferenceResponse::set_result(::google::protobuf::uint32 value) {
  _set_bit(0);
  result_ = value;
}

// optional bytes rank_authority = 2;
inline bool StoreReferenceResponse::has_rank_authority() const {
  return _has_bit(1);
}
inline void StoreReferenceResponse::clear_rank_authority() {
  if (rank_authority_ != &_default_rank_authority_) {
    rank_authority_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& StoreReferenceResponse::rank_authority() const {
  return *rank_authority_;
}
inline void StoreReferenceResponse::set_rank_authority(const ::std::string& value) {
  _set_bit(1);
  if (rank_authority_ == &_default_rank_authority_) {
    rank_authority_ = new ::std::string;
  }
  rank_authority_->assign(value);
}
inline void StoreReferenceResponse::set_rank_authority(const char* value) {
  _set_bit(1);
  if (rank_authority_ == &_default_rank_authority_) {
    rank_authority_ = new ::std::string;
  }
  rank_authority_->assign(value);
}
inline void StoreReferenceResponse::set_rank_authority(const void* value, size_t size) {
  _set_bit(1);
  if (rank_authority_ == &_default_rank_authority_) {
    rank_authority_ = new ::std::string;
  }
  rank_authority_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreReferenceResponse::mutable_rank_authority() {
  _set_bit(1);
  if (rank_authority_ == &_default_rank_authority_) {
    rank_authority_ = new ::std::string;
  }
  return rank_authority_;
}

// optional bytes signed_rank_authority = 3;
inline bool StoreReferenceResponse::has_signed_rank_authority() const {
  return _has_bit(2);
}
inline void StoreReferenceResponse::clear_signed_rank_authority() {
  if (signed_rank_authority_ != &_default_signed_rank_authority_) {
    signed_rank_authority_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& StoreReferenceResponse::signed_rank_authority() const {
  return *signed_rank_authority_;
}
inline void StoreReferenceResponse::set_signed_rank_authority(const ::std::string& value) {
  _set_bit(2);
  if (signed_rank_authority_ == &_default_signed_rank_authority_) {
    signed_rank_authority_ = new ::std::string;
  }
  signed_rank_authority_->assign(value);
}
inline void StoreReferenceResponse::set_signed_rank_authority(const char* value) {
  _set_bit(2);
  if (signed_rank_authority_ == &_default_signed_rank_authority_) {
    signed_rank_authority_ = new ::std::string;
  }
  signed_rank_authority_->assign(value);
}
inline void StoreReferenceResponse::set_signed_rank_authority(const void* value, size_t size) {
  _set_bit(2);
  if (signed_rank_authority_ == &_default_signed_rank_authority_) {
    signed_rank_authority_ = new ::std::string;
  }
  signed_rank_authority_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreReferenceResponse::mutable_signed_rank_authority() {
  _set_bit(2);
  if (signed_rank_authority_ == &_default_signed_rank_authority_) {
    signed_rank_authority_ = new ::std::string;
  }
  return signed_rank_authority_;
}

// optional bytes iou = 4;
inline bool StoreReferenceResponse::has_iou() const {
  return _has_bit(3);
}
inline void StoreReferenceResponse::clear_iou() {
  if (iou_ != &_default_iou_) {
    iou_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& StoreReferenceResponse::iou() const {
  return *iou_;
}
inline void StoreReferenceResponse::set_iou(const ::std::string& value) {
  _set_bit(3);
  if (iou_ == &_default_iou_) {
    iou_ = new ::std::string;
  }
  iou_->assign(value);
}
inline void StoreReferenceResponse::set_iou(const char* value) {
  _set_bit(3);
  if (iou_ == &_default_iou_) {
    iou_ = new ::std::string;
  }
  iou_->assign(value);
}
inline void StoreReferenceResponse::set_iou(const void* value, size_t size) {
  _set_bit(3);
  if (iou_ == &_default_iou_) {
    iou_ = new ::std::string;
  }
  iou_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreReferenceResponse::mutable_iou() {
  _set_bit(3);
  if (iou_ == &_default_iou_) {
    iou_ = new ::std::string;
  }
  return iou_;
}

// optional bytes pmid_id = 5;
inline bool StoreReferenceResponse::has_pmid_id() const {
  return _has_bit(4);
}
inline void StoreReferenceResponse::clear_pmid_id() {
  if (pmid_id_ != &_default_pmid_id_) {
    pmid_id_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& StoreReferenceResponse::pmid_id() const {
  return *pmid_id_;
}
inline void StoreReferenceResponse::set_pmid_id(const ::std::string& value) {
  _set_bit(4);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  pmid_id_->assign(value);
}
inline void StoreReferenceResponse::set_pmid_id(const char* value) {
  _set_bit(4);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  pmid_id_->assign(value);
}
inline void StoreReferenceResponse::set_pmid_id(const void* value, size_t size) {
  _set_bit(4);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  pmid_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreReferenceResponse::mutable_pmid_id() {
  _set_bit(4);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  return pmid_id_;
}

// optional bytes public_key = 6;
inline bool StoreReferenceResponse::has_public_key() const {
  return _has_bit(5);
}
inline void StoreReferenceResponse::clear_public_key() {
  if (public_key_ != &_default_public_key_) {
    public_key_->clear();
  }
  _clear_bit(5);
}
inline const ::std::string& StoreReferenceResponse::public_key() const {
  return *public_key_;
}
inline void StoreReferenceResponse::set_public_key(const ::std::string& value) {
  _set_bit(5);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void StoreReferenceResponse::set_public_key(const char* value) {
  _set_bit(5);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void StoreReferenceResponse::set_public_key(const void* value, size_t size) {
  _set_bit(5);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreReferenceResponse::mutable_public_key() {
  _set_bit(5);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  return public_key_;
}

// optional bytes signed_public_key = 7;
inline bool StoreReferenceResponse::has_signed_public_key() const {
  return _has_bit(6);
}
inline void StoreReferenceResponse::clear_signed_public_key() {
  if (signed_public_key_ != &_default_signed_public_key_) {
    signed_public_key_->clear();
  }
  _clear_bit(6);
}
inline const ::std::string& StoreReferenceResponse::signed_public_key() const {
  return *signed_public_key_;
}
inline void StoreReferenceResponse::set_signed_public_key(const ::std::string& value) {
  _set_bit(6);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  signed_public_key_->assign(value);
}
inline void StoreReferenceResponse::set_signed_public_key(const char* value) {
  _set_bit(6);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  signed_public_key_->assign(value);
}
inline void StoreReferenceResponse::set_signed_public_key(const void* value, size_t size) {
  _set_bit(6);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  signed_public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreReferenceResponse::mutable_signed_public_key() {
  _set_bit(6);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  return signed_public_key_;
}

// -------------------------------------------------------------------

// DeleteRequest

// required bytes chunkname = 1;
inline bool DeleteRequest::has_chunkname() const {
  return _has_bit(0);
}
inline void DeleteRequest::clear_chunkname() {
  if (chunkname_ != &_default_chunkname_) {
    chunkname_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& DeleteRequest::chunkname() const {
  return *chunkname_;
}
inline void DeleteRequest::set_chunkname(const ::std::string& value) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(value);
}
inline void DeleteRequest::set_chunkname(const char* value) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(value);
}
inline void DeleteRequest::set_chunkname(const void* value, size_t size) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeleteRequest::mutable_chunkname() {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  return chunkname_;
}

// required bytes public_key = 2;
inline bool DeleteRequest::has_public_key() const {
  return _has_bit(1);
}
inline void DeleteRequest::clear_public_key() {
  if (public_key_ != &_default_public_key_) {
    public_key_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& DeleteRequest::public_key() const {
  return *public_key_;
}
inline void DeleteRequest::set_public_key(const ::std::string& value) {
  _set_bit(1);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void DeleteRequest::set_public_key(const char* value) {
  _set_bit(1);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void DeleteRequest::set_public_key(const void* value, size_t size) {
  _set_bit(1);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeleteRequest::mutable_public_key() {
  _set_bit(1);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  return public_key_;
}

// required bytes signed_public_key = 3;
inline bool DeleteRequest::has_signed_public_key() const {
  return _has_bit(2);
}
inline void DeleteRequest::clear_signed_public_key() {
  if (signed_public_key_ != &_default_signed_public_key_) {
    signed_public_key_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& DeleteRequest::signed_public_key() const {
  return *signed_public_key_;
}
inline void DeleteRequest::set_signed_public_key(const ::std::string& value) {
  _set_bit(2);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  signed_public_key_->assign(value);
}
inline void DeleteRequest::set_signed_public_key(const char* value) {
  _set_bit(2);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  signed_public_key_->assign(value);
}
inline void DeleteRequest::set_signed_public_key(const void* value, size_t size) {
  _set_bit(2);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  signed_public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeleteRequest::mutable_signed_public_key() {
  _set_bit(2);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  return signed_public_key_;
}

// required bytes signed_request = 4;
inline bool DeleteRequest::has_signed_request() const {
  return _has_bit(3);
}
inline void DeleteRequest::clear_signed_request() {
  if (signed_request_ != &_default_signed_request_) {
    signed_request_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& DeleteRequest::signed_request() const {
  return *signed_request_;
}
inline void DeleteRequest::set_signed_request(const ::std::string& value) {
  _set_bit(3);
  if (signed_request_ == &_default_signed_request_) {
    signed_request_ = new ::std::string;
  }
  signed_request_->assign(value);
}
inline void DeleteRequest::set_signed_request(const char* value) {
  _set_bit(3);
  if (signed_request_ == &_default_signed_request_) {
    signed_request_ = new ::std::string;
  }
  signed_request_->assign(value);
}
inline void DeleteRequest::set_signed_request(const void* value, size_t size) {
  _set_bit(3);
  if (signed_request_ == &_default_signed_request_) {
    signed_request_ = new ::std::string;
  }
  signed_request_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeleteRequest::mutable_signed_request() {
  _set_bit(3);
  if (signed_request_ == &_default_signed_request_) {
    signed_request_ = new ::std::string;
  }
  return signed_request_;
}

// required int32 data_type = 5;
inline bool DeleteRequest::has_data_type() const {
  return _has_bit(4);
}
inline void DeleteRequest::clear_data_type() {
  data_type_ = 0;
  _clear_bit(4);
}
inline ::google::protobuf::int32 DeleteRequest::data_type() const {
  return data_type_;
}
inline void DeleteRequest::set_data_type(::google::protobuf::int32 value) {
  _set_bit(4);
  data_type_ = value;
}

// -------------------------------------------------------------------

// DeleteResponse

// required uint32 result = 1;
inline bool DeleteResponse::has_result() const {
  return _has_bit(0);
}
inline void DeleteResponse::clear_result() {
  result_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 DeleteResponse::result() const {
  return result_;
}
inline void DeleteResponse::set_result(::google::protobuf::uint32 value) {
  _set_bit(0);
  result_ = value;
}

// optional bytes pmid_id = 2;
inline bool DeleteResponse::has_pmid_id() const {
  return _has_bit(1);
}
inline void DeleteResponse::clear_pmid_id() {
  if (pmid_id_ != &_default_pmid_id_) {
    pmid_id_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& DeleteResponse::pmid_id() const {
  return *pmid_id_;
}
inline void DeleteResponse::set_pmid_id(const ::std::string& value) {
  _set_bit(1);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  pmid_id_->assign(value);
}
inline void DeleteResponse::set_pmid_id(const char* value) {
  _set_bit(1);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  pmid_id_->assign(value);
}
inline void DeleteResponse::set_pmid_id(const void* value, size_t size) {
  _set_bit(1);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  pmid_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeleteResponse::mutable_pmid_id() {
  _set_bit(1);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  return pmid_id_;
}

// -------------------------------------------------------------------

// GetRequest

// required bytes chunkname = 1;
inline bool GetRequest::has_chunkname() const {
  return _has_bit(0);
}
inline void GetRequest::clear_chunkname() {
  if (chunkname_ != &_default_chunkname_) {
    chunkname_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& GetRequest::chunkname() const {
  return *chunkname_;
}
inline void GetRequest::set_chunkname(const ::std::string& value) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(value);
}
inline void GetRequest::set_chunkname(const char* value) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(value);
}
inline void GetRequest::set_chunkname(const void* value, size_t size) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetRequest::mutable_chunkname() {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  return chunkname_;
}

// -------------------------------------------------------------------

// GetResponse

// required uint32 result = 1;
inline bool GetResponse::has_result() const {
  return _has_bit(0);
}
inline void GetResponse::clear_result() {
  result_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 GetResponse::result() const {
  return result_;
}
inline void GetResponse::set_result(::google::protobuf::uint32 value) {
  _set_bit(0);
  result_ = value;
}

// optional bytes content = 2;
inline bool GetResponse::has_content() const {
  return _has_bit(1);
}
inline void GetResponse::clear_content() {
  if (content_ != &_default_content_) {
    content_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& GetResponse::content() const {
  return *content_;
}
inline void GetResponse::set_content(const ::std::string& value) {
  _set_bit(1);
  if (content_ == &_default_content_) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void GetResponse::set_content(const char* value) {
  _set_bit(1);
  if (content_ == &_default_content_) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void GetResponse::set_content(const void* value, size_t size) {
  _set_bit(1);
  if (content_ == &_default_content_) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetResponse::mutable_content() {
  _set_bit(1);
  if (content_ == &_default_content_) {
    content_ = new ::std::string;
  }
  return content_;
}

// optional bytes pmid_id = 3;
inline bool GetResponse::has_pmid_id() const {
  return _has_bit(2);
}
inline void GetResponse::clear_pmid_id() {
  if (pmid_id_ != &_default_pmid_id_) {
    pmid_id_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& GetResponse::pmid_id() const {
  return *pmid_id_;
}
inline void GetResponse::set_pmid_id(const ::std::string& value) {
  _set_bit(2);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  pmid_id_->assign(value);
}
inline void GetResponse::set_pmid_id(const char* value) {
  _set_bit(2);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  pmid_id_->assign(value);
}
inline void GetResponse::set_pmid_id(const void* value, size_t size) {
  _set_bit(2);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  pmid_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetResponse::mutable_pmid_id() {
  _set_bit(2);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  return pmid_id_;
}

// -------------------------------------------------------------------

// CheckChunkRequest

// required bytes chunkname = 1;
inline bool CheckChunkRequest::has_chunkname() const {
  return _has_bit(0);
}
inline void CheckChunkRequest::clear_chunkname() {
  if (chunkname_ != &_default_chunkname_) {
    chunkname_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& CheckChunkRequest::chunkname() const {
  return *chunkname_;
}
inline void CheckChunkRequest::set_chunkname(const ::std::string& value) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(value);
}
inline void CheckChunkRequest::set_chunkname(const char* value) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(value);
}
inline void CheckChunkRequest::set_chunkname(const void* value, size_t size) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CheckChunkRequest::mutable_chunkname() {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  return chunkname_;
}

// -------------------------------------------------------------------

// CheckChunkResponse

// required uint32 result = 1;
inline bool CheckChunkResponse::has_result() const {
  return _has_bit(0);
}
inline void CheckChunkResponse::clear_result() {
  result_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 CheckChunkResponse::result() const {
  return result_;
}
inline void CheckChunkResponse::set_result(::google::protobuf::uint32 value) {
  _set_bit(0);
  result_ = value;
}

// required bytes pmid_id = 2;
inline bool CheckChunkResponse::has_pmid_id() const {
  return _has_bit(1);
}
inline void CheckChunkResponse::clear_pmid_id() {
  if (pmid_id_ != &_default_pmid_id_) {
    pmid_id_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& CheckChunkResponse::pmid_id() const {
  return *pmid_id_;
}
inline void CheckChunkResponse::set_pmid_id(const ::std::string& value) {
  _set_bit(1);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  pmid_id_->assign(value);
}
inline void CheckChunkResponse::set_pmid_id(const char* value) {
  _set_bit(1);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  pmid_id_->assign(value);
}
inline void CheckChunkResponse::set_pmid_id(const void* value, size_t size) {
  _set_bit(1);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  pmid_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CheckChunkResponse::mutable_pmid_id() {
  _set_bit(1);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  return pmid_id_;
}

// -------------------------------------------------------------------

// ValidityCheckRequest

// required bytes chunkname = 1;
inline bool ValidityCheckRequest::has_chunkname() const {
  return _has_bit(0);
}
inline void ValidityCheckRequest::clear_chunkname() {
  if (chunkname_ != &_default_chunkname_) {
    chunkname_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& ValidityCheckRequest::chunkname() const {
  return *chunkname_;
}
inline void ValidityCheckRequest::set_chunkname(const ::std::string& value) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(value);
}
inline void ValidityCheckRequest::set_chunkname(const char* value) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(value);
}
inline void ValidityCheckRequest::set_chunkname(const void* value, size_t size) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ValidityCheckRequest::mutable_chunkname() {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  return chunkname_;
}

// required bytes random_data = 2;
inline bool ValidityCheckRequest::has_random_data() const {
  return _has_bit(1);
}
inline void ValidityCheckRequest::clear_random_data() {
  if (random_data_ != &_default_random_data_) {
    random_data_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& ValidityCheckRequest::random_data() const {
  return *random_data_;
}
inline void ValidityCheckRequest::set_random_data(const ::std::string& value) {
  _set_bit(1);
  if (random_data_ == &_default_random_data_) {
    random_data_ = new ::std::string;
  }
  random_data_->assign(value);
}
inline void ValidityCheckRequest::set_random_data(const char* value) {
  _set_bit(1);
  if (random_data_ == &_default_random_data_) {
    random_data_ = new ::std::string;
  }
  random_data_->assign(value);
}
inline void ValidityCheckRequest::set_random_data(const void* value, size_t size) {
  _set_bit(1);
  if (random_data_ == &_default_random_data_) {
    random_data_ = new ::std::string;
  }
  random_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ValidityCheckRequest::mutable_random_data() {
  _set_bit(1);
  if (random_data_ == &_default_random_data_) {
    random_data_ = new ::std::string;
  }
  return random_data_;
}

// -------------------------------------------------------------------

// ValidityCheckResponse

// required uint32 result = 1;
inline bool ValidityCheckResponse::has_result() const {
  return _has_bit(0);
}
inline void ValidityCheckResponse::clear_result() {
  result_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 ValidityCheckResponse::result() const {
  return result_;
}
inline void ValidityCheckResponse::set_result(::google::protobuf::uint32 value) {
  _set_bit(0);
  result_ = value;
}

// optional bytes hash_content = 2;
inline bool ValidityCheckResponse::has_hash_content() const {
  return _has_bit(1);
}
inline void ValidityCheckResponse::clear_hash_content() {
  if (hash_content_ != &_default_hash_content_) {
    hash_content_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& ValidityCheckResponse::hash_content() const {
  return *hash_content_;
}
inline void ValidityCheckResponse::set_hash_content(const ::std::string& value) {
  _set_bit(1);
  if (hash_content_ == &_default_hash_content_) {
    hash_content_ = new ::std::string;
  }
  hash_content_->assign(value);
}
inline void ValidityCheckResponse::set_hash_content(const char* value) {
  _set_bit(1);
  if (hash_content_ == &_default_hash_content_) {
    hash_content_ = new ::std::string;
  }
  hash_content_->assign(value);
}
inline void ValidityCheckResponse::set_hash_content(const void* value, size_t size) {
  _set_bit(1);
  if (hash_content_ == &_default_hash_content_) {
    hash_content_ = new ::std::string;
  }
  hash_content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ValidityCheckResponse::mutable_hash_content() {
  _set_bit(1);
  if (hash_content_ == &_default_hash_content_) {
    hash_content_ = new ::std::string;
  }
  return hash_content_;
}

// required bytes pmid_id = 3;
inline bool ValidityCheckResponse::has_pmid_id() const {
  return _has_bit(2);
}
inline void ValidityCheckResponse::clear_pmid_id() {
  if (pmid_id_ != &_default_pmid_id_) {
    pmid_id_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& ValidityCheckResponse::pmid_id() const {
  return *pmid_id_;
}
inline void ValidityCheckResponse::set_pmid_id(const ::std::string& value) {
  _set_bit(2);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  pmid_id_->assign(value);
}
inline void ValidityCheckResponse::set_pmid_id(const char* value) {
  _set_bit(2);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  pmid_id_->assign(value);
}
inline void ValidityCheckResponse::set_pmid_id(const void* value, size_t size) {
  _set_bit(2);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  pmid_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ValidityCheckResponse::mutable_pmid_id() {
  _set_bit(2);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  return pmid_id_;
}

// -------------------------------------------------------------------

// UpdateRequest

// required bytes chunkname = 1;
inline bool UpdateRequest::has_chunkname() const {
  return _has_bit(0);
}
inline void UpdateRequest::clear_chunkname() {
  if (chunkname_ != &_default_chunkname_) {
    chunkname_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& UpdateRequest::chunkname() const {
  return *chunkname_;
}
inline void UpdateRequest::set_chunkname(const ::std::string& value) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(value);
}
inline void UpdateRequest::set_chunkname(const char* value) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(value);
}
inline void UpdateRequest::set_chunkname(const void* value, size_t size) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpdateRequest::mutable_chunkname() {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  return chunkname_;
}

// required bytes data = 2;
inline bool UpdateRequest::has_data() const {
  return _has_bit(1);
}
inline void UpdateRequest::clear_data() {
  if (data_ != &_default_data_) {
    data_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& UpdateRequest::data() const {
  return *data_;
}
inline void UpdateRequest::set_data(const ::std::string& value) {
  _set_bit(1);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void UpdateRequest::set_data(const char* value) {
  _set_bit(1);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void UpdateRequest::set_data(const void* value, size_t size) {
  _set_bit(1);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpdateRequest::mutable_data() {
  _set_bit(1);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  return data_;
}

// required bytes public_key = 3;
inline bool UpdateRequest::has_public_key() const {
  return _has_bit(2);
}
inline void UpdateRequest::clear_public_key() {
  if (public_key_ != &_default_public_key_) {
    public_key_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& UpdateRequest::public_key() const {
  return *public_key_;
}
inline void UpdateRequest::set_public_key(const ::std::string& value) {
  _set_bit(2);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void UpdateRequest::set_public_key(const char* value) {
  _set_bit(2);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void UpdateRequest::set_public_key(const void* value, size_t size) {
  _set_bit(2);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpdateRequest::mutable_public_key() {
  _set_bit(2);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  return public_key_;
}

// required bytes signed_public_key = 4;
inline bool UpdateRequest::has_signed_public_key() const {
  return _has_bit(3);
}
inline void UpdateRequest::clear_signed_public_key() {
  if (signed_public_key_ != &_default_signed_public_key_) {
    signed_public_key_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& UpdateRequest::signed_public_key() const {
  return *signed_public_key_;
}
inline void UpdateRequest::set_signed_public_key(const ::std::string& value) {
  _set_bit(3);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  signed_public_key_->assign(value);
}
inline void UpdateRequest::set_signed_public_key(const char* value) {
  _set_bit(3);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  signed_public_key_->assign(value);
}
inline void UpdateRequest::set_signed_public_key(const void* value, size_t size) {
  _set_bit(3);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  signed_public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpdateRequest::mutable_signed_public_key() {
  _set_bit(3);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  return signed_public_key_;
}

// required bytes signed_request = 5;
inline bool UpdateRequest::has_signed_request() const {
  return _has_bit(4);
}
inline void UpdateRequest::clear_signed_request() {
  if (signed_request_ != &_default_signed_request_) {
    signed_request_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& UpdateRequest::signed_request() const {
  return *signed_request_;
}
inline void UpdateRequest::set_signed_request(const ::std::string& value) {
  _set_bit(4);
  if (signed_request_ == &_default_signed_request_) {
    signed_request_ = new ::std::string;
  }
  signed_request_->assign(value);
}
inline void UpdateRequest::set_signed_request(const char* value) {
  _set_bit(4);
  if (signed_request_ == &_default_signed_request_) {
    signed_request_ = new ::std::string;
  }
  signed_request_->assign(value);
}
inline void UpdateRequest::set_signed_request(const void* value, size_t size) {
  _set_bit(4);
  if (signed_request_ == &_default_signed_request_) {
    signed_request_ = new ::std::string;
  }
  signed_request_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpdateRequest::mutable_signed_request() {
  _set_bit(4);
  if (signed_request_ == &_default_signed_request_) {
    signed_request_ = new ::std::string;
  }
  return signed_request_;
}

// required int32 data_type = 6;
inline bool UpdateRequest::has_data_type() const {
  return _has_bit(5);
}
inline void UpdateRequest::clear_data_type() {
  data_type_ = 0;
  _clear_bit(5);
}
inline ::google::protobuf::int32 UpdateRequest::data_type() const {
  return data_type_;
}
inline void UpdateRequest::set_data_type(::google::protobuf::int32 value) {
  _set_bit(5);
  data_type_ = value;
}

// -------------------------------------------------------------------

// UpdateResponse

// required uint32 result = 1;
inline bool UpdateResponse::has_result() const {
  return _has_bit(0);
}
inline void UpdateResponse::clear_result() {
  result_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 UpdateResponse::result() const {
  return result_;
}
inline void UpdateResponse::set_result(::google::protobuf::uint32 value) {
  _set_bit(0);
  result_ = value;
}

// optional bytes pmid_id = 2;
inline bool UpdateResponse::has_pmid_id() const {
  return _has_bit(1);
}
inline void UpdateResponse::clear_pmid_id() {
  if (pmid_id_ != &_default_pmid_id_) {
    pmid_id_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& UpdateResponse::pmid_id() const {
  return *pmid_id_;
}
inline void UpdateResponse::set_pmid_id(const ::std::string& value) {
  _set_bit(1);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  pmid_id_->assign(value);
}
inline void UpdateResponse::set_pmid_id(const char* value) {
  _set_bit(1);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  pmid_id_->assign(value);
}
inline void UpdateResponse::set_pmid_id(const void* value, size_t size) {
  _set_bit(1);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  pmid_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpdateResponse::mutable_pmid_id() {
  _set_bit(1);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  return pmid_id_;
}

// -------------------------------------------------------------------

// GetMessagesRequest

// required bytes buffer_packet_name = 1;
inline bool GetMessagesRequest::has_buffer_packet_name() const {
  return _has_bit(0);
}
inline void GetMessagesRequest::clear_buffer_packet_name() {
  if (buffer_packet_name_ != &_default_buffer_packet_name_) {
    buffer_packet_name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& GetMessagesRequest::buffer_packet_name() const {
  return *buffer_packet_name_;
}
inline void GetMessagesRequest::set_buffer_packet_name(const ::std::string& value) {
  _set_bit(0);
  if (buffer_packet_name_ == &_default_buffer_packet_name_) {
    buffer_packet_name_ = new ::std::string;
  }
  buffer_packet_name_->assign(value);
}
inline void GetMessagesRequest::set_buffer_packet_name(const char* value) {
  _set_bit(0);
  if (buffer_packet_name_ == &_default_buffer_packet_name_) {
    buffer_packet_name_ = new ::std::string;
  }
  buffer_packet_name_->assign(value);
}
inline void GetMessagesRequest::set_buffer_packet_name(const void* value, size_t size) {
  _set_bit(0);
  if (buffer_packet_name_ == &_default_buffer_packet_name_) {
    buffer_packet_name_ = new ::std::string;
  }
  buffer_packet_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetMessagesRequest::mutable_buffer_packet_name() {
  _set_bit(0);
  if (buffer_packet_name_ == &_default_buffer_packet_name_) {
    buffer_packet_name_ = new ::std::string;
  }
  return buffer_packet_name_;
}

// required bytes public_key = 2;
inline bool GetMessagesRequest::has_public_key() const {
  return _has_bit(1);
}
inline void GetMessagesRequest::clear_public_key() {
  if (public_key_ != &_default_public_key_) {
    public_key_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& GetMessagesRequest::public_key() const {
  return *public_key_;
}
inline void GetMessagesRequest::set_public_key(const ::std::string& value) {
  _set_bit(1);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void GetMessagesRequest::set_public_key(const char* value) {
  _set_bit(1);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void GetMessagesRequest::set_public_key(const void* value, size_t size) {
  _set_bit(1);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetMessagesRequest::mutable_public_key() {
  _set_bit(1);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  return public_key_;
}

// required bytes signed_public_key = 3;
inline bool GetMessagesRequest::has_signed_public_key() const {
  return _has_bit(2);
}
inline void GetMessagesRequest::clear_signed_public_key() {
  if (signed_public_key_ != &_default_signed_public_key_) {
    signed_public_key_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& GetMessagesRequest::signed_public_key() const {
  return *signed_public_key_;
}
inline void GetMessagesRequest::set_signed_public_key(const ::std::string& value) {
  _set_bit(2);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  signed_public_key_->assign(value);
}
inline void GetMessagesRequest::set_signed_public_key(const char* value) {
  _set_bit(2);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  signed_public_key_->assign(value);
}
inline void GetMessagesRequest::set_signed_public_key(const void* value, size_t size) {
  _set_bit(2);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  signed_public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetMessagesRequest::mutable_signed_public_key() {
  _set_bit(2);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  return signed_public_key_;
}

// -------------------------------------------------------------------

// GetMessagesResponse

// required uint32 result = 1;
inline bool GetMessagesResponse::has_result() const {
  return _has_bit(0);
}
inline void GetMessagesResponse::clear_result() {
  result_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 GetMessagesResponse::result() const {
  return result_;
}
inline void GetMessagesResponse::set_result(::google::protobuf::uint32 value) {
  _set_bit(0);
  result_ = value;
}

// repeated bytes messages = 2;
inline int GetMessagesResponse::messages_size() const {
  return messages_.size();
}
inline void GetMessagesResponse::clear_messages() {
  messages_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GetMessagesResponse::messages() const {
  return messages_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GetMessagesResponse::mutable_messages() {
  return &messages_;
}
inline const ::std::string& GetMessagesResponse::messages(int index) const {
  return messages_.Get(index);
}
inline ::std::string* GetMessagesResponse::mutable_messages(int index) {
  return messages_.Mutable(index);
}
inline void GetMessagesResponse::set_messages(int index, const ::std::string& value) {
  messages_.Mutable(index)->assign(value);
}
inline void GetMessagesResponse::set_messages(int index, const char* value) {
  messages_.Mutable(index)->assign(value);
}
inline void GetMessagesResponse::set_messages(int index, const void* value, size_t size) {
  messages_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetMessagesResponse::add_messages() {
  return messages_.Add();
}
inline void GetMessagesResponse::add_messages(const ::std::string& value) {
  messages_.Add()->assign(value);
}
inline void GetMessagesResponse::add_messages(const char* value) {
  messages_.Add()->assign(value);
}
inline void GetMessagesResponse::add_messages(const void* value, size_t size) {
  messages_.Add()->assign(reinterpret_cast<const char*>(value), size);
}

// optional bytes pmid_id = 3;
inline bool GetMessagesResponse::has_pmid_id() const {
  return _has_bit(2);
}
inline void GetMessagesResponse::clear_pmid_id() {
  if (pmid_id_ != &_default_pmid_id_) {
    pmid_id_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& GetMessagesResponse::pmid_id() const {
  return *pmid_id_;
}
inline void GetMessagesResponse::set_pmid_id(const ::std::string& value) {
  _set_bit(2);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  pmid_id_->assign(value);
}
inline void GetMessagesResponse::set_pmid_id(const char* value) {
  _set_bit(2);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  pmid_id_->assign(value);
}
inline void GetMessagesResponse::set_pmid_id(const void* value, size_t size) {
  _set_bit(2);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  pmid_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetMessagesResponse::mutable_pmid_id() {
  _set_bit(2);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  return pmid_id_;
}

// -------------------------------------------------------------------

// SwapChunkRequest

// required int32 request_type = 1;
inline bool SwapChunkRequest::has_request_type() const {
  return _has_bit(0);
}
inline void SwapChunkRequest::clear_request_type() {
  request_type_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 SwapChunkRequest::request_type() const {
  return request_type_;
}
inline void SwapChunkRequest::set_request_type(::google::protobuf::int32 value) {
  _set_bit(0);
  request_type_ = value;
}

// required bytes chunkname1 = 2;
inline bool SwapChunkRequest::has_chunkname1() const {
  return _has_bit(1);
}
inline void SwapChunkRequest::clear_chunkname1() {
  if (chunkname1_ != &_default_chunkname1_) {
    chunkname1_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& SwapChunkRequest::chunkname1() const {
  return *chunkname1_;
}
inline void SwapChunkRequest::set_chunkname1(const ::std::string& value) {
  _set_bit(1);
  if (chunkname1_ == &_default_chunkname1_) {
    chunkname1_ = new ::std::string;
  }
  chunkname1_->assign(value);
}
inline void SwapChunkRequest::set_chunkname1(const char* value) {
  _set_bit(1);
  if (chunkname1_ == &_default_chunkname1_) {
    chunkname1_ = new ::std::string;
  }
  chunkname1_->assign(value);
}
inline void SwapChunkRequest::set_chunkname1(const void* value, size_t size) {
  _set_bit(1);
  if (chunkname1_ == &_default_chunkname1_) {
    chunkname1_ = new ::std::string;
  }
  chunkname1_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SwapChunkRequest::mutable_chunkname1() {
  _set_bit(1);
  if (chunkname1_ == &_default_chunkname1_) {
    chunkname1_ = new ::std::string;
  }
  return chunkname1_;
}

// optional bytes chunkcontent1 = 3;
inline bool SwapChunkRequest::has_chunkcontent1() const {
  return _has_bit(2);
}
inline void SwapChunkRequest::clear_chunkcontent1() {
  if (chunkcontent1_ != &_default_chunkcontent1_) {
    chunkcontent1_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& SwapChunkRequest::chunkcontent1() const {
  return *chunkcontent1_;
}
inline void SwapChunkRequest::set_chunkcontent1(const ::std::string& value) {
  _set_bit(2);
  if (chunkcontent1_ == &_default_chunkcontent1_) {
    chunkcontent1_ = new ::std::string;
  }
  chunkcontent1_->assign(value);
}
inline void SwapChunkRequest::set_chunkcontent1(const char* value) {
  _set_bit(2);
  if (chunkcontent1_ == &_default_chunkcontent1_) {
    chunkcontent1_ = new ::std::string;
  }
  chunkcontent1_->assign(value);
}
inline void SwapChunkRequest::set_chunkcontent1(const void* value, size_t size) {
  _set_bit(2);
  if (chunkcontent1_ == &_default_chunkcontent1_) {
    chunkcontent1_ = new ::std::string;
  }
  chunkcontent1_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SwapChunkRequest::mutable_chunkcontent1() {
  _set_bit(2);
  if (chunkcontent1_ == &_default_chunkcontent1_) {
    chunkcontent1_ = new ::std::string;
  }
  return chunkcontent1_;
}

// optional int32 size1 = 4;
inline bool SwapChunkRequest::has_size1() const {
  return _has_bit(3);
}
inline void SwapChunkRequest::clear_size1() {
  size1_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 SwapChunkRequest::size1() const {
  return size1_;
}
inline void SwapChunkRequest::set_size1(::google::protobuf::int32 value) {
  _set_bit(3);
  size1_ = value;
}

// optional bytes chunkname2 = 5;
inline bool SwapChunkRequest::has_chunkname2() const {
  return _has_bit(4);
}
inline void SwapChunkRequest::clear_chunkname2() {
  if (chunkname2_ != &_default_chunkname2_) {
    chunkname2_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& SwapChunkRequest::chunkname2() const {
  return *chunkname2_;
}
inline void SwapChunkRequest::set_chunkname2(const ::std::string& value) {
  _set_bit(4);
  if (chunkname2_ == &_default_chunkname2_) {
    chunkname2_ = new ::std::string;
  }
  chunkname2_->assign(value);
}
inline void SwapChunkRequest::set_chunkname2(const char* value) {
  _set_bit(4);
  if (chunkname2_ == &_default_chunkname2_) {
    chunkname2_ = new ::std::string;
  }
  chunkname2_->assign(value);
}
inline void SwapChunkRequest::set_chunkname2(const void* value, size_t size) {
  _set_bit(4);
  if (chunkname2_ == &_default_chunkname2_) {
    chunkname2_ = new ::std::string;
  }
  chunkname2_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SwapChunkRequest::mutable_chunkname2() {
  _set_bit(4);
  if (chunkname2_ == &_default_chunkname2_) {
    chunkname2_ = new ::std::string;
  }
  return chunkname2_;
}

// -------------------------------------------------------------------

// SwapChunkResponse

// required int32 request_type = 1;
inline bool SwapChunkResponse::has_request_type() const {
  return _has_bit(0);
}
inline void SwapChunkResponse::clear_request_type() {
  request_type_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 SwapChunkResponse::request_type() const {
  return request_type_;
}
inline void SwapChunkResponse::set_request_type(::google::protobuf::int32 value) {
  _set_bit(0);
  request_type_ = value;
}

// required uint32 result = 2;
inline bool SwapChunkResponse::has_result() const {
  return _has_bit(1);
}
inline void SwapChunkResponse::clear_result() {
  result_ = 0u;
  _clear_bit(1);
}
inline ::google::protobuf::uint32 SwapChunkResponse::result() const {
  return result_;
}
inline void SwapChunkResponse::set_result(::google::protobuf::uint32 value) {
  _set_bit(1);
  result_ = value;
}

// optional bytes chunkname1 = 3;
inline bool SwapChunkResponse::has_chunkname1() const {
  return _has_bit(2);
}
inline void SwapChunkResponse::clear_chunkname1() {
  if (chunkname1_ != &_default_chunkname1_) {
    chunkname1_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& SwapChunkResponse::chunkname1() const {
  return *chunkname1_;
}
inline void SwapChunkResponse::set_chunkname1(const ::std::string& value) {
  _set_bit(2);
  if (chunkname1_ == &_default_chunkname1_) {
    chunkname1_ = new ::std::string;
  }
  chunkname1_->assign(value);
}
inline void SwapChunkResponse::set_chunkname1(const char* value) {
  _set_bit(2);
  if (chunkname1_ == &_default_chunkname1_) {
    chunkname1_ = new ::std::string;
  }
  chunkname1_->assign(value);
}
inline void SwapChunkResponse::set_chunkname1(const void* value, size_t size) {
  _set_bit(2);
  if (chunkname1_ == &_default_chunkname1_) {
    chunkname1_ = new ::std::string;
  }
  chunkname1_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SwapChunkResponse::mutable_chunkname1() {
  _set_bit(2);
  if (chunkname1_ == &_default_chunkname1_) {
    chunkname1_ = new ::std::string;
  }
  return chunkname1_;
}

// optional bytes chunkcontent1 = 4;
inline bool SwapChunkResponse::has_chunkcontent1() const {
  return _has_bit(3);
}
inline void SwapChunkResponse::clear_chunkcontent1() {
  if (chunkcontent1_ != &_default_chunkcontent1_) {
    chunkcontent1_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& SwapChunkResponse::chunkcontent1() const {
  return *chunkcontent1_;
}
inline void SwapChunkResponse::set_chunkcontent1(const ::std::string& value) {
  _set_bit(3);
  if (chunkcontent1_ == &_default_chunkcontent1_) {
    chunkcontent1_ = new ::std::string;
  }
  chunkcontent1_->assign(value);
}
inline void SwapChunkResponse::set_chunkcontent1(const char* value) {
  _set_bit(3);
  if (chunkcontent1_ == &_default_chunkcontent1_) {
    chunkcontent1_ = new ::std::string;
  }
  chunkcontent1_->assign(value);
}
inline void SwapChunkResponse::set_chunkcontent1(const void* value, size_t size) {
  _set_bit(3);
  if (chunkcontent1_ == &_default_chunkcontent1_) {
    chunkcontent1_ = new ::std::string;
  }
  chunkcontent1_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SwapChunkResponse::mutable_chunkcontent1() {
  _set_bit(3);
  if (chunkcontent1_ == &_default_chunkcontent1_) {
    chunkcontent1_ = new ::std::string;
  }
  return chunkcontent1_;
}

// optional int32 size1 = 5;
inline bool SwapChunkResponse::has_size1() const {
  return _has_bit(4);
}
inline void SwapChunkResponse::clear_size1() {
  size1_ = 0;
  _clear_bit(4);
}
inline ::google::protobuf::int32 SwapChunkResponse::size1() const {
  return size1_;
}
inline void SwapChunkResponse::set_size1(::google::protobuf::int32 value) {
  _set_bit(4);
  size1_ = value;
}

// optional bytes chunkname2 = 6;
inline bool SwapChunkResponse::has_chunkname2() const {
  return _has_bit(5);
}
inline void SwapChunkResponse::clear_chunkname2() {
  if (chunkname2_ != &_default_chunkname2_) {
    chunkname2_->clear();
  }
  _clear_bit(5);
}
inline const ::std::string& SwapChunkResponse::chunkname2() const {
  return *chunkname2_;
}
inline void SwapChunkResponse::set_chunkname2(const ::std::string& value) {
  _set_bit(5);
  if (chunkname2_ == &_default_chunkname2_) {
    chunkname2_ = new ::std::string;
  }
  chunkname2_->assign(value);
}
inline void SwapChunkResponse::set_chunkname2(const char* value) {
  _set_bit(5);
  if (chunkname2_ == &_default_chunkname2_) {
    chunkname2_ = new ::std::string;
  }
  chunkname2_->assign(value);
}
inline void SwapChunkResponse::set_chunkname2(const void* value, size_t size) {
  _set_bit(5);
  if (chunkname2_ == &_default_chunkname2_) {
    chunkname2_ = new ::std::string;
  }
  chunkname2_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SwapChunkResponse::mutable_chunkname2() {
  _set_bit(5);
  if (chunkname2_ == &_default_chunkname2_) {
    chunkname2_ = new ::std::string;
  }
  return chunkname2_;
}

// optional bytes chunkcontent2 = 7;
inline bool SwapChunkResponse::has_chunkcontent2() const {
  return _has_bit(6);
}
inline void SwapChunkResponse::clear_chunkcontent2() {
  if (chunkcontent2_ != &_default_chunkcontent2_) {
    chunkcontent2_->clear();
  }
  _clear_bit(6);
}
inline const ::std::string& SwapChunkResponse::chunkcontent2() const {
  return *chunkcontent2_;
}
inline void SwapChunkResponse::set_chunkcontent2(const ::std::string& value) {
  _set_bit(6);
  if (chunkcontent2_ == &_default_chunkcontent2_) {
    chunkcontent2_ = new ::std::string;
  }
  chunkcontent2_->assign(value);
}
inline void SwapChunkResponse::set_chunkcontent2(const char* value) {
  _set_bit(6);
  if (chunkcontent2_ == &_default_chunkcontent2_) {
    chunkcontent2_ = new ::std::string;
  }
  chunkcontent2_->assign(value);
}
inline void SwapChunkResponse::set_chunkcontent2(const void* value, size_t size) {
  _set_bit(6);
  if (chunkcontent2_ == &_default_chunkcontent2_) {
    chunkcontent2_ = new ::std::string;
  }
  chunkcontent2_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SwapChunkResponse::mutable_chunkcontent2() {
  _set_bit(6);
  if (chunkcontent2_ == &_default_chunkcontent2_) {
    chunkcontent2_ = new ::std::string;
  }
  return chunkcontent2_;
}

// optional int32 size2 = 8;
inline bool SwapChunkResponse::has_size2() const {
  return _has_bit(7);
}
inline void SwapChunkResponse::clear_size2() {
  size2_ = 0;
  _clear_bit(7);
}
inline ::google::protobuf::int32 SwapChunkResponse::size2() const {
  return size2_;
}
inline void SwapChunkResponse::set_size2(::google::protobuf::int32 value) {
  _set_bit(7);
  size2_ = value;
}

// required bytes pmid_id = 9;
inline bool SwapChunkResponse::has_pmid_id() const {
  return _has_bit(8);
}
inline void SwapChunkResponse::clear_pmid_id() {
  if (pmid_id_ != &_default_pmid_id_) {
    pmid_id_->clear();
  }
  _clear_bit(8);
}
inline const ::std::string& SwapChunkResponse::pmid_id() const {
  return *pmid_id_;
}
inline void SwapChunkResponse::set_pmid_id(const ::std::string& value) {
  _set_bit(8);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  pmid_id_->assign(value);
}
inline void SwapChunkResponse::set_pmid_id(const char* value) {
  _set_bit(8);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  pmid_id_->assign(value);
}
inline void SwapChunkResponse::set_pmid_id(const void* value, size_t size) {
  _set_bit(8);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  pmid_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SwapChunkResponse::mutable_pmid_id() {
  _set_bit(8);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  return pmid_id_;
}

// -------------------------------------------------------------------

// VaultCommunication

// optional bytes chunkstore = 1;
inline bool VaultCommunication::has_chunkstore() const {
  return _has_bit(0);
}
inline void VaultCommunication::clear_chunkstore() {
  if (chunkstore_ != &_default_chunkstore_) {
    chunkstore_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& VaultCommunication::chunkstore() const {
  return *chunkstore_;
}
inline void VaultCommunication::set_chunkstore(const ::std::string& value) {
  _set_bit(0);
  if (chunkstore_ == &_default_chunkstore_) {
    chunkstore_ = new ::std::string;
  }
  chunkstore_->assign(value);
}
inline void VaultCommunication::set_chunkstore(const char* value) {
  _set_bit(0);
  if (chunkstore_ == &_default_chunkstore_) {
    chunkstore_ = new ::std::string;
  }
  chunkstore_->assign(value);
}
inline void VaultCommunication::set_chunkstore(const void* value, size_t size) {
  _set_bit(0);
  if (chunkstore_ == &_default_chunkstore_) {
    chunkstore_ = new ::std::string;
  }
  chunkstore_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VaultCommunication::mutable_chunkstore() {
  _set_bit(0);
  if (chunkstore_ == &_default_chunkstore_) {
    chunkstore_ = new ::std::string;
  }
  return chunkstore_;
}

// optional uint64 offered_space = 2;
inline bool VaultCommunication::has_offered_space() const {
  return _has_bit(1);
}
inline void VaultCommunication::clear_offered_space() {
  offered_space_ = GOOGLE_ULONGLONG(0);
  _clear_bit(1);
}
inline ::google::protobuf::uint64 VaultCommunication::offered_space() const {
  return offered_space_;
}
inline void VaultCommunication::set_offered_space(::google::protobuf::uint64 value) {
  _set_bit(1);
  offered_space_ = value;
}

// optional uint64 free_space = 3;
inline bool VaultCommunication::has_free_space() const {
  return _has_bit(2);
}
inline void VaultCommunication::clear_free_space() {
  free_space_ = GOOGLE_ULONGLONG(0);
  _clear_bit(2);
}
inline ::google::protobuf::uint64 VaultCommunication::free_space() const {
  return free_space_;
}
inline void VaultCommunication::set_free_space(::google::protobuf::uint64 value) {
  _set_bit(2);
  free_space_ = value;
}

// required uint32 timestamp = 4;
inline bool VaultCommunication::has_timestamp() const {
  return _has_bit(3);
}
inline void VaultCommunication::clear_timestamp() {
  timestamp_ = 0u;
  _clear_bit(3);
}
inline ::google::protobuf::uint32 VaultCommunication::timestamp() const {
  return timestamp_;
}
inline void VaultCommunication::set_timestamp(::google::protobuf::uint32 value) {
  _set_bit(3);
  timestamp_ = value;
}

// -------------------------------------------------------------------

// VaultStatusRequest

// required bytes encrypted_request = 1;
inline bool VaultStatusRequest::has_encrypted_request() const {
  return _has_bit(0);
}
inline void VaultStatusRequest::clear_encrypted_request() {
  if (encrypted_request_ != &_default_encrypted_request_) {
    encrypted_request_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& VaultStatusRequest::encrypted_request() const {
  return *encrypted_request_;
}
inline void VaultStatusRequest::set_encrypted_request(const ::std::string& value) {
  _set_bit(0);
  if (encrypted_request_ == &_default_encrypted_request_) {
    encrypted_request_ = new ::std::string;
  }
  encrypted_request_->assign(value);
}
inline void VaultStatusRequest::set_encrypted_request(const char* value) {
  _set_bit(0);
  if (encrypted_request_ == &_default_encrypted_request_) {
    encrypted_request_ = new ::std::string;
  }
  encrypted_request_->assign(value);
}
inline void VaultStatusRequest::set_encrypted_request(const void* value, size_t size) {
  _set_bit(0);
  if (encrypted_request_ == &_default_encrypted_request_) {
    encrypted_request_ = new ::std::string;
  }
  encrypted_request_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VaultStatusRequest::mutable_encrypted_request() {
  _set_bit(0);
  if (encrypted_request_ == &_default_encrypted_request_) {
    encrypted_request_ = new ::std::string;
  }
  return encrypted_request_;
}

// -------------------------------------------------------------------

// VaultStatusResponse

// required uint32 result = 1;
inline bool VaultStatusResponse::has_result() const {
  return _has_bit(0);
}
inline void VaultStatusResponse::clear_result() {
  result_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 VaultStatusResponse::result() const {
  return result_;
}
inline void VaultStatusResponse::set_result(::google::protobuf::uint32 value) {
  _set_bit(0);
  result_ = value;
}

// optional bytes encrypted_response = 2;
inline bool VaultStatusResponse::has_encrypted_response() const {
  return _has_bit(1);
}
inline void VaultStatusResponse::clear_encrypted_response() {
  if (encrypted_response_ != &_default_encrypted_response_) {
    encrypted_response_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& VaultStatusResponse::encrypted_response() const {
  return *encrypted_response_;
}
inline void VaultStatusResponse::set_encrypted_response(const ::std::string& value) {
  _set_bit(1);
  if (encrypted_response_ == &_default_encrypted_response_) {
    encrypted_response_ = new ::std::string;
  }
  encrypted_response_->assign(value);
}
inline void VaultStatusResponse::set_encrypted_response(const char* value) {
  _set_bit(1);
  if (encrypted_response_ == &_default_encrypted_response_) {
    encrypted_response_ = new ::std::string;
  }
  encrypted_response_->assign(value);
}
inline void VaultStatusResponse::set_encrypted_response(const void* value, size_t size) {
  _set_bit(1);
  if (encrypted_response_ == &_default_encrypted_response_) {
    encrypted_response_ = new ::std::string;
  }
  encrypted_response_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VaultStatusResponse::mutable_encrypted_response() {
  _set_bit(1);
  if (encrypted_response_ == &_default_encrypted_response_) {
    encrypted_response_ = new ::std::string;
  }
  return encrypted_response_;
}

// -------------------------------------------------------------------

// OwnVaultRequest

// required bytes public_key = 1;
inline bool OwnVaultRequest::has_public_key() const {
  return _has_bit(0);
}
inline void OwnVaultRequest::clear_public_key() {
  if (public_key_ != &_default_public_key_) {
    public_key_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& OwnVaultRequest::public_key() const {
  return *public_key_;
}
inline void OwnVaultRequest::set_public_key(const ::std::string& value) {
  _set_bit(0);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void OwnVaultRequest::set_public_key(const char* value) {
  _set_bit(0);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void OwnVaultRequest::set_public_key(const void* value, size_t size) {
  _set_bit(0);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OwnVaultRequest::mutable_public_key() {
  _set_bit(0);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  return public_key_;
}

// required bytes private_key = 2;
inline bool OwnVaultRequest::has_private_key() const {
  return _has_bit(1);
}
inline void OwnVaultRequest::clear_private_key() {
  if (private_key_ != &_default_private_key_) {
    private_key_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& OwnVaultRequest::private_key() const {
  return *private_key_;
}
inline void OwnVaultRequest::set_private_key(const ::std::string& value) {
  _set_bit(1);
  if (private_key_ == &_default_private_key_) {
    private_key_ = new ::std::string;
  }
  private_key_->assign(value);
}
inline void OwnVaultRequest::set_private_key(const char* value) {
  _set_bit(1);
  if (private_key_ == &_default_private_key_) {
    private_key_ = new ::std::string;
  }
  private_key_->assign(value);
}
inline void OwnVaultRequest::set_private_key(const void* value, size_t size) {
  _set_bit(1);
  if (private_key_ == &_default_private_key_) {
    private_key_ = new ::std::string;
  }
  private_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OwnVaultRequest::mutable_private_key() {
  _set_bit(1);
  if (private_key_ == &_default_private_key_) {
    private_key_ = new ::std::string;
  }
  return private_key_;
}

// required bytes signed_public_key = 3;
inline bool OwnVaultRequest::has_signed_public_key() const {
  return _has_bit(2);
}
inline void OwnVaultRequest::clear_signed_public_key() {
  if (signed_public_key_ != &_default_signed_public_key_) {
    signed_public_key_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& OwnVaultRequest::signed_public_key() const {
  return *signed_public_key_;
}
inline void OwnVaultRequest::set_signed_public_key(const ::std::string& value) {
  _set_bit(2);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  signed_public_key_->assign(value);
}
inline void OwnVaultRequest::set_signed_public_key(const char* value) {
  _set_bit(2);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  signed_public_key_->assign(value);
}
inline void OwnVaultRequest::set_signed_public_key(const void* value, size_t size) {
  _set_bit(2);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  signed_public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OwnVaultRequest::mutable_signed_public_key() {
  _set_bit(2);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  return signed_public_key_;
}

// required bytes chunkstore_dir = 4;
inline bool OwnVaultRequest::has_chunkstore_dir() const {
  return _has_bit(3);
}
inline void OwnVaultRequest::clear_chunkstore_dir() {
  if (chunkstore_dir_ != &_default_chunkstore_dir_) {
    chunkstore_dir_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& OwnVaultRequest::chunkstore_dir() const {
  return *chunkstore_dir_;
}
inline void OwnVaultRequest::set_chunkstore_dir(const ::std::string& value) {
  _set_bit(3);
  if (chunkstore_dir_ == &_default_chunkstore_dir_) {
    chunkstore_dir_ = new ::std::string;
  }
  chunkstore_dir_->assign(value);
}
inline void OwnVaultRequest::set_chunkstore_dir(const char* value) {
  _set_bit(3);
  if (chunkstore_dir_ == &_default_chunkstore_dir_) {
    chunkstore_dir_ = new ::std::string;
  }
  chunkstore_dir_->assign(value);
}
inline void OwnVaultRequest::set_chunkstore_dir(const void* value, size_t size) {
  _set_bit(3);
  if (chunkstore_dir_ == &_default_chunkstore_dir_) {
    chunkstore_dir_ = new ::std::string;
  }
  chunkstore_dir_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OwnVaultRequest::mutable_chunkstore_dir() {
  _set_bit(3);
  if (chunkstore_dir_ == &_default_chunkstore_dir_) {
    chunkstore_dir_ = new ::std::string;
  }
  return chunkstore_dir_;
}

// required uint32 port = 5;
inline bool OwnVaultRequest::has_port() const {
  return _has_bit(4);
}
inline void OwnVaultRequest::clear_port() {
  port_ = 0u;
  _clear_bit(4);
}
inline ::google::protobuf::uint32 OwnVaultRequest::port() const {
  return port_;
}
inline void OwnVaultRequest::set_port(::google::protobuf::uint32 value) {
  _set_bit(4);
  port_ = value;
}

// required uint64 space = 6;
inline bool OwnVaultRequest::has_space() const {
  return _has_bit(5);
}
inline void OwnVaultRequest::clear_space() {
  space_ = GOOGLE_ULONGLONG(0);
  _clear_bit(5);
}
inline ::google::protobuf::uint64 OwnVaultRequest::space() const {
  return space_;
}
inline void OwnVaultRequest::set_space(::google::protobuf::uint64 value) {
  _set_bit(5);
  space_ = value;
}

// -------------------------------------------------------------------

// OwnVaultResponse

// required .maidsafe.OwnVaultResult result = 1;
inline bool OwnVaultResponse::has_result() const {
  return _has_bit(0);
}
inline void OwnVaultResponse::clear_result() {
  result_ = 0;
  _clear_bit(0);
}
inline maidsafe::OwnVaultResult OwnVaultResponse::result() const {
  return static_cast< maidsafe::OwnVaultResult >(result_);
}
inline void OwnVaultResponse::set_result(maidsafe::OwnVaultResult value) {
  GOOGLE_DCHECK(maidsafe::OwnVaultResult_IsValid(value));
  _set_bit(0);
  result_ = value;
}

// optional bytes pmid_name = 2;
inline bool OwnVaultResponse::has_pmid_name() const {
  return _has_bit(1);
}
inline void OwnVaultResponse::clear_pmid_name() {
  if (pmid_name_ != &_default_pmid_name_) {
    pmid_name_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& OwnVaultResponse::pmid_name() const {
  return *pmid_name_;
}
inline void OwnVaultResponse::set_pmid_name(const ::std::string& value) {
  _set_bit(1);
  if (pmid_name_ == &_default_pmid_name_) {
    pmid_name_ = new ::std::string;
  }
  pmid_name_->assign(value);
}
inline void OwnVaultResponse::set_pmid_name(const char* value) {
  _set_bit(1);
  if (pmid_name_ == &_default_pmid_name_) {
    pmid_name_ = new ::std::string;
  }
  pmid_name_->assign(value);
}
inline void OwnVaultResponse::set_pmid_name(const void* value, size_t size) {
  _set_bit(1);
  if (pmid_name_ == &_default_pmid_name_) {
    pmid_name_ = new ::std::string;
  }
  pmid_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OwnVaultResponse::mutable_pmid_name() {
  _set_bit(1);
  if (pmid_name_ == &_default_pmid_name_) {
    pmid_name_ = new ::std::string;
  }
  return pmid_name_;
}

// -------------------------------------------------------------------

// IsOwnedRequest

// -------------------------------------------------------------------

// IsOwnedResponse

// required .maidsafe.VaultStatus status = 1;
inline bool IsOwnedResponse::has_status() const {
  return _has_bit(0);
}
inline void IsOwnedResponse::clear_status() {
  status_ = 0;
  _clear_bit(0);
}
inline maidsafe::VaultStatus IsOwnedResponse::status() const {
  return static_cast< maidsafe::VaultStatus >(status_);
}
inline void IsOwnedResponse::set_status(maidsafe::VaultStatus value) {
  GOOGLE_DCHECK(maidsafe::VaultStatus_IsValid(value));
  _set_bit(0);
  status_ = value;
}


}  // namespace maidsafe
#endif  // PROTOBUF_maidsafe_5fservice_5fmessages_2eproto__INCLUDED
