// Generated by the protocol buffer compiler.  DO NOT EDIT!

#ifndef PROTOBUF_maidsafe_5fservice_5fmessages_2eproto__INCLUDED
#define PROTOBUF_maidsafe_5fservice_5fmessages_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2001000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2001000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "packet.pb.h"

namespace maidsafe {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();

class SignedSize;
class StoreContract;
class StoreContract_InnerContract;
class StorePrepRequest;
class StorePrepResponse;
class StoreChunkRequest;
class StoreChunkResponse;
class StorePacketRequest;
class StorePacketResponse;
class AddToWatchListRequest;
class AddToWatchListResponse;
class RemoveFromWatchListRequest;
class RemoveFromWatchListResponse;
class AddToReferenceListRequest;
class AddToReferenceListResponse;
class RemoveFromReferenceListRequest;
class RemoveFromReferenceListResponse;
class AmendAccountRequest;
class AmendAccountResponse;
class AccountStatusRequest;
class AccountStatusResponse;
class CheckChunkRequest;
class CheckChunkResponse;
class GetChunkRequest;
class GetChunkResponse;
class GetPacketRequest;
class GetPacketResponse;
class UpdateChunkRequest;
class UpdateChunkResponse;
class DeleteChunkRequest;
class DeleteChunkResponse;
class ValidityCheckRequest;
class ValidityCheckResponse;
class SwapChunkRequest;
class SwapChunkResponse;
class VaultCommunication;
class VaultStatusRequest;
class VaultStatusResponse;
class OwnVaultRequest;
class OwnVaultResponse;
class IsOwnedRequest;
class IsOwnedResponse;
class CreateBPRequest;
class CreateBPResponse;
class ModifyBPInfoRequest;
class ModifyBPInfoResponse;
class GetBPMessagesRequest;
class GetBPMessagesResponse;
class AddBPMessageRequest;
class AddBPMessageResponse;

enum AmendAccountRequest_Amendment {
  AmendAccountRequest_Amendment_kSpaceOffered = 0,
  AmendAccountRequest_Amendment_kSpaceGivenInc = 1,
  AmendAccountRequest_Amendment_kSpaceGivenDec = 2,
  AmendAccountRequest_Amendment_kSpaceTakenInc = 3,
  AmendAccountRequest_Amendment_kSpaceTakenDec = 4
};
const ::google::protobuf::EnumDescriptor* AmendAccountRequest_Amendment_descriptor();
bool AmendAccountRequest_Amendment_IsValid(int value);
const AmendAccountRequest_Amendment AmendAccountRequest_Amendment_Amendment_MIN = AmendAccountRequest_Amendment_kSpaceOffered;
const AmendAccountRequest_Amendment AmendAccountRequest_Amendment_Amendment_MAX = AmendAccountRequest_Amendment_kSpaceTakenDec;

inline const ::std::string& AmendAccountRequest_Amendment_Name(AmendAccountRequest_Amendment value) {
  return ::google::protobuf::internal::NameOfEnum(
    AmendAccountRequest_Amendment_descriptor(), value);
}
inline bool AmendAccountRequest_Amendment_Parse(
    const ::std::string& name, AmendAccountRequest_Amendment* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AmendAccountRequest_Amendment>(
    AmendAccountRequest_Amendment_descriptor(), name, value);
}
enum OwnVaultResult {
  OWNED_SUCCESS = 0,
  VAULT_ALREADY_OWNED = 1,
  VAULT_IS_DOWN = 2,
  INVALID_RSA_KEYS = 3,
  NOT_ENOUGH_SPACE = 4,
  NO_SPACE_ALLOCATED = 5,
  INVALID_PORT = 6,
  FAILED_TO_START_VAULT = 7,
  INVALID_OWNREQUEST = 8,
  INVALID_PMID_NAME = 9
};
const ::google::protobuf::EnumDescriptor* OwnVaultResult_descriptor();
bool OwnVaultResult_IsValid(int value);
const OwnVaultResult OwnVaultResult_MIN = OWNED_SUCCESS;
const OwnVaultResult OwnVaultResult_MAX = INVALID_PMID_NAME;

inline const ::std::string& OwnVaultResult_Name(OwnVaultResult value) {
  return ::google::protobuf::internal::NameOfEnum(
    OwnVaultResult_descriptor(), value);
}
inline bool OwnVaultResult_Parse(
    const ::std::string& name, OwnVaultResult* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OwnVaultResult>(
    OwnVaultResult_descriptor(), name, value);
}
enum VaultStatus {
  NOT_OWNED = 0,
  OWNED = 1,
  DOWN = 2,
  ISOWNRPC_CANCELLED = 3
};
const ::google::protobuf::EnumDescriptor* VaultStatus_descriptor();
bool VaultStatus_IsValid(int value);
const VaultStatus VaultStatus_MIN = NOT_OWNED;
const VaultStatus VaultStatus_MAX = ISOWNRPC_CANCELLED;

inline const ::std::string& VaultStatus_Name(VaultStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    VaultStatus_descriptor(), value);
}
inline bool VaultStatus_Parse(
    const ::std::string& name, VaultStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VaultStatus>(
    VaultStatus_descriptor(), name, value);
}
// ===================================================================

class SignedSize : public ::google::protobuf::Message {
 public:
  SignedSize();
  virtual ~SignedSize();
  
  SignedSize(const SignedSize& from);
  
  inline SignedSize& operator=(const SignedSize& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SignedSize& default_instance();
  void Swap(SignedSize* other);
  
  // implements Message ----------------------------------------------
  
  SignedSize* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SignedSize& from);
  void MergeFrom(const SignedSize& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint64 data_size = 1;
  inline bool has_data_size() const;
  inline void clear_data_size();
  static const int kDataSizeFieldNumber = 1;
  inline ::google::protobuf::uint64 data_size() const;
  inline void set_data_size(::google::protobuf::uint64 value);
  
  // required bytes signature = 2;
  inline bool has_signature() const;
  inline void clear_signature();
  static const int kSignatureFieldNumber = 2;
  inline const ::std::string& signature() const;
  inline void set_signature(const ::std::string& value);
  inline void set_signature(const char* value);
  inline void set_signature(const void* value, size_t size);
  inline ::std::string* mutable_signature();
  
  // required bytes pmid = 3;
  inline bool has_pmid() const;
  inline void clear_pmid();
  static const int kPmidFieldNumber = 3;
  inline const ::std::string& pmid() const;
  inline void set_pmid(const ::std::string& value);
  inline void set_pmid(const char* value);
  inline void set_pmid(const void* value, size_t size);
  inline ::std::string* mutable_pmid();
  
  // required bytes public_key = 4;
  inline bool has_public_key() const;
  inline void clear_public_key();
  static const int kPublicKeyFieldNumber = 4;
  inline const ::std::string& public_key() const;
  inline void set_public_key(const ::std::string& value);
  inline void set_public_key(const char* value);
  inline void set_public_key(const void* value, size_t size);
  inline ::std::string* mutable_public_key();
  
  // required bytes public_key_signature = 5;
  inline bool has_public_key_signature() const;
  inline void clear_public_key_signature();
  static const int kPublicKeySignatureFieldNumber = 5;
  inline const ::std::string& public_key_signature() const;
  inline void set_public_key_signature(const ::std::string& value);
  inline void set_public_key_signature(const char* value);
  inline void set_public_key_signature(const void* value, size_t size);
  inline ::std::string* mutable_public_key_signature();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint64 data_size_;
  ::std::string* signature_;
  static const ::std::string _default_signature_;
  ::std::string* pmid_;
  static const ::std::string _default_pmid_;
  ::std::string* public_key_;
  static const ::std::string _default_public_key_;
  ::std::string* public_key_signature_;
  static const ::std::string _default_public_key_signature_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static SignedSize* default_instance_;
};
// -------------------------------------------------------------------

class StoreContract_InnerContract : public ::google::protobuf::Message {
 public:
  StoreContract_InnerContract();
  virtual ~StoreContract_InnerContract();
  
  StoreContract_InnerContract(const StoreContract_InnerContract& from);
  
  inline StoreContract_InnerContract& operator=(const StoreContract_InnerContract& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StoreContract_InnerContract& default_instance();
  void Swap(StoreContract_InnerContract* other);
  
  // implements Message ----------------------------------------------
  
  StoreContract_InnerContract* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StoreContract_InnerContract& from);
  void MergeFrom(const StoreContract_InnerContract& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);
  
  // required .maidsafe.SignedSize signed_size = 2;
  inline bool has_signed_size() const;
  inline void clear_signed_size();
  static const int kSignedSizeFieldNumber = 2;
  inline const ::maidsafe::SignedSize& signed_size() const;
  inline ::maidsafe::SignedSize* mutable_signed_size();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 result_;
  ::maidsafe::SignedSize* signed_size_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static StoreContract_InnerContract* default_instance_;
};
// -------------------------------------------------------------------

class StoreContract : public ::google::protobuf::Message {
 public:
  StoreContract();
  virtual ~StoreContract();
  
  StoreContract(const StoreContract& from);
  
  inline StoreContract& operator=(const StoreContract& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StoreContract& default_instance();
  void Swap(StoreContract* other);
  
  // implements Message ----------------------------------------------
  
  StoreContract* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StoreContract& from);
  void MergeFrom(const StoreContract& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  typedef StoreContract_InnerContract InnerContract;
  
  // accessors -------------------------------------------------------
  
  // required .maidsafe.StoreContract.InnerContract inner_contract = 1;
  inline bool has_inner_contract() const;
  inline void clear_inner_contract();
  static const int kInnerContractFieldNumber = 1;
  inline const ::maidsafe::StoreContract_InnerContract& inner_contract() const;
  inline ::maidsafe::StoreContract_InnerContract* mutable_inner_contract();
  
  // required bytes signature = 2;
  inline bool has_signature() const;
  inline void clear_signature();
  static const int kSignatureFieldNumber = 2;
  inline const ::std::string& signature() const;
  inline void set_signature(const ::std::string& value);
  inline void set_signature(const char* value);
  inline void set_signature(const void* value, size_t size);
  inline ::std::string* mutable_signature();
  
  // required bytes pmid = 3;
  inline bool has_pmid() const;
  inline void clear_pmid();
  static const int kPmidFieldNumber = 3;
  inline const ::std::string& pmid() const;
  inline void set_pmid(const ::std::string& value);
  inline void set_pmid(const char* value);
  inline void set_pmid(const void* value, size_t size);
  inline ::std::string* mutable_pmid();
  
  // required bytes public_key = 4;
  inline bool has_public_key() const;
  inline void clear_public_key();
  static const int kPublicKeyFieldNumber = 4;
  inline const ::std::string& public_key() const;
  inline void set_public_key(const ::std::string& value);
  inline void set_public_key(const char* value);
  inline void set_public_key(const void* value, size_t size);
  inline ::std::string* mutable_public_key();
  
  // required bytes public_key_signature = 5;
  inline bool has_public_key_signature() const;
  inline void clear_public_key_signature();
  static const int kPublicKeySignatureFieldNumber = 5;
  inline const ::std::string& public_key_signature() const;
  inline void set_public_key_signature(const ::std::string& value);
  inline void set_public_key_signature(const char* value);
  inline void set_public_key_signature(const void* value, size_t size);
  inline ::std::string* mutable_public_key_signature();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::maidsafe::StoreContract_InnerContract* inner_contract_;
  ::std::string* signature_;
  static const ::std::string _default_signature_;
  ::std::string* pmid_;
  static const ::std::string _default_pmid_;
  ::std::string* public_key_;
  static const ::std::string _default_public_key_;
  ::std::string* public_key_signature_;
  static const ::std::string _default_public_key_signature_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static StoreContract* default_instance_;
};
// -------------------------------------------------------------------

class StorePrepRequest : public ::google::protobuf::Message {
 public:
  StorePrepRequest();
  virtual ~StorePrepRequest();
  
  StorePrepRequest(const StorePrepRequest& from);
  
  inline StorePrepRequest& operator=(const StorePrepRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StorePrepRequest& default_instance();
  void Swap(StorePrepRequest* other);
  
  // implements Message ----------------------------------------------
  
  StorePrepRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StorePrepRequest& from);
  void MergeFrom(const StorePrepRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes chunkname = 1;
  inline bool has_chunkname() const;
  inline void clear_chunkname();
  static const int kChunknameFieldNumber = 1;
  inline const ::std::string& chunkname() const;
  inline void set_chunkname(const ::std::string& value);
  inline void set_chunkname(const char* value);
  inline void set_chunkname(const void* value, size_t size);
  inline ::std::string* mutable_chunkname();
  
  // required .maidsafe.SignedSize signed_size = 2;
  inline bool has_signed_size() const;
  inline void clear_signed_size();
  static const int kSignedSizeFieldNumber = 2;
  inline const ::maidsafe::SignedSize& signed_size() const;
  inline ::maidsafe::SignedSize* mutable_signed_size();
  
  // required bytes request_signature = 3;
  inline bool has_request_signature() const;
  inline void clear_request_signature();
  static const int kRequestSignatureFieldNumber = 3;
  inline const ::std::string& request_signature() const;
  inline void set_request_signature(const ::std::string& value);
  inline void set_request_signature(const char* value);
  inline void set_request_signature(const void* value, size_t size);
  inline ::std::string* mutable_request_signature();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* chunkname_;
  static const ::std::string _default_chunkname_;
  ::maidsafe::SignedSize* signed_size_;
  ::std::string* request_signature_;
  static const ::std::string _default_request_signature_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static StorePrepRequest* default_instance_;
};
// -------------------------------------------------------------------

class StorePrepResponse : public ::google::protobuf::Message {
 public:
  StorePrepResponse();
  virtual ~StorePrepResponse();
  
  StorePrepResponse(const StorePrepResponse& from);
  
  inline StorePrepResponse& operator=(const StorePrepResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StorePrepResponse& default_instance();
  void Swap(StorePrepResponse* other);
  
  // implements Message ----------------------------------------------
  
  StorePrepResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StorePrepResponse& from);
  void MergeFrom(const StorePrepResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .maidsafe.StoreContract store_contract = 1;
  inline bool has_store_contract() const;
  inline void clear_store_contract();
  static const int kStoreContractFieldNumber = 1;
  inline const ::maidsafe::StoreContract& store_contract() const;
  inline ::maidsafe::StoreContract* mutable_store_contract();
  
  // required bytes response_signature = 2;
  inline bool has_response_signature() const;
  inline void clear_response_signature();
  static const int kResponseSignatureFieldNumber = 2;
  inline const ::std::string& response_signature() const;
  inline void set_response_signature(const ::std::string& value);
  inline void set_response_signature(const char* value);
  inline void set_response_signature(const void* value, size_t size);
  inline ::std::string* mutable_response_signature();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::maidsafe::StoreContract* store_contract_;
  ::std::string* response_signature_;
  static const ::std::string _default_response_signature_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static StorePrepResponse* default_instance_;
};
// -------------------------------------------------------------------

class StoreChunkRequest : public ::google::protobuf::Message {
 public:
  StoreChunkRequest();
  virtual ~StoreChunkRequest();
  
  StoreChunkRequest(const StoreChunkRequest& from);
  
  inline StoreChunkRequest& operator=(const StoreChunkRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StoreChunkRequest& default_instance();
  void Swap(StoreChunkRequest* other);
  
  // implements Message ----------------------------------------------
  
  StoreChunkRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StoreChunkRequest& from);
  void MergeFrom(const StoreChunkRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes chunkname = 1;
  inline bool has_chunkname() const;
  inline void clear_chunkname();
  static const int kChunknameFieldNumber = 1;
  inline const ::std::string& chunkname() const;
  inline void set_chunkname(const ::std::string& value);
  inline void set_chunkname(const char* value);
  inline void set_chunkname(const void* value, size_t size);
  inline ::std::string* mutable_chunkname();
  
  // required bytes data = 2;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  
  // required bytes pmid = 3;
  inline bool has_pmid() const;
  inline void clear_pmid();
  static const int kPmidFieldNumber = 3;
  inline const ::std::string& pmid() const;
  inline void set_pmid(const ::std::string& value);
  inline void set_pmid(const char* value);
  inline void set_pmid(const void* value, size_t size);
  inline ::std::string* mutable_pmid();
  
  // required bytes public_key = 4;
  inline bool has_public_key() const;
  inline void clear_public_key();
  static const int kPublicKeyFieldNumber = 4;
  inline const ::std::string& public_key() const;
  inline void set_public_key(const ::std::string& value);
  inline void set_public_key(const char* value);
  inline void set_public_key(const void* value, size_t size);
  inline ::std::string* mutable_public_key();
  
  // required bytes public_key_signature = 5;
  inline bool has_public_key_signature() const;
  inline void clear_public_key_signature();
  static const int kPublicKeySignatureFieldNumber = 5;
  inline const ::std::string& public_key_signature() const;
  inline void set_public_key_signature(const ::std::string& value);
  inline void set_public_key_signature(const char* value);
  inline void set_public_key_signature(const void* value, size_t size);
  inline ::std::string* mutable_public_key_signature();
  
  // required bytes request_signature = 6;
  inline bool has_request_signature() const;
  inline void clear_request_signature();
  static const int kRequestSignatureFieldNumber = 6;
  inline const ::std::string& request_signature() const;
  inline void set_request_signature(const ::std::string& value);
  inline void set_request_signature(const char* value);
  inline void set_request_signature(const void* value, size_t size);
  inline ::std::string* mutable_request_signature();
  
  // required int32 data_type = 7;
  inline bool has_data_type() const;
  inline void clear_data_type();
  static const int kDataTypeFieldNumber = 7;
  inline ::google::protobuf::int32 data_type() const;
  inline void set_data_type(::google::protobuf::int32 value);
  
  // optional uint32 offset = 8;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 8;
  inline ::google::protobuf::uint32 offset() const;
  inline void set_offset(::google::protobuf::uint32 value);
  
  // optional uint32 chunklet_size = 9;
  inline bool has_chunklet_size() const;
  inline void clear_chunklet_size();
  static const int kChunkletSizeFieldNumber = 9;
  inline ::google::protobuf::uint32 chunklet_size() const;
  inline void set_chunklet_size(::google::protobuf::uint32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* chunkname_;
  static const ::std::string _default_chunkname_;
  ::std::string* data_;
  static const ::std::string _default_data_;
  ::std::string* pmid_;
  static const ::std::string _default_pmid_;
  ::std::string* public_key_;
  static const ::std::string _default_public_key_;
  ::std::string* public_key_signature_;
  static const ::std::string _default_public_key_signature_;
  ::std::string* request_signature_;
  static const ::std::string _default_request_signature_;
  ::google::protobuf::int32 data_type_;
  ::google::protobuf::uint32 offset_;
  ::google::protobuf::uint32 chunklet_size_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static StoreChunkRequest* default_instance_;
};
// -------------------------------------------------------------------

class StoreChunkResponse : public ::google::protobuf::Message {
 public:
  StoreChunkResponse();
  virtual ~StoreChunkResponse();
  
  StoreChunkResponse(const StoreChunkResponse& from);
  
  inline StoreChunkResponse& operator=(const StoreChunkResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StoreChunkResponse& default_instance();
  void Swap(StoreChunkResponse* other);
  
  // implements Message ----------------------------------------------
  
  StoreChunkResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StoreChunkResponse& from);
  void MergeFrom(const StoreChunkResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);
  
  // optional bytes pmid = 2;
  inline bool has_pmid() const;
  inline void clear_pmid();
  static const int kPmidFieldNumber = 2;
  inline const ::std::string& pmid() const;
  inline void set_pmid(const ::std::string& value);
  inline void set_pmid(const char* value);
  inline void set_pmid(const void* value, size_t size);
  inline ::std::string* mutable_pmid();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 result_;
  ::std::string* pmid_;
  static const ::std::string _default_pmid_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static StoreChunkResponse* default_instance_;
};
// -------------------------------------------------------------------

class StorePacketRequest : public ::google::protobuf::Message {
 public:
  StorePacketRequest();
  virtual ~StorePacketRequest();
  
  StorePacketRequest(const StorePacketRequest& from);
  
  inline StorePacketRequest& operator=(const StorePacketRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StorePacketRequest& default_instance();
  void Swap(StorePacketRequest* other);
  
  // implements Message ----------------------------------------------
  
  StorePacketRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StorePacketRequest& from);
  void MergeFrom(const StorePacketRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes packetname = 1;
  inline bool has_packetname() const;
  inline void clear_packetname();
  static const int kPacketnameFieldNumber = 1;
  inline const ::std::string& packetname() const;
  inline void set_packetname(const ::std::string& value);
  inline void set_packetname(const char* value);
  inline void set_packetname(const void* value, size_t size);
  inline ::std::string* mutable_packetname();
  
  // repeated .maidsafe.GenericPacket signed_data = 2;
  inline int signed_data_size() const;
  inline void clear_signed_data();
  static const int kSignedDataFieldNumber = 2;
  inline const ::google::protobuf::RepeatedPtrField< ::maidsafe::GenericPacket >& signed_data() const;
  inline ::google::protobuf::RepeatedPtrField< ::maidsafe::GenericPacket >* mutable_signed_data();
  inline const ::maidsafe::GenericPacket& signed_data(int index) const;
  inline ::maidsafe::GenericPacket* mutable_signed_data(int index);
  inline ::maidsafe::GenericPacket* add_signed_data();
  
  // optional bytes key_id = 3;
  inline bool has_key_id() const;
  inline void clear_key_id();
  static const int kKeyIdFieldNumber = 3;
  inline const ::std::string& key_id() const;
  inline void set_key_id(const ::std::string& value);
  inline void set_key_id(const char* value);
  inline void set_key_id(const void* value, size_t size);
  inline ::std::string* mutable_key_id();
  
  // optional bytes public_key = 4;
  inline bool has_public_key() const;
  inline void clear_public_key();
  static const int kPublicKeyFieldNumber = 4;
  inline const ::std::string& public_key() const;
  inline void set_public_key(const ::std::string& value);
  inline void set_public_key(const char* value);
  inline void set_public_key(const void* value, size_t size);
  inline ::std::string* mutable_public_key();
  
  // optional bytes public_key_signature = 5;
  inline bool has_public_key_signature() const;
  inline void clear_public_key_signature();
  static const int kPublicKeySignatureFieldNumber = 5;
  inline const ::std::string& public_key_signature() const;
  inline void set_public_key_signature(const ::std::string& value);
  inline void set_public_key_signature(const char* value);
  inline void set_public_key_signature(const void* value, size_t size);
  inline ::std::string* mutable_public_key_signature();
  
  // optional bytes request_signature = 6;
  inline bool has_request_signature() const;
  inline void clear_request_signature();
  static const int kRequestSignatureFieldNumber = 6;
  inline const ::std::string& request_signature() const;
  inline void set_request_signature(const ::std::string& value);
  inline void set_request_signature(const char* value);
  inline void set_request_signature(const void* value, size_t size);
  inline ::std::string* mutable_request_signature();
  
  // required int32 data_type = 7;
  inline bool has_data_type() const;
  inline void clear_data_type();
  static const int kDataTypeFieldNumber = 7;
  inline ::google::protobuf::int32 data_type() const;
  inline void set_data_type(::google::protobuf::int32 value);
  
  // required bool append = 8;
  inline bool has_append() const;
  inline void clear_append();
  static const int kAppendFieldNumber = 8;
  inline bool append() const;
  inline void set_append(bool value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* packetname_;
  static const ::std::string _default_packetname_;
  ::google::protobuf::RepeatedPtrField< ::maidsafe::GenericPacket > signed_data_;
  ::std::string* key_id_;
  static const ::std::string _default_key_id_;
  ::std::string* public_key_;
  static const ::std::string _default_public_key_;
  ::std::string* public_key_signature_;
  static const ::std::string _default_public_key_signature_;
  ::std::string* request_signature_;
  static const ::std::string _default_request_signature_;
  ::google::protobuf::int32 data_type_;
  bool append_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static StorePacketRequest* default_instance_;
};
// -------------------------------------------------------------------

class StorePacketResponse : public ::google::protobuf::Message {
 public:
  StorePacketResponse();
  virtual ~StorePacketResponse();
  
  StorePacketResponse(const StorePacketResponse& from);
  
  inline StorePacketResponse& operator=(const StorePacketResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StorePacketResponse& default_instance();
  void Swap(StorePacketResponse* other);
  
  // implements Message ----------------------------------------------
  
  StorePacketResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StorePacketResponse& from);
  void MergeFrom(const StorePacketResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);
  
  // optional bytes pmid = 2;
  inline bool has_pmid() const;
  inline void clear_pmid();
  static const int kPmidFieldNumber = 2;
  inline const ::std::string& pmid() const;
  inline void set_pmid(const ::std::string& value);
  inline void set_pmid(const char* value);
  inline void set_pmid(const void* value, size_t size);
  inline ::std::string* mutable_pmid();
  
  // optional bytes public_key = 3;
  inline bool has_public_key() const;
  inline void clear_public_key();
  static const int kPublicKeyFieldNumber = 3;
  inline const ::std::string& public_key() const;
  inline void set_public_key(const ::std::string& value);
  inline void set_public_key(const char* value);
  inline void set_public_key(const void* value, size_t size);
  inline ::std::string* mutable_public_key();
  
  // optional bytes public_key_signature = 4;
  inline bool has_public_key_signature() const;
  inline void clear_public_key_signature();
  static const int kPublicKeySignatureFieldNumber = 4;
  inline const ::std::string& public_key_signature() const;
  inline void set_public_key_signature(const ::std::string& value);
  inline void set_public_key_signature(const char* value);
  inline void set_public_key_signature(const void* value, size_t size);
  inline ::std::string* mutable_public_key_signature();
  
  // optional bytes response_signature = 5;
  inline bool has_response_signature() const;
  inline void clear_response_signature();
  static const int kResponseSignatureFieldNumber = 5;
  inline const ::std::string& response_signature() const;
  inline void set_response_signature(const ::std::string& value);
  inline void set_response_signature(const char* value);
  inline void set_response_signature(const void* value, size_t size);
  inline ::std::string* mutable_response_signature();
  
  // optional bytes checksum = 6;
  inline bool has_checksum() const;
  inline void clear_checksum();
  static const int kChecksumFieldNumber = 6;
  inline const ::std::string& checksum() const;
  inline void set_checksum(const ::std::string& value);
  inline void set_checksum(const char* value);
  inline void set_checksum(const void* value, size_t size);
  inline ::std::string* mutable_checksum();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 result_;
  ::std::string* pmid_;
  static const ::std::string _default_pmid_;
  ::std::string* public_key_;
  static const ::std::string _default_public_key_;
  ::std::string* public_key_signature_;
  static const ::std::string _default_public_key_signature_;
  ::std::string* response_signature_;
  static const ::std::string _default_response_signature_;
  ::std::string* checksum_;
  static const ::std::string _default_checksum_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static StorePacketResponse* default_instance_;
};
// -------------------------------------------------------------------

class AddToWatchListRequest : public ::google::protobuf::Message {
 public:
  AddToWatchListRequest();
  virtual ~AddToWatchListRequest();
  
  AddToWatchListRequest(const AddToWatchListRequest& from);
  
  inline AddToWatchListRequest& operator=(const AddToWatchListRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AddToWatchListRequest& default_instance();
  void Swap(AddToWatchListRequest* other);
  
  // implements Message ----------------------------------------------
  
  AddToWatchListRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AddToWatchListRequest& from);
  void MergeFrom(const AddToWatchListRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes chunkname = 1;
  inline bool has_chunkname() const;
  inline void clear_chunkname();
  static const int kChunknameFieldNumber = 1;
  inline const ::std::string& chunkname() const;
  inline void set_chunkname(const ::std::string& value);
  inline void set_chunkname(const char* value);
  inline void set_chunkname(const void* value, size_t size);
  inline ::std::string* mutable_chunkname();
  
  // required .maidsafe.SignedSize signed_size = 2;
  inline bool has_signed_size() const;
  inline void clear_signed_size();
  static const int kSignedSizeFieldNumber = 2;
  inline const ::maidsafe::SignedSize& signed_size() const;
  inline ::maidsafe::SignedSize* mutable_signed_size();
  
  // required bytes request_signature = 4;
  inline bool has_request_signature() const;
  inline void clear_request_signature();
  static const int kRequestSignatureFieldNumber = 4;
  inline const ::std::string& request_signature() const;
  inline void set_request_signature(const ::std::string& value);
  inline void set_request_signature(const char* value);
  inline void set_request_signature(const void* value, size_t size);
  inline ::std::string* mutable_request_signature();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* chunkname_;
  static const ::std::string _default_chunkname_;
  ::maidsafe::SignedSize* signed_size_;
  ::std::string* request_signature_;
  static const ::std::string _default_request_signature_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static AddToWatchListRequest* default_instance_;
};
// -------------------------------------------------------------------

class AddToWatchListResponse : public ::google::protobuf::Message {
 public:
  AddToWatchListResponse();
  virtual ~AddToWatchListResponse();
  
  AddToWatchListResponse(const AddToWatchListResponse& from);
  
  inline AddToWatchListResponse& operator=(const AddToWatchListResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AddToWatchListResponse& default_instance();
  void Swap(AddToWatchListResponse* other);
  
  // implements Message ----------------------------------------------
  
  AddToWatchListResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AddToWatchListResponse& from);
  void MergeFrom(const AddToWatchListResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);
  
  // optional bytes pmid = 2;
  inline bool has_pmid() const;
  inline void clear_pmid();
  static const int kPmidFieldNumber = 2;
  inline const ::std::string& pmid() const;
  inline void set_pmid(const ::std::string& value);
  inline void set_pmid(const char* value);
  inline void set_pmid(const void* value, size_t size);
  inline ::std::string* mutable_pmid();
  
  // optional uint32 upload_count = 3;
  inline bool has_upload_count() const;
  inline void clear_upload_count();
  static const int kUploadCountFieldNumber = 3;
  inline ::google::protobuf::uint32 upload_count() const;
  inline void set_upload_count(::google::protobuf::uint32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 result_;
  ::std::string* pmid_;
  static const ::std::string _default_pmid_;
  ::google::protobuf::uint32 upload_count_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static AddToWatchListResponse* default_instance_;
};
// -------------------------------------------------------------------

class RemoveFromWatchListRequest : public ::google::protobuf::Message {
 public:
  RemoveFromWatchListRequest();
  virtual ~RemoveFromWatchListRequest();
  
  RemoveFromWatchListRequest(const RemoveFromWatchListRequest& from);
  
  inline RemoveFromWatchListRequest& operator=(const RemoveFromWatchListRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RemoveFromWatchListRequest& default_instance();
  void Swap(RemoveFromWatchListRequest* other);
  
  // implements Message ----------------------------------------------
  
  RemoveFromWatchListRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RemoveFromWatchListRequest& from);
  void MergeFrom(const RemoveFromWatchListRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes chunkname = 1;
  inline bool has_chunkname() const;
  inline void clear_chunkname();
  static const int kChunknameFieldNumber = 1;
  inline const ::std::string& chunkname() const;
  inline void set_chunkname(const ::std::string& value);
  inline void set_chunkname(const char* value);
  inline void set_chunkname(const void* value, size_t size);
  inline ::std::string* mutable_chunkname();
  
  // required bytes pmid = 2;
  inline bool has_pmid() const;
  inline void clear_pmid();
  static const int kPmidFieldNumber = 2;
  inline const ::std::string& pmid() const;
  inline void set_pmid(const ::std::string& value);
  inline void set_pmid(const char* value);
  inline void set_pmid(const void* value, size_t size);
  inline ::std::string* mutable_pmid();
  
  // required bytes public_key = 3;
  inline bool has_public_key() const;
  inline void clear_public_key();
  static const int kPublicKeyFieldNumber = 3;
  inline const ::std::string& public_key() const;
  inline void set_public_key(const ::std::string& value);
  inline void set_public_key(const char* value);
  inline void set_public_key(const void* value, size_t size);
  inline ::std::string* mutable_public_key();
  
  // required bytes public_key_signature = 4;
  inline bool has_public_key_signature() const;
  inline void clear_public_key_signature();
  static const int kPublicKeySignatureFieldNumber = 4;
  inline const ::std::string& public_key_signature() const;
  inline void set_public_key_signature(const ::std::string& value);
  inline void set_public_key_signature(const char* value);
  inline void set_public_key_signature(const void* value, size_t size);
  inline ::std::string* mutable_public_key_signature();
  
  // required bytes request_signature = 5;
  inline bool has_request_signature() const;
  inline void clear_request_signature();
  static const int kRequestSignatureFieldNumber = 5;
  inline const ::std::string& request_signature() const;
  inline void set_request_signature(const ::std::string& value);
  inline void set_request_signature(const char* value);
  inline void set_request_signature(const void* value, size_t size);
  inline ::std::string* mutable_request_signature();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* chunkname_;
  static const ::std::string _default_chunkname_;
  ::std::string* pmid_;
  static const ::std::string _default_pmid_;
  ::std::string* public_key_;
  static const ::std::string _default_public_key_;
  ::std::string* public_key_signature_;
  static const ::std::string _default_public_key_signature_;
  ::std::string* request_signature_;
  static const ::std::string _default_request_signature_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static RemoveFromWatchListRequest* default_instance_;
};
// -------------------------------------------------------------------

class RemoveFromWatchListResponse : public ::google::protobuf::Message {
 public:
  RemoveFromWatchListResponse();
  virtual ~RemoveFromWatchListResponse();
  
  RemoveFromWatchListResponse(const RemoveFromWatchListResponse& from);
  
  inline RemoveFromWatchListResponse& operator=(const RemoveFromWatchListResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RemoveFromWatchListResponse& default_instance();
  void Swap(RemoveFromWatchListResponse* other);
  
  // implements Message ----------------------------------------------
  
  RemoveFromWatchListResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RemoveFromWatchListResponse& from);
  void MergeFrom(const RemoveFromWatchListResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);
  
  // optional bytes pmid = 2;
  inline bool has_pmid() const;
  inline void clear_pmid();
  static const int kPmidFieldNumber = 2;
  inline const ::std::string& pmid() const;
  inline void set_pmid(const ::std::string& value);
  inline void set_pmid(const char* value);
  inline void set_pmid(const void* value, size_t size);
  inline ::std::string* mutable_pmid();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 result_;
  ::std::string* pmid_;
  static const ::std::string _default_pmid_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static RemoveFromWatchListResponse* default_instance_;
};
// -------------------------------------------------------------------

class AddToReferenceListRequest : public ::google::protobuf::Message {
 public:
  AddToReferenceListRequest();
  virtual ~AddToReferenceListRequest();
  
  AddToReferenceListRequest(const AddToReferenceListRequest& from);
  
  inline AddToReferenceListRequest& operator=(const AddToReferenceListRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AddToReferenceListRequest& default_instance();
  void Swap(AddToReferenceListRequest* other);
  
  // implements Message ----------------------------------------------
  
  AddToReferenceListRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AddToReferenceListRequest& from);
  void MergeFrom(const AddToReferenceListRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes chunkname = 1;
  inline bool has_chunkname() const;
  inline void clear_chunkname();
  static const int kChunknameFieldNumber = 1;
  inline const ::std::string& chunkname() const;
  inline void set_chunkname(const ::std::string& value);
  inline void set_chunkname(const char* value);
  inline void set_chunkname(const void* value, size_t size);
  inline ::std::string* mutable_chunkname();
  
  // required .maidsafe.StoreContract store_contract = 2;
  inline bool has_store_contract() const;
  inline void clear_store_contract();
  static const int kStoreContractFieldNumber = 2;
  inline const ::maidsafe::StoreContract& store_contract() const;
  inline ::maidsafe::StoreContract* mutable_store_contract();
  
  // required bytes request_signature = 3;
  inline bool has_request_signature() const;
  inline void clear_request_signature();
  static const int kRequestSignatureFieldNumber = 3;
  inline const ::std::string& request_signature() const;
  inline void set_request_signature(const ::std::string& value);
  inline void set_request_signature(const char* value);
  inline void set_request_signature(const void* value, size_t size);
  inline ::std::string* mutable_request_signature();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* chunkname_;
  static const ::std::string _default_chunkname_;
  ::maidsafe::StoreContract* store_contract_;
  ::std::string* request_signature_;
  static const ::std::string _default_request_signature_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static AddToReferenceListRequest* default_instance_;
};
// -------------------------------------------------------------------

class AddToReferenceListResponse : public ::google::protobuf::Message {
 public:
  AddToReferenceListResponse();
  virtual ~AddToReferenceListResponse();
  
  AddToReferenceListResponse(const AddToReferenceListResponse& from);
  
  inline AddToReferenceListResponse& operator=(const AddToReferenceListResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AddToReferenceListResponse& default_instance();
  void Swap(AddToReferenceListResponse* other);
  
  // implements Message ----------------------------------------------
  
  AddToReferenceListResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AddToReferenceListResponse& from);
  void MergeFrom(const AddToReferenceListResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);
  
  // optional bytes pmid = 2;
  inline bool has_pmid() const;
  inline void clear_pmid();
  static const int kPmidFieldNumber = 2;
  inline const ::std::string& pmid() const;
  inline void set_pmid(const ::std::string& value);
  inline void set_pmid(const char* value);
  inline void set_pmid(const void* value, size_t size);
  inline ::std::string* mutable_pmid();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 result_;
  ::std::string* pmid_;
  static const ::std::string _default_pmid_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static AddToReferenceListResponse* default_instance_;
};
// -------------------------------------------------------------------

class RemoveFromReferenceListRequest : public ::google::protobuf::Message {
 public:
  RemoveFromReferenceListRequest();
  virtual ~RemoveFromReferenceListRequest();
  
  RemoveFromReferenceListRequest(const RemoveFromReferenceListRequest& from);
  
  inline RemoveFromReferenceListRequest& operator=(const RemoveFromReferenceListRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RemoveFromReferenceListRequest& default_instance();
  void Swap(RemoveFromReferenceListRequest* other);
  
  // implements Message ----------------------------------------------
  
  RemoveFromReferenceListRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RemoveFromReferenceListRequest& from);
  void MergeFrom(const RemoveFromReferenceListRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes chunkname = 1;
  inline bool has_chunkname() const;
  inline void clear_chunkname();
  static const int kChunknameFieldNumber = 1;
  inline const ::std::string& chunkname() const;
  inline void set_chunkname(const ::std::string& value);
  inline void set_chunkname(const char* value);
  inline void set_chunkname(const void* value, size_t size);
  inline ::std::string* mutable_chunkname();
  
  // required bytes pmid = 2;
  inline bool has_pmid() const;
  inline void clear_pmid();
  static const int kPmidFieldNumber = 2;
  inline const ::std::string& pmid() const;
  inline void set_pmid(const ::std::string& value);
  inline void set_pmid(const char* value);
  inline void set_pmid(const void* value, size_t size);
  inline ::std::string* mutable_pmid();
  
  // required bytes public_key = 3;
  inline bool has_public_key() const;
  inline void clear_public_key();
  static const int kPublicKeyFieldNumber = 3;
  inline const ::std::string& public_key() const;
  inline void set_public_key(const ::std::string& value);
  inline void set_public_key(const char* value);
  inline void set_public_key(const void* value, size_t size);
  inline ::std::string* mutable_public_key();
  
  // required bytes public_key_signature = 4;
  inline bool has_public_key_signature() const;
  inline void clear_public_key_signature();
  static const int kPublicKeySignatureFieldNumber = 4;
  inline const ::std::string& public_key_signature() const;
  inline void set_public_key_signature(const ::std::string& value);
  inline void set_public_key_signature(const char* value);
  inline void set_public_key_signature(const void* value, size_t size);
  inline ::std::string* mutable_public_key_signature();
  
  // required bytes request_signature = 5;
  inline bool has_request_signature() const;
  inline void clear_request_signature();
  static const int kRequestSignatureFieldNumber = 5;
  inline const ::std::string& request_signature() const;
  inline void set_request_signature(const ::std::string& value);
  inline void set_request_signature(const char* value);
  inline void set_request_signature(const void* value, size_t size);
  inline ::std::string* mutable_request_signature();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* chunkname_;
  static const ::std::string _default_chunkname_;
  ::std::string* pmid_;
  static const ::std::string _default_pmid_;
  ::std::string* public_key_;
  static const ::std::string _default_public_key_;
  ::std::string* public_key_signature_;
  static const ::std::string _default_public_key_signature_;
  ::std::string* request_signature_;
  static const ::std::string _default_request_signature_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static RemoveFromReferenceListRequest* default_instance_;
};
// -------------------------------------------------------------------

class RemoveFromReferenceListResponse : public ::google::protobuf::Message {
 public:
  RemoveFromReferenceListResponse();
  virtual ~RemoveFromReferenceListResponse();
  
  RemoveFromReferenceListResponse(const RemoveFromReferenceListResponse& from);
  
  inline RemoveFromReferenceListResponse& operator=(const RemoveFromReferenceListResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RemoveFromReferenceListResponse& default_instance();
  void Swap(RemoveFromReferenceListResponse* other);
  
  // implements Message ----------------------------------------------
  
  RemoveFromReferenceListResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RemoveFromReferenceListResponse& from);
  void MergeFrom(const RemoveFromReferenceListResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);
  
  // optional bytes pmid = 2;
  inline bool has_pmid() const;
  inline void clear_pmid();
  static const int kPmidFieldNumber = 2;
  inline const ::std::string& pmid() const;
  inline void set_pmid(const ::std::string& value);
  inline void set_pmid(const char* value);
  inline void set_pmid(const void* value, size_t size);
  inline ::std::string* mutable_pmid();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 result_;
  ::std::string* pmid_;
  static const ::std::string _default_pmid_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static RemoveFromReferenceListResponse* default_instance_;
};
// -------------------------------------------------------------------

class AmendAccountRequest : public ::google::protobuf::Message {
 public:
  AmendAccountRequest();
  virtual ~AmendAccountRequest();
  
  AmendAccountRequest(const AmendAccountRequest& from);
  
  inline AmendAccountRequest& operator=(const AmendAccountRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AmendAccountRequest& default_instance();
  void Swap(AmendAccountRequest* other);
  
  // implements Message ----------------------------------------------
  
  AmendAccountRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AmendAccountRequest& from);
  void MergeFrom(const AmendAccountRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  typedef AmendAccountRequest_Amendment Amendment;
  static const Amendment kSpaceOffered = AmendAccountRequest_Amendment_kSpaceOffered;
  static const Amendment kSpaceGivenInc = AmendAccountRequest_Amendment_kSpaceGivenInc;
  static const Amendment kSpaceGivenDec = AmendAccountRequest_Amendment_kSpaceGivenDec;
  static const Amendment kSpaceTakenInc = AmendAccountRequest_Amendment_kSpaceTakenInc;
  static const Amendment kSpaceTakenDec = AmendAccountRequest_Amendment_kSpaceTakenDec;
  static inline const ::google::protobuf::EnumDescriptor*
  Amendment_descriptor() {
    return AmendAccountRequest_Amendment_descriptor();
  }
  static inline bool Amendment_IsValid(int value) {
    return AmendAccountRequest_Amendment_IsValid(value);
  }
  static inline const ::std::string& Amendment_Name(Amendment value) {
    return AmendAccountRequest_Amendment_Name(value);
  }
  static inline bool Amendment_Parse(const ::std::string& name,
      Amendment* value) {
    return AmendAccountRequest_Amendment_Parse(name, value);
  }
  static const Amendment Amendment_MIN =
    AmendAccountRequest_Amendment_Amendment_MIN;
  static const Amendment Amendment_MAX =
    AmendAccountRequest_Amendment_Amendment_MAX;
  
  // accessors -------------------------------------------------------
  
  // required .maidsafe.AmendAccountRequest.Amendment amendment_type = 1;
  inline bool has_amendment_type() const;
  inline void clear_amendment_type();
  static const int kAmendmentTypeFieldNumber = 1;
  inline ::maidsafe::AmendAccountRequest_Amendment amendment_type() const;
  inline void set_amendment_type(::maidsafe::AmendAccountRequest_Amendment value);
  
  // required bytes account_pmid = 2;
  inline bool has_account_pmid() const;
  inline void clear_account_pmid();
  static const int kAccountPmidFieldNumber = 2;
  inline const ::std::string& account_pmid() const;
  inline void set_account_pmid(const ::std::string& value);
  inline void set_account_pmid(const char* value);
  inline void set_account_pmid(const void* value, size_t size);
  inline ::std::string* mutable_account_pmid();
  
  // required .maidsafe.SignedSize signed_size = 3;
  inline bool has_signed_size() const;
  inline void clear_signed_size();
  static const int kSignedSizeFieldNumber = 3;
  inline const ::maidsafe::SignedSize& signed_size() const;
  inline ::maidsafe::SignedSize* mutable_signed_size();
  
  // optional bytes chunkname = 4;
  inline bool has_chunkname() const;
  inline void clear_chunkname();
  static const int kChunknameFieldNumber = 4;
  inline const ::std::string& chunkname() const;
  inline void set_chunkname(const ::std::string& value);
  inline void set_chunkname(const char* value);
  inline void set_chunkname(const void* value, size_t size);
  inline ::std::string* mutable_chunkname();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  int amendment_type_;
  ::std::string* account_pmid_;
  static const ::std::string _default_account_pmid_;
  ::maidsafe::SignedSize* signed_size_;
  ::std::string* chunkname_;
  static const ::std::string _default_chunkname_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static AmendAccountRequest* default_instance_;
};
// -------------------------------------------------------------------

class AmendAccountResponse : public ::google::protobuf::Message {
 public:
  AmendAccountResponse();
  virtual ~AmendAccountResponse();
  
  AmendAccountResponse(const AmendAccountResponse& from);
  
  inline AmendAccountResponse& operator=(const AmendAccountResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AmendAccountResponse& default_instance();
  void Swap(AmendAccountResponse* other);
  
  // implements Message ----------------------------------------------
  
  AmendAccountResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AmendAccountResponse& from);
  void MergeFrom(const AmendAccountResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);
  
  // optional bytes pmid = 2;
  inline bool has_pmid() const;
  inline void clear_pmid();
  static const int kPmidFieldNumber = 2;
  inline const ::std::string& pmid() const;
  inline void set_pmid(const ::std::string& value);
  inline void set_pmid(const char* value);
  inline void set_pmid(const void* value, size_t size);
  inline ::std::string* mutable_pmid();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 result_;
  ::std::string* pmid_;
  static const ::std::string _default_pmid_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static AmendAccountResponse* default_instance_;
};
// -------------------------------------------------------------------

class AccountStatusRequest : public ::google::protobuf::Message {
 public:
  AccountStatusRequest();
  virtual ~AccountStatusRequest();
  
  AccountStatusRequest(const AccountStatusRequest& from);
  
  inline AccountStatusRequest& operator=(const AccountStatusRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AccountStatusRequest& default_instance();
  void Swap(AccountStatusRequest* other);
  
  // implements Message ----------------------------------------------
  
  AccountStatusRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AccountStatusRequest& from);
  void MergeFrom(const AccountStatusRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes account_pmid = 1;
  inline bool has_account_pmid() const;
  inline void clear_account_pmid();
  static const int kAccountPmidFieldNumber = 1;
  inline const ::std::string& account_pmid() const;
  inline void set_account_pmid(const ::std::string& value);
  inline void set_account_pmid(const char* value);
  inline void set_account_pmid(const void* value, size_t size);
  inline ::std::string* mutable_account_pmid();
  
  // optional uint64 space_requested = 2;
  inline bool has_space_requested() const;
  inline void clear_space_requested();
  static const int kSpaceRequestedFieldNumber = 2;
  inline ::google::protobuf::uint64 space_requested() const;
  inline void set_space_requested(::google::protobuf::uint64 value);
  
  // optional bytes public_key = 3;
  inline bool has_public_key() const;
  inline void clear_public_key();
  static const int kPublicKeyFieldNumber = 3;
  inline const ::std::string& public_key() const;
  inline void set_public_key(const ::std::string& value);
  inline void set_public_key(const char* value);
  inline void set_public_key(const void* value, size_t size);
  inline ::std::string* mutable_public_key();
  
  // optional bytes public_key_signature = 4;
  inline bool has_public_key_signature() const;
  inline void clear_public_key_signature();
  static const int kPublicKeySignatureFieldNumber = 4;
  inline const ::std::string& public_key_signature() const;
  inline void set_public_key_signature(const ::std::string& value);
  inline void set_public_key_signature(const char* value);
  inline void set_public_key_signature(const void* value, size_t size);
  inline ::std::string* mutable_public_key_signature();
  
  // optional bytes request_signature = 5;
  inline bool has_request_signature() const;
  inline void clear_request_signature();
  static const int kRequestSignatureFieldNumber = 5;
  inline const ::std::string& request_signature() const;
  inline void set_request_signature(const ::std::string& value);
  inline void set_request_signature(const char* value);
  inline void set_request_signature(const void* value, size_t size);
  inline ::std::string* mutable_request_signature();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* account_pmid_;
  static const ::std::string _default_account_pmid_;
  ::google::protobuf::uint64 space_requested_;
  ::std::string* public_key_;
  static const ::std::string _default_public_key_;
  ::std::string* public_key_signature_;
  static const ::std::string _default_public_key_signature_;
  ::std::string* request_signature_;
  static const ::std::string _default_request_signature_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static AccountStatusRequest* default_instance_;
};
// -------------------------------------------------------------------

class AccountStatusResponse : public ::google::protobuf::Message {
 public:
  AccountStatusResponse();
  virtual ~AccountStatusResponse();
  
  AccountStatusResponse(const AccountStatusResponse& from);
  
  inline AccountStatusResponse& operator=(const AccountStatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AccountStatusResponse& default_instance();
  void Swap(AccountStatusResponse* other);
  
  // implements Message ----------------------------------------------
  
  AccountStatusResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AccountStatusResponse& from);
  void MergeFrom(const AccountStatusResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);
  
  // required bytes pmid = 2;
  inline bool has_pmid() const;
  inline void clear_pmid();
  static const int kPmidFieldNumber = 2;
  inline const ::std::string& pmid() const;
  inline void set_pmid(const ::std::string& value);
  inline void set_pmid(const char* value);
  inline void set_pmid(const void* value, size_t size);
  inline ::std::string* mutable_pmid();
  
  // optional uint64 space_offered = 3;
  inline bool has_space_offered() const;
  inline void clear_space_offered();
  static const int kSpaceOfferedFieldNumber = 3;
  inline ::google::protobuf::uint64 space_offered() const;
  inline void set_space_offered(::google::protobuf::uint64 value);
  
  // optional uint64 space_given = 4;
  inline bool has_space_given() const;
  inline void clear_space_given();
  static const int kSpaceGivenFieldNumber = 4;
  inline ::google::protobuf::uint64 space_given() const;
  inline void set_space_given(::google::protobuf::uint64 value);
  
  // optional uint64 space_taken = 5;
  inline bool has_space_taken() const;
  inline void clear_space_taken();
  static const int kSpaceTakenFieldNumber = 5;
  inline ::google::protobuf::uint64 space_taken() const;
  inline void set_space_taken(::google::protobuf::uint64 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 result_;
  ::std::string* pmid_;
  static const ::std::string _default_pmid_;
  ::google::protobuf::uint64 space_offered_;
  ::google::protobuf::uint64 space_given_;
  ::google::protobuf::uint64 space_taken_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static AccountStatusResponse* default_instance_;
};
// -------------------------------------------------------------------

class CheckChunkRequest : public ::google::protobuf::Message {
 public:
  CheckChunkRequest();
  virtual ~CheckChunkRequest();
  
  CheckChunkRequest(const CheckChunkRequest& from);
  
  inline CheckChunkRequest& operator=(const CheckChunkRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CheckChunkRequest& default_instance();
  void Swap(CheckChunkRequest* other);
  
  // implements Message ----------------------------------------------
  
  CheckChunkRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CheckChunkRequest& from);
  void MergeFrom(const CheckChunkRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes chunkname = 1;
  inline bool has_chunkname() const;
  inline void clear_chunkname();
  static const int kChunknameFieldNumber = 1;
  inline const ::std::string& chunkname() const;
  inline void set_chunkname(const ::std::string& value);
  inline void set_chunkname(const char* value);
  inline void set_chunkname(const void* value, size_t size);
  inline ::std::string* mutable_chunkname();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* chunkname_;
  static const ::std::string _default_chunkname_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static CheckChunkRequest* default_instance_;
};
// -------------------------------------------------------------------

class CheckChunkResponse : public ::google::protobuf::Message {
 public:
  CheckChunkResponse();
  virtual ~CheckChunkResponse();
  
  CheckChunkResponse(const CheckChunkResponse& from);
  
  inline CheckChunkResponse& operator=(const CheckChunkResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CheckChunkResponse& default_instance();
  void Swap(CheckChunkResponse* other);
  
  // implements Message ----------------------------------------------
  
  CheckChunkResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CheckChunkResponse& from);
  void MergeFrom(const CheckChunkResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);
  
  // required bytes pmid = 2;
  inline bool has_pmid() const;
  inline void clear_pmid();
  static const int kPmidFieldNumber = 2;
  inline const ::std::string& pmid() const;
  inline void set_pmid(const ::std::string& value);
  inline void set_pmid(const char* value);
  inline void set_pmid(const void* value, size_t size);
  inline ::std::string* mutable_pmid();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 result_;
  ::std::string* pmid_;
  static const ::std::string _default_pmid_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static CheckChunkResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetChunkRequest : public ::google::protobuf::Message {
 public:
  GetChunkRequest();
  virtual ~GetChunkRequest();
  
  GetChunkRequest(const GetChunkRequest& from);
  
  inline GetChunkRequest& operator=(const GetChunkRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetChunkRequest& default_instance();
  void Swap(GetChunkRequest* other);
  
  // implements Message ----------------------------------------------
  
  GetChunkRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetChunkRequest& from);
  void MergeFrom(const GetChunkRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes chunkname = 1;
  inline bool has_chunkname() const;
  inline void clear_chunkname();
  static const int kChunknameFieldNumber = 1;
  inline const ::std::string& chunkname() const;
  inline void set_chunkname(const ::std::string& value);
  inline void set_chunkname(const char* value);
  inline void set_chunkname(const void* value, size_t size);
  inline ::std::string* mutable_chunkname();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* chunkname_;
  static const ::std::string _default_chunkname_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static GetChunkRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetChunkResponse : public ::google::protobuf::Message {
 public:
  GetChunkResponse();
  virtual ~GetChunkResponse();
  
  GetChunkResponse(const GetChunkResponse& from);
  
  inline GetChunkResponse& operator=(const GetChunkResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetChunkResponse& default_instance();
  void Swap(GetChunkResponse* other);
  
  // implements Message ----------------------------------------------
  
  GetChunkResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetChunkResponse& from);
  void MergeFrom(const GetChunkResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);
  
  // optional bytes content = 2;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 2;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const void* value, size_t size);
  inline ::std::string* mutable_content();
  
  // optional bytes pmid = 3;
  inline bool has_pmid() const;
  inline void clear_pmid();
  static const int kPmidFieldNumber = 3;
  inline const ::std::string& pmid() const;
  inline void set_pmid(const ::std::string& value);
  inline void set_pmid(const char* value);
  inline void set_pmid(const void* value, size_t size);
  inline ::std::string* mutable_pmid();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 result_;
  ::std::string* content_;
  static const ::std::string _default_content_;
  ::std::string* pmid_;
  static const ::std::string _default_pmid_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static GetChunkResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetPacketRequest : public ::google::protobuf::Message {
 public:
  GetPacketRequest();
  virtual ~GetPacketRequest();
  
  GetPacketRequest(const GetPacketRequest& from);
  
  inline GetPacketRequest& operator=(const GetPacketRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetPacketRequest& default_instance();
  void Swap(GetPacketRequest* other);
  
  // implements Message ----------------------------------------------
  
  GetPacketRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetPacketRequest& from);
  void MergeFrom(const GetPacketRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes packetname = 1;
  inline bool has_packetname() const;
  inline void clear_packetname();
  static const int kPacketnameFieldNumber = 1;
  inline const ::std::string& packetname() const;
  inline void set_packetname(const ::std::string& value);
  inline void set_packetname(const char* value);
  inline void set_packetname(const void* value, size_t size);
  inline ::std::string* mutable_packetname();
  
  // optional bytes key_id = 2;
  inline bool has_key_id() const;
  inline void clear_key_id();
  static const int kKeyIdFieldNumber = 2;
  inline const ::std::string& key_id() const;
  inline void set_key_id(const ::std::string& value);
  inline void set_key_id(const char* value);
  inline void set_key_id(const void* value, size_t size);
  inline ::std::string* mutable_key_id();
  
  // optional bytes public_key = 3;
  inline bool has_public_key() const;
  inline void clear_public_key();
  static const int kPublicKeyFieldNumber = 3;
  inline const ::std::string& public_key() const;
  inline void set_public_key(const ::std::string& value);
  inline void set_public_key(const char* value);
  inline void set_public_key(const void* value, size_t size);
  inline ::std::string* mutable_public_key();
  
  // optional bytes public_key_signature = 4;
  inline bool has_public_key_signature() const;
  inline void clear_public_key_signature();
  static const int kPublicKeySignatureFieldNumber = 4;
  inline const ::std::string& public_key_signature() const;
  inline void set_public_key_signature(const ::std::string& value);
  inline void set_public_key_signature(const char* value);
  inline void set_public_key_signature(const void* value, size_t size);
  inline ::std::string* mutable_public_key_signature();
  
  // optional bytes request_signature = 5;
  inline bool has_request_signature() const;
  inline void clear_request_signature();
  static const int kRequestSignatureFieldNumber = 5;
  inline const ::std::string& request_signature() const;
  inline void set_request_signature(const ::std::string& value);
  inline void set_request_signature(const char* value);
  inline void set_request_signature(const void* value, size_t size);
  inline ::std::string* mutable_request_signature();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* packetname_;
  static const ::std::string _default_packetname_;
  ::std::string* key_id_;
  static const ::std::string _default_key_id_;
  ::std::string* public_key_;
  static const ::std::string _default_public_key_;
  ::std::string* public_key_signature_;
  static const ::std::string _default_public_key_signature_;
  ::std::string* request_signature_;
  static const ::std::string _default_request_signature_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static GetPacketRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetPacketResponse : public ::google::protobuf::Message {
 public:
  GetPacketResponse();
  virtual ~GetPacketResponse();
  
  GetPacketResponse(const GetPacketResponse& from);
  
  inline GetPacketResponse& operator=(const GetPacketResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetPacketResponse& default_instance();
  void Swap(GetPacketResponse* other);
  
  // implements Message ----------------------------------------------
  
  GetPacketResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetPacketResponse& from);
  void MergeFrom(const GetPacketResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);
  
  // repeated .maidsafe.GenericPacket content = 2;
  inline int content_size() const;
  inline void clear_content();
  static const int kContentFieldNumber = 2;
  inline const ::google::protobuf::RepeatedPtrField< ::maidsafe::GenericPacket >& content() const;
  inline ::google::protobuf::RepeatedPtrField< ::maidsafe::GenericPacket >* mutable_content();
  inline const ::maidsafe::GenericPacket& content(int index) const;
  inline ::maidsafe::GenericPacket* mutable_content(int index);
  inline ::maidsafe::GenericPacket* add_content();
  
  // optional bytes pmid = 3;
  inline bool has_pmid() const;
  inline void clear_pmid();
  static const int kPmidFieldNumber = 3;
  inline const ::std::string& pmid() const;
  inline void set_pmid(const ::std::string& value);
  inline void set_pmid(const char* value);
  inline void set_pmid(const void* value, size_t size);
  inline ::std::string* mutable_pmid();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 result_;
  ::google::protobuf::RepeatedPtrField< ::maidsafe::GenericPacket > content_;
  ::std::string* pmid_;
  static const ::std::string _default_pmid_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static GetPacketResponse* default_instance_;
};
// -------------------------------------------------------------------

class UpdateChunkRequest : public ::google::protobuf::Message {
 public:
  UpdateChunkRequest();
  virtual ~UpdateChunkRequest();
  
  UpdateChunkRequest(const UpdateChunkRequest& from);
  
  inline UpdateChunkRequest& operator=(const UpdateChunkRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateChunkRequest& default_instance();
  void Swap(UpdateChunkRequest* other);
  
  // implements Message ----------------------------------------------
  
  UpdateChunkRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdateChunkRequest& from);
  void MergeFrom(const UpdateChunkRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes chunkname = 1;
  inline bool has_chunkname() const;
  inline void clear_chunkname();
  static const int kChunknameFieldNumber = 1;
  inline const ::std::string& chunkname() const;
  inline void set_chunkname(const ::std::string& value);
  inline void set_chunkname(const char* value);
  inline void set_chunkname(const void* value, size_t size);
  inline ::std::string* mutable_chunkname();
  
  // required bytes data = 2;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  
  // required bytes pmid = 3;
  inline bool has_pmid() const;
  inline void clear_pmid();
  static const int kPmidFieldNumber = 3;
  inline const ::std::string& pmid() const;
  inline void set_pmid(const ::std::string& value);
  inline void set_pmid(const char* value);
  inline void set_pmid(const void* value, size_t size);
  inline ::std::string* mutable_pmid();
  
  // required bytes public_key = 4;
  inline bool has_public_key() const;
  inline void clear_public_key();
  static const int kPublicKeyFieldNumber = 4;
  inline const ::std::string& public_key() const;
  inline void set_public_key(const ::std::string& value);
  inline void set_public_key(const char* value);
  inline void set_public_key(const void* value, size_t size);
  inline ::std::string* mutable_public_key();
  
  // required bytes public_key_signature = 5;
  inline bool has_public_key_signature() const;
  inline void clear_public_key_signature();
  static const int kPublicKeySignatureFieldNumber = 5;
  inline const ::std::string& public_key_signature() const;
  inline void set_public_key_signature(const ::std::string& value);
  inline void set_public_key_signature(const char* value);
  inline void set_public_key_signature(const void* value, size_t size);
  inline ::std::string* mutable_public_key_signature();
  
  // required bytes request_signature = 6;
  inline bool has_request_signature() const;
  inline void clear_request_signature();
  static const int kRequestSignatureFieldNumber = 6;
  inline const ::std::string& request_signature() const;
  inline void set_request_signature(const ::std::string& value);
  inline void set_request_signature(const char* value);
  inline void set_request_signature(const void* value, size_t size);
  inline ::std::string* mutable_request_signature();
  
  // required int32 data_type = 7;
  inline bool has_data_type() const;
  inline void clear_data_type();
  static const int kDataTypeFieldNumber = 7;
  inline ::google::protobuf::int32 data_type() const;
  inline void set_data_type(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* chunkname_;
  static const ::std::string _default_chunkname_;
  ::std::string* data_;
  static const ::std::string _default_data_;
  ::std::string* pmid_;
  static const ::std::string _default_pmid_;
  ::std::string* public_key_;
  static const ::std::string _default_public_key_;
  ::std::string* public_key_signature_;
  static const ::std::string _default_public_key_signature_;
  ::std::string* request_signature_;
  static const ::std::string _default_request_signature_;
  ::google::protobuf::int32 data_type_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static UpdateChunkRequest* default_instance_;
};
// -------------------------------------------------------------------

class UpdateChunkResponse : public ::google::protobuf::Message {
 public:
  UpdateChunkResponse();
  virtual ~UpdateChunkResponse();
  
  UpdateChunkResponse(const UpdateChunkResponse& from);
  
  inline UpdateChunkResponse& operator=(const UpdateChunkResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateChunkResponse& default_instance();
  void Swap(UpdateChunkResponse* other);
  
  // implements Message ----------------------------------------------
  
  UpdateChunkResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdateChunkResponse& from);
  void MergeFrom(const UpdateChunkResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);
  
  // optional bytes pmid = 2;
  inline bool has_pmid() const;
  inline void clear_pmid();
  static const int kPmidFieldNumber = 2;
  inline const ::std::string& pmid() const;
  inline void set_pmid(const ::std::string& value);
  inline void set_pmid(const char* value);
  inline void set_pmid(const void* value, size_t size);
  inline ::std::string* mutable_pmid();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 result_;
  ::std::string* pmid_;
  static const ::std::string _default_pmid_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static UpdateChunkResponse* default_instance_;
};
// -------------------------------------------------------------------

class DeleteChunkRequest : public ::google::protobuf::Message {
 public:
  DeleteChunkRequest();
  virtual ~DeleteChunkRequest();
  
  DeleteChunkRequest(const DeleteChunkRequest& from);
  
  inline DeleteChunkRequest& operator=(const DeleteChunkRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteChunkRequest& default_instance();
  void Swap(DeleteChunkRequest* other);
  
  // implements Message ----------------------------------------------
  
  DeleteChunkRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeleteChunkRequest& from);
  void MergeFrom(const DeleteChunkRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes chunkname = 1;
  inline bool has_chunkname() const;
  inline void clear_chunkname();
  static const int kChunknameFieldNumber = 1;
  inline const ::std::string& chunkname() const;
  inline void set_chunkname(const ::std::string& value);
  inline void set_chunkname(const char* value);
  inline void set_chunkname(const void* value, size_t size);
  inline ::std::string* mutable_chunkname();
  
  // required .maidsafe.SignedSize signed_size = 2;
  inline bool has_signed_size() const;
  inline void clear_signed_size();
  static const int kSignedSizeFieldNumber = 2;
  inline const ::maidsafe::SignedSize& signed_size() const;
  inline ::maidsafe::SignedSize* mutable_signed_size();
  
  // required bytes request_signature = 3;
  inline bool has_request_signature() const;
  inline void clear_request_signature();
  static const int kRequestSignatureFieldNumber = 3;
  inline const ::std::string& request_signature() const;
  inline void set_request_signature(const ::std::string& value);
  inline void set_request_signature(const char* value);
  inline void set_request_signature(const void* value, size_t size);
  inline ::std::string* mutable_request_signature();
  
  // required int32 data_type = 4;
  inline bool has_data_type() const;
  inline void clear_data_type();
  static const int kDataTypeFieldNumber = 4;
  inline ::google::protobuf::int32 data_type() const;
  inline void set_data_type(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* chunkname_;
  static const ::std::string _default_chunkname_;
  ::maidsafe::SignedSize* signed_size_;
  ::std::string* request_signature_;
  static const ::std::string _default_request_signature_;
  ::google::protobuf::int32 data_type_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static DeleteChunkRequest* default_instance_;
};
// -------------------------------------------------------------------

class DeleteChunkResponse : public ::google::protobuf::Message {
 public:
  DeleteChunkResponse();
  virtual ~DeleteChunkResponse();
  
  DeleteChunkResponse(const DeleteChunkResponse& from);
  
  inline DeleteChunkResponse& operator=(const DeleteChunkResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteChunkResponse& default_instance();
  void Swap(DeleteChunkResponse* other);
  
  // implements Message ----------------------------------------------
  
  DeleteChunkResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeleteChunkResponse& from);
  void MergeFrom(const DeleteChunkResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);
  
  // optional bytes pmid = 2;
  inline bool has_pmid() const;
  inline void clear_pmid();
  static const int kPmidFieldNumber = 2;
  inline const ::std::string& pmid() const;
  inline void set_pmid(const ::std::string& value);
  inline void set_pmid(const char* value);
  inline void set_pmid(const void* value, size_t size);
  inline ::std::string* mutable_pmid();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 result_;
  ::std::string* pmid_;
  static const ::std::string _default_pmid_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static DeleteChunkResponse* default_instance_;
};
// -------------------------------------------------------------------

class ValidityCheckRequest : public ::google::protobuf::Message {
 public:
  ValidityCheckRequest();
  virtual ~ValidityCheckRequest();
  
  ValidityCheckRequest(const ValidityCheckRequest& from);
  
  inline ValidityCheckRequest& operator=(const ValidityCheckRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ValidityCheckRequest& default_instance();
  void Swap(ValidityCheckRequest* other);
  
  // implements Message ----------------------------------------------
  
  ValidityCheckRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ValidityCheckRequest& from);
  void MergeFrom(const ValidityCheckRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes chunkname = 1;
  inline bool has_chunkname() const;
  inline void clear_chunkname();
  static const int kChunknameFieldNumber = 1;
  inline const ::std::string& chunkname() const;
  inline void set_chunkname(const ::std::string& value);
  inline void set_chunkname(const char* value);
  inline void set_chunkname(const void* value, size_t size);
  inline ::std::string* mutable_chunkname();
  
  // required bytes random_data = 2;
  inline bool has_random_data() const;
  inline void clear_random_data();
  static const int kRandomDataFieldNumber = 2;
  inline const ::std::string& random_data() const;
  inline void set_random_data(const ::std::string& value);
  inline void set_random_data(const char* value);
  inline void set_random_data(const void* value, size_t size);
  inline ::std::string* mutable_random_data();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* chunkname_;
  static const ::std::string _default_chunkname_;
  ::std::string* random_data_;
  static const ::std::string _default_random_data_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ValidityCheckRequest* default_instance_;
};
// -------------------------------------------------------------------

class ValidityCheckResponse : public ::google::protobuf::Message {
 public:
  ValidityCheckResponse();
  virtual ~ValidityCheckResponse();
  
  ValidityCheckResponse(const ValidityCheckResponse& from);
  
  inline ValidityCheckResponse& operator=(const ValidityCheckResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ValidityCheckResponse& default_instance();
  void Swap(ValidityCheckResponse* other);
  
  // implements Message ----------------------------------------------
  
  ValidityCheckResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ValidityCheckResponse& from);
  void MergeFrom(const ValidityCheckResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);
  
  // optional bytes hash_content = 2;
  inline bool has_hash_content() const;
  inline void clear_hash_content();
  static const int kHashContentFieldNumber = 2;
  inline const ::std::string& hash_content() const;
  inline void set_hash_content(const ::std::string& value);
  inline void set_hash_content(const char* value);
  inline void set_hash_content(const void* value, size_t size);
  inline ::std::string* mutable_hash_content();
  
  // required bytes pmid = 3;
  inline bool has_pmid() const;
  inline void clear_pmid();
  static const int kPmidFieldNumber = 3;
  inline const ::std::string& pmid() const;
  inline void set_pmid(const ::std::string& value);
  inline void set_pmid(const char* value);
  inline void set_pmid(const void* value, size_t size);
  inline ::std::string* mutable_pmid();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 result_;
  ::std::string* hash_content_;
  static const ::std::string _default_hash_content_;
  ::std::string* pmid_;
  static const ::std::string _default_pmid_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ValidityCheckResponse* default_instance_;
};
// -------------------------------------------------------------------

class SwapChunkRequest : public ::google::protobuf::Message {
 public:
  SwapChunkRequest();
  virtual ~SwapChunkRequest();
  
  SwapChunkRequest(const SwapChunkRequest& from);
  
  inline SwapChunkRequest& operator=(const SwapChunkRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SwapChunkRequest& default_instance();
  void Swap(SwapChunkRequest* other);
  
  // implements Message ----------------------------------------------
  
  SwapChunkRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SwapChunkRequest& from);
  void MergeFrom(const SwapChunkRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 request_type = 1;
  inline bool has_request_type() const;
  inline void clear_request_type();
  static const int kRequestTypeFieldNumber = 1;
  inline ::google::protobuf::int32 request_type() const;
  inline void set_request_type(::google::protobuf::int32 value);
  
  // required bytes chunkname1 = 2;
  inline bool has_chunkname1() const;
  inline void clear_chunkname1();
  static const int kChunkname1FieldNumber = 2;
  inline const ::std::string& chunkname1() const;
  inline void set_chunkname1(const ::std::string& value);
  inline void set_chunkname1(const char* value);
  inline void set_chunkname1(const void* value, size_t size);
  inline ::std::string* mutable_chunkname1();
  
  // optional bytes chunkcontent1 = 3;
  inline bool has_chunkcontent1() const;
  inline void clear_chunkcontent1();
  static const int kChunkcontent1FieldNumber = 3;
  inline const ::std::string& chunkcontent1() const;
  inline void set_chunkcontent1(const ::std::string& value);
  inline void set_chunkcontent1(const char* value);
  inline void set_chunkcontent1(const void* value, size_t size);
  inline ::std::string* mutable_chunkcontent1();
  
  // optional int32 size1 = 4;
  inline bool has_size1() const;
  inline void clear_size1();
  static const int kSize1FieldNumber = 4;
  inline ::google::protobuf::int32 size1() const;
  inline void set_size1(::google::protobuf::int32 value);
  
  // optional bytes chunkname2 = 5;
  inline bool has_chunkname2() const;
  inline void clear_chunkname2();
  static const int kChunkname2FieldNumber = 5;
  inline const ::std::string& chunkname2() const;
  inline void set_chunkname2(const ::std::string& value);
  inline void set_chunkname2(const char* value);
  inline void set_chunkname2(const void* value, size_t size);
  inline ::std::string* mutable_chunkname2();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 request_type_;
  ::std::string* chunkname1_;
  static const ::std::string _default_chunkname1_;
  ::std::string* chunkcontent1_;
  static const ::std::string _default_chunkcontent1_;
  ::google::protobuf::int32 size1_;
  ::std::string* chunkname2_;
  static const ::std::string _default_chunkname2_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static SwapChunkRequest* default_instance_;
};
// -------------------------------------------------------------------

class SwapChunkResponse : public ::google::protobuf::Message {
 public:
  SwapChunkResponse();
  virtual ~SwapChunkResponse();
  
  SwapChunkResponse(const SwapChunkResponse& from);
  
  inline SwapChunkResponse& operator=(const SwapChunkResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SwapChunkResponse& default_instance();
  void Swap(SwapChunkResponse* other);
  
  // implements Message ----------------------------------------------
  
  SwapChunkResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SwapChunkResponse& from);
  void MergeFrom(const SwapChunkResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 request_type = 1;
  inline bool has_request_type() const;
  inline void clear_request_type();
  static const int kRequestTypeFieldNumber = 1;
  inline ::google::protobuf::int32 request_type() const;
  inline void set_request_type(::google::protobuf::int32 value);
  
  // required uint32 result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);
  
  // optional bytes chunkname1 = 3;
  inline bool has_chunkname1() const;
  inline void clear_chunkname1();
  static const int kChunkname1FieldNumber = 3;
  inline const ::std::string& chunkname1() const;
  inline void set_chunkname1(const ::std::string& value);
  inline void set_chunkname1(const char* value);
  inline void set_chunkname1(const void* value, size_t size);
  inline ::std::string* mutable_chunkname1();
  
  // optional bytes chunkcontent1 = 4;
  inline bool has_chunkcontent1() const;
  inline void clear_chunkcontent1();
  static const int kChunkcontent1FieldNumber = 4;
  inline const ::std::string& chunkcontent1() const;
  inline void set_chunkcontent1(const ::std::string& value);
  inline void set_chunkcontent1(const char* value);
  inline void set_chunkcontent1(const void* value, size_t size);
  inline ::std::string* mutable_chunkcontent1();
  
  // optional int32 size1 = 5;
  inline bool has_size1() const;
  inline void clear_size1();
  static const int kSize1FieldNumber = 5;
  inline ::google::protobuf::int32 size1() const;
  inline void set_size1(::google::protobuf::int32 value);
  
  // optional bytes chunkname2 = 6;
  inline bool has_chunkname2() const;
  inline void clear_chunkname2();
  static const int kChunkname2FieldNumber = 6;
  inline const ::std::string& chunkname2() const;
  inline void set_chunkname2(const ::std::string& value);
  inline void set_chunkname2(const char* value);
  inline void set_chunkname2(const void* value, size_t size);
  inline ::std::string* mutable_chunkname2();
  
  // optional bytes chunkcontent2 = 7;
  inline bool has_chunkcontent2() const;
  inline void clear_chunkcontent2();
  static const int kChunkcontent2FieldNumber = 7;
  inline const ::std::string& chunkcontent2() const;
  inline void set_chunkcontent2(const ::std::string& value);
  inline void set_chunkcontent2(const char* value);
  inline void set_chunkcontent2(const void* value, size_t size);
  inline ::std::string* mutable_chunkcontent2();
  
  // optional int32 size2 = 8;
  inline bool has_size2() const;
  inline void clear_size2();
  static const int kSize2FieldNumber = 8;
  inline ::google::protobuf::int32 size2() const;
  inline void set_size2(::google::protobuf::int32 value);
  
  // required bytes pmid = 9;
  inline bool has_pmid() const;
  inline void clear_pmid();
  static const int kPmidFieldNumber = 9;
  inline const ::std::string& pmid() const;
  inline void set_pmid(const ::std::string& value);
  inline void set_pmid(const char* value);
  inline void set_pmid(const void* value, size_t size);
  inline ::std::string* mutable_pmid();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 request_type_;
  ::google::protobuf::uint32 result_;
  ::std::string* chunkname1_;
  static const ::std::string _default_chunkname1_;
  ::std::string* chunkcontent1_;
  static const ::std::string _default_chunkcontent1_;
  ::google::protobuf::int32 size1_;
  ::std::string* chunkname2_;
  static const ::std::string _default_chunkname2_;
  ::std::string* chunkcontent2_;
  static const ::std::string _default_chunkcontent2_;
  ::google::protobuf::int32 size2_;
  ::std::string* pmid_;
  static const ::std::string _default_pmid_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static SwapChunkResponse* default_instance_;
};
// -------------------------------------------------------------------

class VaultCommunication : public ::google::protobuf::Message {
 public:
  VaultCommunication();
  virtual ~VaultCommunication();
  
  VaultCommunication(const VaultCommunication& from);
  
  inline VaultCommunication& operator=(const VaultCommunication& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const VaultCommunication& default_instance();
  void Swap(VaultCommunication* other);
  
  // implements Message ----------------------------------------------
  
  VaultCommunication* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VaultCommunication& from);
  void MergeFrom(const VaultCommunication& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bytes chunkstore = 1;
  inline bool has_chunkstore() const;
  inline void clear_chunkstore();
  static const int kChunkstoreFieldNumber = 1;
  inline const ::std::string& chunkstore() const;
  inline void set_chunkstore(const ::std::string& value);
  inline void set_chunkstore(const char* value);
  inline void set_chunkstore(const void* value, size_t size);
  inline ::std::string* mutable_chunkstore();
  
  // optional uint64 offered_space = 2;
  inline bool has_offered_space() const;
  inline void clear_offered_space();
  static const int kOfferedSpaceFieldNumber = 2;
  inline ::google::protobuf::uint64 offered_space() const;
  inline void set_offered_space(::google::protobuf::uint64 value);
  
  // optional uint64 free_space = 3;
  inline bool has_free_space() const;
  inline void clear_free_space();
  static const int kFreeSpaceFieldNumber = 3;
  inline ::google::protobuf::uint64 free_space() const;
  inline void set_free_space(::google::protobuf::uint64 value);
  
  // optional bytes ip = 4;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 4;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const void* value, size_t size);
  inline ::std::string* mutable_ip();
  
  // optional uint32 port = 5;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 5;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);
  
  // required uint32 timestamp = 6;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 6;
  inline ::google::protobuf::uint32 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint32 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* chunkstore_;
  static const ::std::string _default_chunkstore_;
  ::google::protobuf::uint64 offered_space_;
  ::google::protobuf::uint64 free_space_;
  ::std::string* ip_;
  static const ::std::string _default_ip_;
  ::google::protobuf::uint32 port_;
  ::google::protobuf::uint32 timestamp_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static VaultCommunication* default_instance_;
};
// -------------------------------------------------------------------

class VaultStatusRequest : public ::google::protobuf::Message {
 public:
  VaultStatusRequest();
  virtual ~VaultStatusRequest();
  
  VaultStatusRequest(const VaultStatusRequest& from);
  
  inline VaultStatusRequest& operator=(const VaultStatusRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const VaultStatusRequest& default_instance();
  void Swap(VaultStatusRequest* other);
  
  // implements Message ----------------------------------------------
  
  VaultStatusRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VaultStatusRequest& from);
  void MergeFrom(const VaultStatusRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes encrypted_request = 1;
  inline bool has_encrypted_request() const;
  inline void clear_encrypted_request();
  static const int kEncryptedRequestFieldNumber = 1;
  inline const ::std::string& encrypted_request() const;
  inline void set_encrypted_request(const ::std::string& value);
  inline void set_encrypted_request(const char* value);
  inline void set_encrypted_request(const void* value, size_t size);
  inline ::std::string* mutable_encrypted_request();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* encrypted_request_;
  static const ::std::string _default_encrypted_request_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static VaultStatusRequest* default_instance_;
};
// -------------------------------------------------------------------

class VaultStatusResponse : public ::google::protobuf::Message {
 public:
  VaultStatusResponse();
  virtual ~VaultStatusResponse();
  
  VaultStatusResponse(const VaultStatusResponse& from);
  
  inline VaultStatusResponse& operator=(const VaultStatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const VaultStatusResponse& default_instance();
  void Swap(VaultStatusResponse* other);
  
  // implements Message ----------------------------------------------
  
  VaultStatusResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VaultStatusResponse& from);
  void MergeFrom(const VaultStatusResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);
  
  // optional bytes encrypted_response = 2;
  inline bool has_encrypted_response() const;
  inline void clear_encrypted_response();
  static const int kEncryptedResponseFieldNumber = 2;
  inline const ::std::string& encrypted_response() const;
  inline void set_encrypted_response(const ::std::string& value);
  inline void set_encrypted_response(const char* value);
  inline void set_encrypted_response(const void* value, size_t size);
  inline ::std::string* mutable_encrypted_response();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 result_;
  ::std::string* encrypted_response_;
  static const ::std::string _default_encrypted_response_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static VaultStatusResponse* default_instance_;
};
// -------------------------------------------------------------------

class OwnVaultRequest : public ::google::protobuf::Message {
 public:
  OwnVaultRequest();
  virtual ~OwnVaultRequest();
  
  OwnVaultRequest(const OwnVaultRequest& from);
  
  inline OwnVaultRequest& operator=(const OwnVaultRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OwnVaultRequest& default_instance();
  void Swap(OwnVaultRequest* other);
  
  // implements Message ----------------------------------------------
  
  OwnVaultRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OwnVaultRequest& from);
  void MergeFrom(const OwnVaultRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes public_key = 1;
  inline bool has_public_key() const;
  inline void clear_public_key();
  static const int kPublicKeyFieldNumber = 1;
  inline const ::std::string& public_key() const;
  inline void set_public_key(const ::std::string& value);
  inline void set_public_key(const char* value);
  inline void set_public_key(const void* value, size_t size);
  inline ::std::string* mutable_public_key();
  
  // required bytes private_key = 2;
  inline bool has_private_key() const;
  inline void clear_private_key();
  static const int kPrivateKeyFieldNumber = 2;
  inline const ::std::string& private_key() const;
  inline void set_private_key(const ::std::string& value);
  inline void set_private_key(const char* value);
  inline void set_private_key(const void* value, size_t size);
  inline ::std::string* mutable_private_key();
  
  // required bytes signed_public_key = 3;
  inline bool has_signed_public_key() const;
  inline void clear_signed_public_key();
  static const int kSignedPublicKeyFieldNumber = 3;
  inline const ::std::string& signed_public_key() const;
  inline void set_signed_public_key(const ::std::string& value);
  inline void set_signed_public_key(const char* value);
  inline void set_signed_public_key(const void* value, size_t size);
  inline ::std::string* mutable_signed_public_key();
  
  // required bytes chunkstore_dir = 4;
  inline bool has_chunkstore_dir() const;
  inline void clear_chunkstore_dir();
  static const int kChunkstoreDirFieldNumber = 4;
  inline const ::std::string& chunkstore_dir() const;
  inline void set_chunkstore_dir(const ::std::string& value);
  inline void set_chunkstore_dir(const char* value);
  inline void set_chunkstore_dir(const void* value, size_t size);
  inline ::std::string* mutable_chunkstore_dir();
  
  // required uint32 port = 5;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 5;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);
  
  // required uint64 space = 6;
  inline bool has_space() const;
  inline void clear_space();
  static const int kSpaceFieldNumber = 6;
  inline ::google::protobuf::uint64 space() const;
  inline void set_space(::google::protobuf::uint64 value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* public_key_;
  static const ::std::string _default_public_key_;
  ::std::string* private_key_;
  static const ::std::string _default_private_key_;
  ::std::string* signed_public_key_;
  static const ::std::string _default_signed_public_key_;
  ::std::string* chunkstore_dir_;
  static const ::std::string _default_chunkstore_dir_;
  ::google::protobuf::uint32 port_;
  ::google::protobuf::uint64 space_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static OwnVaultRequest* default_instance_;
};
// -------------------------------------------------------------------

class OwnVaultResponse : public ::google::protobuf::Message {
 public:
  OwnVaultResponse();
  virtual ~OwnVaultResponse();
  
  OwnVaultResponse(const OwnVaultResponse& from);
  
  inline OwnVaultResponse& operator=(const OwnVaultResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OwnVaultResponse& default_instance();
  void Swap(OwnVaultResponse* other);
  
  // implements Message ----------------------------------------------
  
  OwnVaultResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OwnVaultResponse& from);
  void MergeFrom(const OwnVaultResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .maidsafe.OwnVaultResult result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline maidsafe::OwnVaultResult result() const;
  inline void set_result(maidsafe::OwnVaultResult value);
  
  // optional bytes pmid_name = 2;
  inline bool has_pmid_name() const;
  inline void clear_pmid_name();
  static const int kPmidNameFieldNumber = 2;
  inline const ::std::string& pmid_name() const;
  inline void set_pmid_name(const ::std::string& value);
  inline void set_pmid_name(const char* value);
  inline void set_pmid_name(const void* value, size_t size);
  inline ::std::string* mutable_pmid_name();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  int result_;
  ::std::string* pmid_name_;
  static const ::std::string _default_pmid_name_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static OwnVaultResponse* default_instance_;
};
// -------------------------------------------------------------------

class IsOwnedRequest : public ::google::protobuf::Message {
 public:
  IsOwnedRequest();
  virtual ~IsOwnedRequest();
  
  IsOwnedRequest(const IsOwnedRequest& from);
  
  inline IsOwnedRequest& operator=(const IsOwnedRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const IsOwnedRequest& default_instance();
  void Swap(IsOwnedRequest* other);
  
  // implements Message ----------------------------------------------
  
  IsOwnedRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IsOwnedRequest& from);
  void MergeFrom(const IsOwnedRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[1];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static IsOwnedRequest* default_instance_;
};
// -------------------------------------------------------------------

class IsOwnedResponse : public ::google::protobuf::Message {
 public:
  IsOwnedResponse();
  virtual ~IsOwnedResponse();
  
  IsOwnedResponse(const IsOwnedResponse& from);
  
  inline IsOwnedResponse& operator=(const IsOwnedResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const IsOwnedResponse& default_instance();
  void Swap(IsOwnedResponse* other);
  
  // implements Message ----------------------------------------------
  
  IsOwnedResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IsOwnedResponse& from);
  void MergeFrom(const IsOwnedResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .maidsafe.VaultStatus status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline maidsafe::VaultStatus status() const;
  inline void set_status(maidsafe::VaultStatus value);
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  int status_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static IsOwnedResponse* default_instance_;
};
// -------------------------------------------------------------------

class CreateBPRequest : public ::google::protobuf::Message {
 public:
  CreateBPRequest();
  virtual ~CreateBPRequest();
  
  CreateBPRequest(const CreateBPRequest& from);
  
  inline CreateBPRequest& operator=(const CreateBPRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateBPRequest& default_instance();
  void Swap(CreateBPRequest* other);
  
  // implements Message ----------------------------------------------
  
  CreateBPRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateBPRequest& from);
  void MergeFrom(const CreateBPRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes bufferpacket_name = 1;
  inline bool has_bufferpacket_name() const;
  inline void clear_bufferpacket_name();
  static const int kBufferpacketNameFieldNumber = 1;
  inline const ::std::string& bufferpacket_name() const;
  inline void set_bufferpacket_name(const ::std::string& value);
  inline void set_bufferpacket_name(const char* value);
  inline void set_bufferpacket_name(const void* value, size_t size);
  inline ::std::string* mutable_bufferpacket_name();
  
  // required bytes data = 2;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  
  // required bytes pmid = 3;
  inline bool has_pmid() const;
  inline void clear_pmid();
  static const int kPmidFieldNumber = 3;
  inline const ::std::string& pmid() const;
  inline void set_pmid(const ::std::string& value);
  inline void set_pmid(const char* value);
  inline void set_pmid(const void* value, size_t size);
  inline ::std::string* mutable_pmid();
  
  // required bytes public_key = 4;
  inline bool has_public_key() const;
  inline void clear_public_key();
  static const int kPublicKeyFieldNumber = 4;
  inline const ::std::string& public_key() const;
  inline void set_public_key(const ::std::string& value);
  inline void set_public_key(const char* value);
  inline void set_public_key(const void* value, size_t size);
  inline ::std::string* mutable_public_key();
  
  // required bytes signed_public_key = 5;
  inline bool has_signed_public_key() const;
  inline void clear_signed_public_key();
  static const int kSignedPublicKeyFieldNumber = 5;
  inline const ::std::string& signed_public_key() const;
  inline void set_signed_public_key(const ::std::string& value);
  inline void set_signed_public_key(const char* value);
  inline void set_signed_public_key(const void* value, size_t size);
  inline ::std::string* mutable_signed_public_key();
  
  // required bytes signed_request = 6;
  inline bool has_signed_request() const;
  inline void clear_signed_request();
  static const int kSignedRequestFieldNumber = 6;
  inline const ::std::string& signed_request() const;
  inline void set_signed_request(const ::std::string& value);
  inline void set_signed_request(const char* value);
  inline void set_signed_request(const void* value, size_t size);
  inline ::std::string* mutable_signed_request();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* bufferpacket_name_;
  static const ::std::string _default_bufferpacket_name_;
  ::std::string* data_;
  static const ::std::string _default_data_;
  ::std::string* pmid_;
  static const ::std::string _default_pmid_;
  ::std::string* public_key_;
  static const ::std::string _default_public_key_;
  ::std::string* signed_public_key_;
  static const ::std::string _default_signed_public_key_;
  ::std::string* signed_request_;
  static const ::std::string _default_signed_request_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static CreateBPRequest* default_instance_;
};
// -------------------------------------------------------------------

class CreateBPResponse : public ::google::protobuf::Message {
 public:
  CreateBPResponse();
  virtual ~CreateBPResponse();
  
  CreateBPResponse(const CreateBPResponse& from);
  
  inline CreateBPResponse& operator=(const CreateBPResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateBPResponse& default_instance();
  void Swap(CreateBPResponse* other);
  
  // implements Message ----------------------------------------------
  
  CreateBPResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateBPResponse& from);
  void MergeFrom(const CreateBPResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);
  
  // optional bytes pmid_id = 2;
  inline bool has_pmid_id() const;
  inline void clear_pmid_id();
  static const int kPmidIdFieldNumber = 2;
  inline const ::std::string& pmid_id() const;
  inline void set_pmid_id(const ::std::string& value);
  inline void set_pmid_id(const char* value);
  inline void set_pmid_id(const void* value, size_t size);
  inline ::std::string* mutable_pmid_id();
  
  // optional bytes public_key = 3;
  inline bool has_public_key() const;
  inline void clear_public_key();
  static const int kPublicKeyFieldNumber = 3;
  inline const ::std::string& public_key() const;
  inline void set_public_key(const ::std::string& value);
  inline void set_public_key(const char* value);
  inline void set_public_key(const void* value, size_t size);
  inline ::std::string* mutable_public_key();
  
  // optional bytes signed_public_key = 4;
  inline bool has_signed_public_key() const;
  inline void clear_signed_public_key();
  static const int kSignedPublicKeyFieldNumber = 4;
  inline const ::std::string& signed_public_key() const;
  inline void set_signed_public_key(const ::std::string& value);
  inline void set_signed_public_key(const char* value);
  inline void set_signed_public_key(const void* value, size_t size);
  inline ::std::string* mutable_signed_public_key();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 result_;
  ::std::string* pmid_id_;
  static const ::std::string _default_pmid_id_;
  ::std::string* public_key_;
  static const ::std::string _default_public_key_;
  ::std::string* signed_public_key_;
  static const ::std::string _default_signed_public_key_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static CreateBPResponse* default_instance_;
};
// -------------------------------------------------------------------

class ModifyBPInfoRequest : public ::google::protobuf::Message {
 public:
  ModifyBPInfoRequest();
  virtual ~ModifyBPInfoRequest();
  
  ModifyBPInfoRequest(const ModifyBPInfoRequest& from);
  
  inline ModifyBPInfoRequest& operator=(const ModifyBPInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ModifyBPInfoRequest& default_instance();
  void Swap(ModifyBPInfoRequest* other);
  
  // implements Message ----------------------------------------------
  
  ModifyBPInfoRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModifyBPInfoRequest& from);
  void MergeFrom(const ModifyBPInfoRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes bufferpacket_name = 1;
  inline bool has_bufferpacket_name() const;
  inline void clear_bufferpacket_name();
  static const int kBufferpacketNameFieldNumber = 1;
  inline const ::std::string& bufferpacket_name() const;
  inline void set_bufferpacket_name(const ::std::string& value);
  inline void set_bufferpacket_name(const char* value);
  inline void set_bufferpacket_name(const void* value, size_t size);
  inline ::std::string* mutable_bufferpacket_name();
  
  // required bytes data = 2;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  
  // required bytes pmid = 3;
  inline bool has_pmid() const;
  inline void clear_pmid();
  static const int kPmidFieldNumber = 3;
  inline const ::std::string& pmid() const;
  inline void set_pmid(const ::std::string& value);
  inline void set_pmid(const char* value);
  inline void set_pmid(const void* value, size_t size);
  inline ::std::string* mutable_pmid();
  
  // required bytes public_key = 4;
  inline bool has_public_key() const;
  inline void clear_public_key();
  static const int kPublicKeyFieldNumber = 4;
  inline const ::std::string& public_key() const;
  inline void set_public_key(const ::std::string& value);
  inline void set_public_key(const char* value);
  inline void set_public_key(const void* value, size_t size);
  inline ::std::string* mutable_public_key();
  
  // required bytes signed_public_key = 5;
  inline bool has_signed_public_key() const;
  inline void clear_signed_public_key();
  static const int kSignedPublicKeyFieldNumber = 5;
  inline const ::std::string& signed_public_key() const;
  inline void set_signed_public_key(const ::std::string& value);
  inline void set_signed_public_key(const char* value);
  inline void set_signed_public_key(const void* value, size_t size);
  inline ::std::string* mutable_signed_public_key();
  
  // required bytes signed_request = 6;
  inline bool has_signed_request() const;
  inline void clear_signed_request();
  static const int kSignedRequestFieldNumber = 6;
  inline const ::std::string& signed_request() const;
  inline void set_signed_request(const ::std::string& value);
  inline void set_signed_request(const char* value);
  inline void set_signed_request(const void* value, size_t size);
  inline ::std::string* mutable_signed_request();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* bufferpacket_name_;
  static const ::std::string _default_bufferpacket_name_;
  ::std::string* data_;
  static const ::std::string _default_data_;
  ::std::string* pmid_;
  static const ::std::string _default_pmid_;
  ::std::string* public_key_;
  static const ::std::string _default_public_key_;
  ::std::string* signed_public_key_;
  static const ::std::string _default_signed_public_key_;
  ::std::string* signed_request_;
  static const ::std::string _default_signed_request_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ModifyBPInfoRequest* default_instance_;
};
// -------------------------------------------------------------------

class ModifyBPInfoResponse : public ::google::protobuf::Message {
 public:
  ModifyBPInfoResponse();
  virtual ~ModifyBPInfoResponse();
  
  ModifyBPInfoResponse(const ModifyBPInfoResponse& from);
  
  inline ModifyBPInfoResponse& operator=(const ModifyBPInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ModifyBPInfoResponse& default_instance();
  void Swap(ModifyBPInfoResponse* other);
  
  // implements Message ----------------------------------------------
  
  ModifyBPInfoResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModifyBPInfoResponse& from);
  void MergeFrom(const ModifyBPInfoResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);
  
  // optional bytes pmid_id = 2;
  inline bool has_pmid_id() const;
  inline void clear_pmid_id();
  static const int kPmidIdFieldNumber = 2;
  inline const ::std::string& pmid_id() const;
  inline void set_pmid_id(const ::std::string& value);
  inline void set_pmid_id(const char* value);
  inline void set_pmid_id(const void* value, size_t size);
  inline ::std::string* mutable_pmid_id();
  
  // optional bytes public_key = 3;
  inline bool has_public_key() const;
  inline void clear_public_key();
  static const int kPublicKeyFieldNumber = 3;
  inline const ::std::string& public_key() const;
  inline void set_public_key(const ::std::string& value);
  inline void set_public_key(const char* value);
  inline void set_public_key(const void* value, size_t size);
  inline ::std::string* mutable_public_key();
  
  // optional bytes signed_public_key = 4;
  inline bool has_signed_public_key() const;
  inline void clear_signed_public_key();
  static const int kSignedPublicKeyFieldNumber = 4;
  inline const ::std::string& signed_public_key() const;
  inline void set_signed_public_key(const ::std::string& value);
  inline void set_signed_public_key(const char* value);
  inline void set_signed_public_key(const void* value, size_t size);
  inline ::std::string* mutable_signed_public_key();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 result_;
  ::std::string* pmid_id_;
  static const ::std::string _default_pmid_id_;
  ::std::string* public_key_;
  static const ::std::string _default_public_key_;
  ::std::string* signed_public_key_;
  static const ::std::string _default_signed_public_key_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ModifyBPInfoResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetBPMessagesRequest : public ::google::protobuf::Message {
 public:
  GetBPMessagesRequest();
  virtual ~GetBPMessagesRequest();
  
  GetBPMessagesRequest(const GetBPMessagesRequest& from);
  
  inline GetBPMessagesRequest& operator=(const GetBPMessagesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetBPMessagesRequest& default_instance();
  void Swap(GetBPMessagesRequest* other);
  
  // implements Message ----------------------------------------------
  
  GetBPMessagesRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetBPMessagesRequest& from);
  void MergeFrom(const GetBPMessagesRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes bufferpacket_name = 1;
  inline bool has_bufferpacket_name() const;
  inline void clear_bufferpacket_name();
  static const int kBufferpacketNameFieldNumber = 1;
  inline const ::std::string& bufferpacket_name() const;
  inline void set_bufferpacket_name(const ::std::string& value);
  inline void set_bufferpacket_name(const char* value);
  inline void set_bufferpacket_name(const void* value, size_t size);
  inline ::std::string* mutable_bufferpacket_name();
  
  // required bytes public_key = 2;
  inline bool has_public_key() const;
  inline void clear_public_key();
  static const int kPublicKeyFieldNumber = 2;
  inline const ::std::string& public_key() const;
  inline void set_public_key(const ::std::string& value);
  inline void set_public_key(const char* value);
  inline void set_public_key(const void* value, size_t size);
  inline ::std::string* mutable_public_key();
  
  // required bytes pmid = 3;
  inline bool has_pmid() const;
  inline void clear_pmid();
  static const int kPmidFieldNumber = 3;
  inline const ::std::string& pmid() const;
  inline void set_pmid(const ::std::string& value);
  inline void set_pmid(const char* value);
  inline void set_pmid(const void* value, size_t size);
  inline ::std::string* mutable_pmid();
  
  // required bytes signed_public_key = 4;
  inline bool has_signed_public_key() const;
  inline void clear_signed_public_key();
  static const int kSignedPublicKeyFieldNumber = 4;
  inline const ::std::string& signed_public_key() const;
  inline void set_signed_public_key(const ::std::string& value);
  inline void set_signed_public_key(const char* value);
  inline void set_signed_public_key(const void* value, size_t size);
  inline ::std::string* mutable_signed_public_key();
  
  // required bytes signed_request = 5;
  inline bool has_signed_request() const;
  inline void clear_signed_request();
  static const int kSignedRequestFieldNumber = 5;
  inline const ::std::string& signed_request() const;
  inline void set_signed_request(const ::std::string& value);
  inline void set_signed_request(const char* value);
  inline void set_signed_request(const void* value, size_t size);
  inline ::std::string* mutable_signed_request();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* bufferpacket_name_;
  static const ::std::string _default_bufferpacket_name_;
  ::std::string* public_key_;
  static const ::std::string _default_public_key_;
  ::std::string* pmid_;
  static const ::std::string _default_pmid_;
  ::std::string* signed_public_key_;
  static const ::std::string _default_signed_public_key_;
  ::std::string* signed_request_;
  static const ::std::string _default_signed_request_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static GetBPMessagesRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetBPMessagesResponse : public ::google::protobuf::Message {
 public:
  GetBPMessagesResponse();
  virtual ~GetBPMessagesResponse();
  
  GetBPMessagesResponse(const GetBPMessagesResponse& from);
  
  inline GetBPMessagesResponse& operator=(const GetBPMessagesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetBPMessagesResponse& default_instance();
  void Swap(GetBPMessagesResponse* other);
  
  // implements Message ----------------------------------------------
  
  GetBPMessagesResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetBPMessagesResponse& from);
  void MergeFrom(const GetBPMessagesResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);
  
  // repeated bytes messages = 2;
  inline int messages_size() const;
  inline void clear_messages();
  static const int kMessagesFieldNumber = 2;
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& messages() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_messages();
  inline const ::std::string& messages(int index) const;
  inline ::std::string* mutable_messages(int index);
  inline void set_messages(int index, const ::std::string& value);
  inline void set_messages(int index, const char* value);
  inline void set_messages(int index, const void* value, size_t size);
  inline ::std::string* add_messages();
  inline void add_messages(const ::std::string& value);
  inline void add_messages(const char* value);
  inline void add_messages(const void* value, size_t size);
  
  // optional bytes pmid_id = 3;
  inline bool has_pmid_id() const;
  inline void clear_pmid_id();
  static const int kPmidIdFieldNumber = 3;
  inline const ::std::string& pmid_id() const;
  inline void set_pmid_id(const ::std::string& value);
  inline void set_pmid_id(const char* value);
  inline void set_pmid_id(const void* value, size_t size);
  inline ::std::string* mutable_pmid_id();
  
  // optional bytes public_key = 4;
  inline bool has_public_key() const;
  inline void clear_public_key();
  static const int kPublicKeyFieldNumber = 4;
  inline const ::std::string& public_key() const;
  inline void set_public_key(const ::std::string& value);
  inline void set_public_key(const char* value);
  inline void set_public_key(const void* value, size_t size);
  inline ::std::string* mutable_public_key();
  
  // optional bytes signed_public_key = 5;
  inline bool has_signed_public_key() const;
  inline void clear_signed_public_key();
  static const int kSignedPublicKeyFieldNumber = 5;
  inline const ::std::string& signed_public_key() const;
  inline void set_signed_public_key(const ::std::string& value);
  inline void set_signed_public_key(const char* value);
  inline void set_signed_public_key(const void* value, size_t size);
  inline ::std::string* mutable_signed_public_key();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 result_;
  ::google::protobuf::RepeatedPtrField< ::std::string> messages_;
  ::std::string* pmid_id_;
  static const ::std::string _default_pmid_id_;
  ::std::string* public_key_;
  static const ::std::string _default_public_key_;
  ::std::string* signed_public_key_;
  static const ::std::string _default_signed_public_key_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static GetBPMessagesResponse* default_instance_;
};
// -------------------------------------------------------------------

class AddBPMessageRequest : public ::google::protobuf::Message {
 public:
  AddBPMessageRequest();
  virtual ~AddBPMessageRequest();
  
  AddBPMessageRequest(const AddBPMessageRequest& from);
  
  inline AddBPMessageRequest& operator=(const AddBPMessageRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AddBPMessageRequest& default_instance();
  void Swap(AddBPMessageRequest* other);
  
  // implements Message ----------------------------------------------
  
  AddBPMessageRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AddBPMessageRequest& from);
  void MergeFrom(const AddBPMessageRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes bufferpacket_name = 1;
  inline bool has_bufferpacket_name() const;
  inline void clear_bufferpacket_name();
  static const int kBufferpacketNameFieldNumber = 1;
  inline const ::std::string& bufferpacket_name() const;
  inline void set_bufferpacket_name(const ::std::string& value);
  inline void set_bufferpacket_name(const char* value);
  inline void set_bufferpacket_name(const void* value, size_t size);
  inline ::std::string* mutable_bufferpacket_name();
  
  // required bytes data = 2;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  
  // required bytes pmid = 3;
  inline bool has_pmid() const;
  inline void clear_pmid();
  static const int kPmidFieldNumber = 3;
  inline const ::std::string& pmid() const;
  inline void set_pmid(const ::std::string& value);
  inline void set_pmid(const char* value);
  inline void set_pmid(const void* value, size_t size);
  inline ::std::string* mutable_pmid();
  
  // required bytes public_key = 4;
  inline bool has_public_key() const;
  inline void clear_public_key();
  static const int kPublicKeyFieldNumber = 4;
  inline const ::std::string& public_key() const;
  inline void set_public_key(const ::std::string& value);
  inline void set_public_key(const char* value);
  inline void set_public_key(const void* value, size_t size);
  inline ::std::string* mutable_public_key();
  
  // required bytes signed_public_key = 5;
  inline bool has_signed_public_key() const;
  inline void clear_signed_public_key();
  static const int kSignedPublicKeyFieldNumber = 5;
  inline const ::std::string& signed_public_key() const;
  inline void set_signed_public_key(const ::std::string& value);
  inline void set_signed_public_key(const char* value);
  inline void set_signed_public_key(const void* value, size_t size);
  inline ::std::string* mutable_signed_public_key();
  
  // required bytes signed_request = 6;
  inline bool has_signed_request() const;
  inline void clear_signed_request();
  static const int kSignedRequestFieldNumber = 6;
  inline const ::std::string& signed_request() const;
  inline void set_signed_request(const ::std::string& value);
  inline void set_signed_request(const char* value);
  inline void set_signed_request(const void* value, size_t size);
  inline ::std::string* mutable_signed_request();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* bufferpacket_name_;
  static const ::std::string _default_bufferpacket_name_;
  ::std::string* data_;
  static const ::std::string _default_data_;
  ::std::string* pmid_;
  static const ::std::string _default_pmid_;
  ::std::string* public_key_;
  static const ::std::string _default_public_key_;
  ::std::string* signed_public_key_;
  static const ::std::string _default_signed_public_key_;
  ::std::string* signed_request_;
  static const ::std::string _default_signed_request_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static AddBPMessageRequest* default_instance_;
};
// -------------------------------------------------------------------

class AddBPMessageResponse : public ::google::protobuf::Message {
 public:
  AddBPMessageResponse();
  virtual ~AddBPMessageResponse();
  
  AddBPMessageResponse(const AddBPMessageResponse& from);
  
  inline AddBPMessageResponse& operator=(const AddBPMessageResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AddBPMessageResponse& default_instance();
  void Swap(AddBPMessageResponse* other);
  
  // implements Message ----------------------------------------------
  
  AddBPMessageResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AddBPMessageResponse& from);
  void MergeFrom(const AddBPMessageResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Reflection* GetReflection() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline ::google::protobuf::uint32 result() const;
  inline void set_result(::google::protobuf::uint32 value);
  
  // optional bytes pmid_id = 2;
  inline bool has_pmid_id() const;
  inline void clear_pmid_id();
  static const int kPmidIdFieldNumber = 2;
  inline const ::std::string& pmid_id() const;
  inline void set_pmid_id(const ::std::string& value);
  inline void set_pmid_id(const char* value);
  inline void set_pmid_id(const void* value, size_t size);
  inline ::std::string* mutable_pmid_id();
  
  // optional bytes public_key = 3;
  inline bool has_public_key() const;
  inline void clear_public_key();
  static const int kPublicKeyFieldNumber = 3;
  inline const ::std::string& public_key() const;
  inline void set_public_key(const ::std::string& value);
  inline void set_public_key(const char* value);
  inline void set_public_key(const void* value, size_t size);
  inline ::std::string* mutable_public_key();
  
  // optional bytes signed_public_key = 4;
  inline bool has_signed_public_key() const;
  inline void clear_signed_public_key();
  static const int kSignedPublicKeyFieldNumber = 4;
  inline const ::std::string& signed_public_key() const;
  inline void set_signed_public_key(const ::std::string& value);
  inline void set_signed_public_key(const char* value);
  inline void set_signed_public_key(const void* value, size_t size);
  inline ::std::string* mutable_signed_public_key();
  
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 result_;
  ::std::string* pmid_id_;
  static const ::std::string _default_pmid_id_;
  ::std::string* public_key_;
  static const ::std::string _default_public_key_;
  ::std::string* signed_public_key_;
  static const ::std::string _default_signed_public_key_;
  friend void  protobuf_AddDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_AssignDesc_maidsafe_5fservice_5fmessages_2eproto();
  friend void protobuf_ShutdownFile_maidsafe_5fservice_5fmessages_2eproto();
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static AddBPMessageResponse* default_instance_;
};
// ===================================================================


// ===================================================================


// ===================================================================

// SignedSize

// required uint64 data_size = 1;
inline bool SignedSize::has_data_size() const {
  return _has_bit(0);
}
inline void SignedSize::clear_data_size() {
  data_size_ = GOOGLE_ULONGLONG(0);
  _clear_bit(0);
}
inline ::google::protobuf::uint64 SignedSize::data_size() const {
  return data_size_;
}
inline void SignedSize::set_data_size(::google::protobuf::uint64 value) {
  _set_bit(0);
  data_size_ = value;
}

// required bytes signature = 2;
inline bool SignedSize::has_signature() const {
  return _has_bit(1);
}
inline void SignedSize::clear_signature() {
  if (signature_ != &_default_signature_) {
    signature_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& SignedSize::signature() const {
  return *signature_;
}
inline void SignedSize::set_signature(const ::std::string& value) {
  _set_bit(1);
  if (signature_ == &_default_signature_) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void SignedSize::set_signature(const char* value) {
  _set_bit(1);
  if (signature_ == &_default_signature_) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void SignedSize::set_signature(const void* value, size_t size) {
  _set_bit(1);
  if (signature_ == &_default_signature_) {
    signature_ = new ::std::string;
  }
  signature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignedSize::mutable_signature() {
  _set_bit(1);
  if (signature_ == &_default_signature_) {
    signature_ = new ::std::string;
  }
  return signature_;
}

// required bytes pmid = 3;
inline bool SignedSize::has_pmid() const {
  return _has_bit(2);
}
inline void SignedSize::clear_pmid() {
  if (pmid_ != &_default_pmid_) {
    pmid_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& SignedSize::pmid() const {
  return *pmid_;
}
inline void SignedSize::set_pmid(const ::std::string& value) {
  _set_bit(2);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(value);
}
inline void SignedSize::set_pmid(const char* value) {
  _set_bit(2);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(value);
}
inline void SignedSize::set_pmid(const void* value, size_t size) {
  _set_bit(2);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignedSize::mutable_pmid() {
  _set_bit(2);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  return pmid_;
}

// required bytes public_key = 4;
inline bool SignedSize::has_public_key() const {
  return _has_bit(3);
}
inline void SignedSize::clear_public_key() {
  if (public_key_ != &_default_public_key_) {
    public_key_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& SignedSize::public_key() const {
  return *public_key_;
}
inline void SignedSize::set_public_key(const ::std::string& value) {
  _set_bit(3);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void SignedSize::set_public_key(const char* value) {
  _set_bit(3);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void SignedSize::set_public_key(const void* value, size_t size) {
  _set_bit(3);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignedSize::mutable_public_key() {
  _set_bit(3);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  return public_key_;
}

// required bytes public_key_signature = 5;
inline bool SignedSize::has_public_key_signature() const {
  return _has_bit(4);
}
inline void SignedSize::clear_public_key_signature() {
  if (public_key_signature_ != &_default_public_key_signature_) {
    public_key_signature_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& SignedSize::public_key_signature() const {
  return *public_key_signature_;
}
inline void SignedSize::set_public_key_signature(const ::std::string& value) {
  _set_bit(4);
  if (public_key_signature_ == &_default_public_key_signature_) {
    public_key_signature_ = new ::std::string;
  }
  public_key_signature_->assign(value);
}
inline void SignedSize::set_public_key_signature(const char* value) {
  _set_bit(4);
  if (public_key_signature_ == &_default_public_key_signature_) {
    public_key_signature_ = new ::std::string;
  }
  public_key_signature_->assign(value);
}
inline void SignedSize::set_public_key_signature(const void* value, size_t size) {
  _set_bit(4);
  if (public_key_signature_ == &_default_public_key_signature_) {
    public_key_signature_ = new ::std::string;
  }
  public_key_signature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SignedSize::mutable_public_key_signature() {
  _set_bit(4);
  if (public_key_signature_ == &_default_public_key_signature_) {
    public_key_signature_ = new ::std::string;
  }
  return public_key_signature_;
}

// -------------------------------------------------------------------

// StoreContract_InnerContract

// required uint32 result = 1;
inline bool StoreContract_InnerContract::has_result() const {
  return _has_bit(0);
}
inline void StoreContract_InnerContract::clear_result() {
  result_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 StoreContract_InnerContract::result() const {
  return result_;
}
inline void StoreContract_InnerContract::set_result(::google::protobuf::uint32 value) {
  _set_bit(0);
  result_ = value;
}

// required .maidsafe.SignedSize signed_size = 2;
inline bool StoreContract_InnerContract::has_signed_size() const {
  return _has_bit(1);
}
inline void StoreContract_InnerContract::clear_signed_size() {
  if (signed_size_ != NULL) signed_size_->::maidsafe::SignedSize::Clear();
  _clear_bit(1);
}
inline const ::maidsafe::SignedSize& StoreContract_InnerContract::signed_size() const {
  return signed_size_ != NULL ? *signed_size_ : *default_instance_->signed_size_;
}
inline ::maidsafe::SignedSize* StoreContract_InnerContract::mutable_signed_size() {
  _set_bit(1);
  if (signed_size_ == NULL) signed_size_ = new ::maidsafe::SignedSize;
  return signed_size_;
}

// -------------------------------------------------------------------

// StoreContract

// required .maidsafe.StoreContract.InnerContract inner_contract = 1;
inline bool StoreContract::has_inner_contract() const {
  return _has_bit(0);
}
inline void StoreContract::clear_inner_contract() {
  if (inner_contract_ != NULL) inner_contract_->::maidsafe::StoreContract_InnerContract::Clear();
  _clear_bit(0);
}
inline const ::maidsafe::StoreContract_InnerContract& StoreContract::inner_contract() const {
  return inner_contract_ != NULL ? *inner_contract_ : *default_instance_->inner_contract_;
}
inline ::maidsafe::StoreContract_InnerContract* StoreContract::mutable_inner_contract() {
  _set_bit(0);
  if (inner_contract_ == NULL) inner_contract_ = new ::maidsafe::StoreContract_InnerContract;
  return inner_contract_;
}

// required bytes signature = 2;
inline bool StoreContract::has_signature() const {
  return _has_bit(1);
}
inline void StoreContract::clear_signature() {
  if (signature_ != &_default_signature_) {
    signature_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& StoreContract::signature() const {
  return *signature_;
}
inline void StoreContract::set_signature(const ::std::string& value) {
  _set_bit(1);
  if (signature_ == &_default_signature_) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void StoreContract::set_signature(const char* value) {
  _set_bit(1);
  if (signature_ == &_default_signature_) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void StoreContract::set_signature(const void* value, size_t size) {
  _set_bit(1);
  if (signature_ == &_default_signature_) {
    signature_ = new ::std::string;
  }
  signature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreContract::mutable_signature() {
  _set_bit(1);
  if (signature_ == &_default_signature_) {
    signature_ = new ::std::string;
  }
  return signature_;
}

// required bytes pmid = 3;
inline bool StoreContract::has_pmid() const {
  return _has_bit(2);
}
inline void StoreContract::clear_pmid() {
  if (pmid_ != &_default_pmid_) {
    pmid_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& StoreContract::pmid() const {
  return *pmid_;
}
inline void StoreContract::set_pmid(const ::std::string& value) {
  _set_bit(2);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(value);
}
inline void StoreContract::set_pmid(const char* value) {
  _set_bit(2);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(value);
}
inline void StoreContract::set_pmid(const void* value, size_t size) {
  _set_bit(2);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreContract::mutable_pmid() {
  _set_bit(2);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  return pmid_;
}

// required bytes public_key = 4;
inline bool StoreContract::has_public_key() const {
  return _has_bit(3);
}
inline void StoreContract::clear_public_key() {
  if (public_key_ != &_default_public_key_) {
    public_key_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& StoreContract::public_key() const {
  return *public_key_;
}
inline void StoreContract::set_public_key(const ::std::string& value) {
  _set_bit(3);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void StoreContract::set_public_key(const char* value) {
  _set_bit(3);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void StoreContract::set_public_key(const void* value, size_t size) {
  _set_bit(3);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreContract::mutable_public_key() {
  _set_bit(3);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  return public_key_;
}

// required bytes public_key_signature = 5;
inline bool StoreContract::has_public_key_signature() const {
  return _has_bit(4);
}
inline void StoreContract::clear_public_key_signature() {
  if (public_key_signature_ != &_default_public_key_signature_) {
    public_key_signature_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& StoreContract::public_key_signature() const {
  return *public_key_signature_;
}
inline void StoreContract::set_public_key_signature(const ::std::string& value) {
  _set_bit(4);
  if (public_key_signature_ == &_default_public_key_signature_) {
    public_key_signature_ = new ::std::string;
  }
  public_key_signature_->assign(value);
}
inline void StoreContract::set_public_key_signature(const char* value) {
  _set_bit(4);
  if (public_key_signature_ == &_default_public_key_signature_) {
    public_key_signature_ = new ::std::string;
  }
  public_key_signature_->assign(value);
}
inline void StoreContract::set_public_key_signature(const void* value, size_t size) {
  _set_bit(4);
  if (public_key_signature_ == &_default_public_key_signature_) {
    public_key_signature_ = new ::std::string;
  }
  public_key_signature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreContract::mutable_public_key_signature() {
  _set_bit(4);
  if (public_key_signature_ == &_default_public_key_signature_) {
    public_key_signature_ = new ::std::string;
  }
  return public_key_signature_;
}

// -------------------------------------------------------------------

// StorePrepRequest

// required bytes chunkname = 1;
inline bool StorePrepRequest::has_chunkname() const {
  return _has_bit(0);
}
inline void StorePrepRequest::clear_chunkname() {
  if (chunkname_ != &_default_chunkname_) {
    chunkname_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& StorePrepRequest::chunkname() const {
  return *chunkname_;
}
inline void StorePrepRequest::set_chunkname(const ::std::string& value) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(value);
}
inline void StorePrepRequest::set_chunkname(const char* value) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(value);
}
inline void StorePrepRequest::set_chunkname(const void* value, size_t size) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StorePrepRequest::mutable_chunkname() {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  return chunkname_;
}

// required .maidsafe.SignedSize signed_size = 2;
inline bool StorePrepRequest::has_signed_size() const {
  return _has_bit(1);
}
inline void StorePrepRequest::clear_signed_size() {
  if (signed_size_ != NULL) signed_size_->::maidsafe::SignedSize::Clear();
  _clear_bit(1);
}
inline const ::maidsafe::SignedSize& StorePrepRequest::signed_size() const {
  return signed_size_ != NULL ? *signed_size_ : *default_instance_->signed_size_;
}
inline ::maidsafe::SignedSize* StorePrepRequest::mutable_signed_size() {
  _set_bit(1);
  if (signed_size_ == NULL) signed_size_ = new ::maidsafe::SignedSize;
  return signed_size_;
}

// required bytes request_signature = 3;
inline bool StorePrepRequest::has_request_signature() const {
  return _has_bit(2);
}
inline void StorePrepRequest::clear_request_signature() {
  if (request_signature_ != &_default_request_signature_) {
    request_signature_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& StorePrepRequest::request_signature() const {
  return *request_signature_;
}
inline void StorePrepRequest::set_request_signature(const ::std::string& value) {
  _set_bit(2);
  if (request_signature_ == &_default_request_signature_) {
    request_signature_ = new ::std::string;
  }
  request_signature_->assign(value);
}
inline void StorePrepRequest::set_request_signature(const char* value) {
  _set_bit(2);
  if (request_signature_ == &_default_request_signature_) {
    request_signature_ = new ::std::string;
  }
  request_signature_->assign(value);
}
inline void StorePrepRequest::set_request_signature(const void* value, size_t size) {
  _set_bit(2);
  if (request_signature_ == &_default_request_signature_) {
    request_signature_ = new ::std::string;
  }
  request_signature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StorePrepRequest::mutable_request_signature() {
  _set_bit(2);
  if (request_signature_ == &_default_request_signature_) {
    request_signature_ = new ::std::string;
  }
  return request_signature_;
}

// -------------------------------------------------------------------

// StorePrepResponse

// required .maidsafe.StoreContract store_contract = 1;
inline bool StorePrepResponse::has_store_contract() const {
  return _has_bit(0);
}
inline void StorePrepResponse::clear_store_contract() {
  if (store_contract_ != NULL) store_contract_->::maidsafe::StoreContract::Clear();
  _clear_bit(0);
}
inline const ::maidsafe::StoreContract& StorePrepResponse::store_contract() const {
  return store_contract_ != NULL ? *store_contract_ : *default_instance_->store_contract_;
}
inline ::maidsafe::StoreContract* StorePrepResponse::mutable_store_contract() {
  _set_bit(0);
  if (store_contract_ == NULL) store_contract_ = new ::maidsafe::StoreContract;
  return store_contract_;
}

// required bytes response_signature = 2;
inline bool StorePrepResponse::has_response_signature() const {
  return _has_bit(1);
}
inline void StorePrepResponse::clear_response_signature() {
  if (response_signature_ != &_default_response_signature_) {
    response_signature_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& StorePrepResponse::response_signature() const {
  return *response_signature_;
}
inline void StorePrepResponse::set_response_signature(const ::std::string& value) {
  _set_bit(1);
  if (response_signature_ == &_default_response_signature_) {
    response_signature_ = new ::std::string;
  }
  response_signature_->assign(value);
}
inline void StorePrepResponse::set_response_signature(const char* value) {
  _set_bit(1);
  if (response_signature_ == &_default_response_signature_) {
    response_signature_ = new ::std::string;
  }
  response_signature_->assign(value);
}
inline void StorePrepResponse::set_response_signature(const void* value, size_t size) {
  _set_bit(1);
  if (response_signature_ == &_default_response_signature_) {
    response_signature_ = new ::std::string;
  }
  response_signature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StorePrepResponse::mutable_response_signature() {
  _set_bit(1);
  if (response_signature_ == &_default_response_signature_) {
    response_signature_ = new ::std::string;
  }
  return response_signature_;
}

// -------------------------------------------------------------------

// StoreChunkRequest

// required bytes chunkname = 1;
inline bool StoreChunkRequest::has_chunkname() const {
  return _has_bit(0);
}
inline void StoreChunkRequest::clear_chunkname() {
  if (chunkname_ != &_default_chunkname_) {
    chunkname_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& StoreChunkRequest::chunkname() const {
  return *chunkname_;
}
inline void StoreChunkRequest::set_chunkname(const ::std::string& value) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(value);
}
inline void StoreChunkRequest::set_chunkname(const char* value) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(value);
}
inline void StoreChunkRequest::set_chunkname(const void* value, size_t size) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreChunkRequest::mutable_chunkname() {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  return chunkname_;
}

// required bytes data = 2;
inline bool StoreChunkRequest::has_data() const {
  return _has_bit(1);
}
inline void StoreChunkRequest::clear_data() {
  if (data_ != &_default_data_) {
    data_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& StoreChunkRequest::data() const {
  return *data_;
}
inline void StoreChunkRequest::set_data(const ::std::string& value) {
  _set_bit(1);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void StoreChunkRequest::set_data(const char* value) {
  _set_bit(1);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void StoreChunkRequest::set_data(const void* value, size_t size) {
  _set_bit(1);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreChunkRequest::mutable_data() {
  _set_bit(1);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  return data_;
}

// required bytes pmid = 3;
inline bool StoreChunkRequest::has_pmid() const {
  return _has_bit(2);
}
inline void StoreChunkRequest::clear_pmid() {
  if (pmid_ != &_default_pmid_) {
    pmid_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& StoreChunkRequest::pmid() const {
  return *pmid_;
}
inline void StoreChunkRequest::set_pmid(const ::std::string& value) {
  _set_bit(2);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(value);
}
inline void StoreChunkRequest::set_pmid(const char* value) {
  _set_bit(2);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(value);
}
inline void StoreChunkRequest::set_pmid(const void* value, size_t size) {
  _set_bit(2);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreChunkRequest::mutable_pmid() {
  _set_bit(2);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  return pmid_;
}

// required bytes public_key = 4;
inline bool StoreChunkRequest::has_public_key() const {
  return _has_bit(3);
}
inline void StoreChunkRequest::clear_public_key() {
  if (public_key_ != &_default_public_key_) {
    public_key_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& StoreChunkRequest::public_key() const {
  return *public_key_;
}
inline void StoreChunkRequest::set_public_key(const ::std::string& value) {
  _set_bit(3);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void StoreChunkRequest::set_public_key(const char* value) {
  _set_bit(3);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void StoreChunkRequest::set_public_key(const void* value, size_t size) {
  _set_bit(3);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreChunkRequest::mutable_public_key() {
  _set_bit(3);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  return public_key_;
}

// required bytes public_key_signature = 5;
inline bool StoreChunkRequest::has_public_key_signature() const {
  return _has_bit(4);
}
inline void StoreChunkRequest::clear_public_key_signature() {
  if (public_key_signature_ != &_default_public_key_signature_) {
    public_key_signature_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& StoreChunkRequest::public_key_signature() const {
  return *public_key_signature_;
}
inline void StoreChunkRequest::set_public_key_signature(const ::std::string& value) {
  _set_bit(4);
  if (public_key_signature_ == &_default_public_key_signature_) {
    public_key_signature_ = new ::std::string;
  }
  public_key_signature_->assign(value);
}
inline void StoreChunkRequest::set_public_key_signature(const char* value) {
  _set_bit(4);
  if (public_key_signature_ == &_default_public_key_signature_) {
    public_key_signature_ = new ::std::string;
  }
  public_key_signature_->assign(value);
}
inline void StoreChunkRequest::set_public_key_signature(const void* value, size_t size) {
  _set_bit(4);
  if (public_key_signature_ == &_default_public_key_signature_) {
    public_key_signature_ = new ::std::string;
  }
  public_key_signature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreChunkRequest::mutable_public_key_signature() {
  _set_bit(4);
  if (public_key_signature_ == &_default_public_key_signature_) {
    public_key_signature_ = new ::std::string;
  }
  return public_key_signature_;
}

// required bytes request_signature = 6;
inline bool StoreChunkRequest::has_request_signature() const {
  return _has_bit(5);
}
inline void StoreChunkRequest::clear_request_signature() {
  if (request_signature_ != &_default_request_signature_) {
    request_signature_->clear();
  }
  _clear_bit(5);
}
inline const ::std::string& StoreChunkRequest::request_signature() const {
  return *request_signature_;
}
inline void StoreChunkRequest::set_request_signature(const ::std::string& value) {
  _set_bit(5);
  if (request_signature_ == &_default_request_signature_) {
    request_signature_ = new ::std::string;
  }
  request_signature_->assign(value);
}
inline void StoreChunkRequest::set_request_signature(const char* value) {
  _set_bit(5);
  if (request_signature_ == &_default_request_signature_) {
    request_signature_ = new ::std::string;
  }
  request_signature_->assign(value);
}
inline void StoreChunkRequest::set_request_signature(const void* value, size_t size) {
  _set_bit(5);
  if (request_signature_ == &_default_request_signature_) {
    request_signature_ = new ::std::string;
  }
  request_signature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreChunkRequest::mutable_request_signature() {
  _set_bit(5);
  if (request_signature_ == &_default_request_signature_) {
    request_signature_ = new ::std::string;
  }
  return request_signature_;
}

// required int32 data_type = 7;
inline bool StoreChunkRequest::has_data_type() const {
  return _has_bit(6);
}
inline void StoreChunkRequest::clear_data_type() {
  data_type_ = 0;
  _clear_bit(6);
}
inline ::google::protobuf::int32 StoreChunkRequest::data_type() const {
  return data_type_;
}
inline void StoreChunkRequest::set_data_type(::google::protobuf::int32 value) {
  _set_bit(6);
  data_type_ = value;
}

// optional uint32 offset = 8;
inline bool StoreChunkRequest::has_offset() const {
  return _has_bit(7);
}
inline void StoreChunkRequest::clear_offset() {
  offset_ = 0u;
  _clear_bit(7);
}
inline ::google::protobuf::uint32 StoreChunkRequest::offset() const {
  return offset_;
}
inline void StoreChunkRequest::set_offset(::google::protobuf::uint32 value) {
  _set_bit(7);
  offset_ = value;
}

// optional uint32 chunklet_size = 9;
inline bool StoreChunkRequest::has_chunklet_size() const {
  return _has_bit(8);
}
inline void StoreChunkRequest::clear_chunklet_size() {
  chunklet_size_ = 0u;
  _clear_bit(8);
}
inline ::google::protobuf::uint32 StoreChunkRequest::chunklet_size() const {
  return chunklet_size_;
}
inline void StoreChunkRequest::set_chunklet_size(::google::protobuf::uint32 value) {
  _set_bit(8);
  chunklet_size_ = value;
}

// -------------------------------------------------------------------

// StoreChunkResponse

// required uint32 result = 1;
inline bool StoreChunkResponse::has_result() const {
  return _has_bit(0);
}
inline void StoreChunkResponse::clear_result() {
  result_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 StoreChunkResponse::result() const {
  return result_;
}
inline void StoreChunkResponse::set_result(::google::protobuf::uint32 value) {
  _set_bit(0);
  result_ = value;
}

// optional bytes pmid = 2;
inline bool StoreChunkResponse::has_pmid() const {
  return _has_bit(1);
}
inline void StoreChunkResponse::clear_pmid() {
  if (pmid_ != &_default_pmid_) {
    pmid_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& StoreChunkResponse::pmid() const {
  return *pmid_;
}
inline void StoreChunkResponse::set_pmid(const ::std::string& value) {
  _set_bit(1);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(value);
}
inline void StoreChunkResponse::set_pmid(const char* value) {
  _set_bit(1);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(value);
}
inline void StoreChunkResponse::set_pmid(const void* value, size_t size) {
  _set_bit(1);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StoreChunkResponse::mutable_pmid() {
  _set_bit(1);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  return pmid_;
}

// -------------------------------------------------------------------

// StorePacketRequest

// required bytes packetname = 1;
inline bool StorePacketRequest::has_packetname() const {
  return _has_bit(0);
}
inline void StorePacketRequest::clear_packetname() {
  if (packetname_ != &_default_packetname_) {
    packetname_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& StorePacketRequest::packetname() const {
  return *packetname_;
}
inline void StorePacketRequest::set_packetname(const ::std::string& value) {
  _set_bit(0);
  if (packetname_ == &_default_packetname_) {
    packetname_ = new ::std::string;
  }
  packetname_->assign(value);
}
inline void StorePacketRequest::set_packetname(const char* value) {
  _set_bit(0);
  if (packetname_ == &_default_packetname_) {
    packetname_ = new ::std::string;
  }
  packetname_->assign(value);
}
inline void StorePacketRequest::set_packetname(const void* value, size_t size) {
  _set_bit(0);
  if (packetname_ == &_default_packetname_) {
    packetname_ = new ::std::string;
  }
  packetname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StorePacketRequest::mutable_packetname() {
  _set_bit(0);
  if (packetname_ == &_default_packetname_) {
    packetname_ = new ::std::string;
  }
  return packetname_;
}

// repeated .maidsafe.GenericPacket signed_data = 2;
inline int StorePacketRequest::signed_data_size() const {
  return signed_data_.size();
}
inline void StorePacketRequest::clear_signed_data() {
  signed_data_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::maidsafe::GenericPacket >&
StorePacketRequest::signed_data() const {
  return signed_data_;
}
inline ::google::protobuf::RepeatedPtrField< ::maidsafe::GenericPacket >*
StorePacketRequest::mutable_signed_data() {
  return &signed_data_;
}
inline const ::maidsafe::GenericPacket& StorePacketRequest::signed_data(int index) const {
  return signed_data_.Get(index);
}
inline ::maidsafe::GenericPacket* StorePacketRequest::mutable_signed_data(int index) {
  return signed_data_.Mutable(index);
}
inline ::maidsafe::GenericPacket* StorePacketRequest::add_signed_data() {
  return signed_data_.Add();
}

// optional bytes key_id = 3;
inline bool StorePacketRequest::has_key_id() const {
  return _has_bit(2);
}
inline void StorePacketRequest::clear_key_id() {
  if (key_id_ != &_default_key_id_) {
    key_id_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& StorePacketRequest::key_id() const {
  return *key_id_;
}
inline void StorePacketRequest::set_key_id(const ::std::string& value) {
  _set_bit(2);
  if (key_id_ == &_default_key_id_) {
    key_id_ = new ::std::string;
  }
  key_id_->assign(value);
}
inline void StorePacketRequest::set_key_id(const char* value) {
  _set_bit(2);
  if (key_id_ == &_default_key_id_) {
    key_id_ = new ::std::string;
  }
  key_id_->assign(value);
}
inline void StorePacketRequest::set_key_id(const void* value, size_t size) {
  _set_bit(2);
  if (key_id_ == &_default_key_id_) {
    key_id_ = new ::std::string;
  }
  key_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StorePacketRequest::mutable_key_id() {
  _set_bit(2);
  if (key_id_ == &_default_key_id_) {
    key_id_ = new ::std::string;
  }
  return key_id_;
}

// optional bytes public_key = 4;
inline bool StorePacketRequest::has_public_key() const {
  return _has_bit(3);
}
inline void StorePacketRequest::clear_public_key() {
  if (public_key_ != &_default_public_key_) {
    public_key_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& StorePacketRequest::public_key() const {
  return *public_key_;
}
inline void StorePacketRequest::set_public_key(const ::std::string& value) {
  _set_bit(3);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void StorePacketRequest::set_public_key(const char* value) {
  _set_bit(3);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void StorePacketRequest::set_public_key(const void* value, size_t size) {
  _set_bit(3);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StorePacketRequest::mutable_public_key() {
  _set_bit(3);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  return public_key_;
}

// optional bytes public_key_signature = 5;
inline bool StorePacketRequest::has_public_key_signature() const {
  return _has_bit(4);
}
inline void StorePacketRequest::clear_public_key_signature() {
  if (public_key_signature_ != &_default_public_key_signature_) {
    public_key_signature_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& StorePacketRequest::public_key_signature() const {
  return *public_key_signature_;
}
inline void StorePacketRequest::set_public_key_signature(const ::std::string& value) {
  _set_bit(4);
  if (public_key_signature_ == &_default_public_key_signature_) {
    public_key_signature_ = new ::std::string;
  }
  public_key_signature_->assign(value);
}
inline void StorePacketRequest::set_public_key_signature(const char* value) {
  _set_bit(4);
  if (public_key_signature_ == &_default_public_key_signature_) {
    public_key_signature_ = new ::std::string;
  }
  public_key_signature_->assign(value);
}
inline void StorePacketRequest::set_public_key_signature(const void* value, size_t size) {
  _set_bit(4);
  if (public_key_signature_ == &_default_public_key_signature_) {
    public_key_signature_ = new ::std::string;
  }
  public_key_signature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StorePacketRequest::mutable_public_key_signature() {
  _set_bit(4);
  if (public_key_signature_ == &_default_public_key_signature_) {
    public_key_signature_ = new ::std::string;
  }
  return public_key_signature_;
}

// optional bytes request_signature = 6;
inline bool StorePacketRequest::has_request_signature() const {
  return _has_bit(5);
}
inline void StorePacketRequest::clear_request_signature() {
  if (request_signature_ != &_default_request_signature_) {
    request_signature_->clear();
  }
  _clear_bit(5);
}
inline const ::std::string& StorePacketRequest::request_signature() const {
  return *request_signature_;
}
inline void StorePacketRequest::set_request_signature(const ::std::string& value) {
  _set_bit(5);
  if (request_signature_ == &_default_request_signature_) {
    request_signature_ = new ::std::string;
  }
  request_signature_->assign(value);
}
inline void StorePacketRequest::set_request_signature(const char* value) {
  _set_bit(5);
  if (request_signature_ == &_default_request_signature_) {
    request_signature_ = new ::std::string;
  }
  request_signature_->assign(value);
}
inline void StorePacketRequest::set_request_signature(const void* value, size_t size) {
  _set_bit(5);
  if (request_signature_ == &_default_request_signature_) {
    request_signature_ = new ::std::string;
  }
  request_signature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StorePacketRequest::mutable_request_signature() {
  _set_bit(5);
  if (request_signature_ == &_default_request_signature_) {
    request_signature_ = new ::std::string;
  }
  return request_signature_;
}

// required int32 data_type = 7;
inline bool StorePacketRequest::has_data_type() const {
  return _has_bit(6);
}
inline void StorePacketRequest::clear_data_type() {
  data_type_ = 0;
  _clear_bit(6);
}
inline ::google::protobuf::int32 StorePacketRequest::data_type() const {
  return data_type_;
}
inline void StorePacketRequest::set_data_type(::google::protobuf::int32 value) {
  _set_bit(6);
  data_type_ = value;
}

// required bool append = 8;
inline bool StorePacketRequest::has_append() const {
  return _has_bit(7);
}
inline void StorePacketRequest::clear_append() {
  append_ = false;
  _clear_bit(7);
}
inline bool StorePacketRequest::append() const {
  return append_;
}
inline void StorePacketRequest::set_append(bool value) {
  _set_bit(7);
  append_ = value;
}

// -------------------------------------------------------------------

// StorePacketResponse

// required uint32 result = 1;
inline bool StorePacketResponse::has_result() const {
  return _has_bit(0);
}
inline void StorePacketResponse::clear_result() {
  result_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 StorePacketResponse::result() const {
  return result_;
}
inline void StorePacketResponse::set_result(::google::protobuf::uint32 value) {
  _set_bit(0);
  result_ = value;
}

// optional bytes pmid = 2;
inline bool StorePacketResponse::has_pmid() const {
  return _has_bit(1);
}
inline void StorePacketResponse::clear_pmid() {
  if (pmid_ != &_default_pmid_) {
    pmid_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& StorePacketResponse::pmid() const {
  return *pmid_;
}
inline void StorePacketResponse::set_pmid(const ::std::string& value) {
  _set_bit(1);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(value);
}
inline void StorePacketResponse::set_pmid(const char* value) {
  _set_bit(1);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(value);
}
inline void StorePacketResponse::set_pmid(const void* value, size_t size) {
  _set_bit(1);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StorePacketResponse::mutable_pmid() {
  _set_bit(1);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  return pmid_;
}

// optional bytes public_key = 3;
inline bool StorePacketResponse::has_public_key() const {
  return _has_bit(2);
}
inline void StorePacketResponse::clear_public_key() {
  if (public_key_ != &_default_public_key_) {
    public_key_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& StorePacketResponse::public_key() const {
  return *public_key_;
}
inline void StorePacketResponse::set_public_key(const ::std::string& value) {
  _set_bit(2);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void StorePacketResponse::set_public_key(const char* value) {
  _set_bit(2);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void StorePacketResponse::set_public_key(const void* value, size_t size) {
  _set_bit(2);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StorePacketResponse::mutable_public_key() {
  _set_bit(2);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  return public_key_;
}

// optional bytes public_key_signature = 4;
inline bool StorePacketResponse::has_public_key_signature() const {
  return _has_bit(3);
}
inline void StorePacketResponse::clear_public_key_signature() {
  if (public_key_signature_ != &_default_public_key_signature_) {
    public_key_signature_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& StorePacketResponse::public_key_signature() const {
  return *public_key_signature_;
}
inline void StorePacketResponse::set_public_key_signature(const ::std::string& value) {
  _set_bit(3);
  if (public_key_signature_ == &_default_public_key_signature_) {
    public_key_signature_ = new ::std::string;
  }
  public_key_signature_->assign(value);
}
inline void StorePacketResponse::set_public_key_signature(const char* value) {
  _set_bit(3);
  if (public_key_signature_ == &_default_public_key_signature_) {
    public_key_signature_ = new ::std::string;
  }
  public_key_signature_->assign(value);
}
inline void StorePacketResponse::set_public_key_signature(const void* value, size_t size) {
  _set_bit(3);
  if (public_key_signature_ == &_default_public_key_signature_) {
    public_key_signature_ = new ::std::string;
  }
  public_key_signature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StorePacketResponse::mutable_public_key_signature() {
  _set_bit(3);
  if (public_key_signature_ == &_default_public_key_signature_) {
    public_key_signature_ = new ::std::string;
  }
  return public_key_signature_;
}

// optional bytes response_signature = 5;
inline bool StorePacketResponse::has_response_signature() const {
  return _has_bit(4);
}
inline void StorePacketResponse::clear_response_signature() {
  if (response_signature_ != &_default_response_signature_) {
    response_signature_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& StorePacketResponse::response_signature() const {
  return *response_signature_;
}
inline void StorePacketResponse::set_response_signature(const ::std::string& value) {
  _set_bit(4);
  if (response_signature_ == &_default_response_signature_) {
    response_signature_ = new ::std::string;
  }
  response_signature_->assign(value);
}
inline void StorePacketResponse::set_response_signature(const char* value) {
  _set_bit(4);
  if (response_signature_ == &_default_response_signature_) {
    response_signature_ = new ::std::string;
  }
  response_signature_->assign(value);
}
inline void StorePacketResponse::set_response_signature(const void* value, size_t size) {
  _set_bit(4);
  if (response_signature_ == &_default_response_signature_) {
    response_signature_ = new ::std::string;
  }
  response_signature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StorePacketResponse::mutable_response_signature() {
  _set_bit(4);
  if (response_signature_ == &_default_response_signature_) {
    response_signature_ = new ::std::string;
  }
  return response_signature_;
}

// optional bytes checksum = 6;
inline bool StorePacketResponse::has_checksum() const {
  return _has_bit(5);
}
inline void StorePacketResponse::clear_checksum() {
  if (checksum_ != &_default_checksum_) {
    checksum_->clear();
  }
  _clear_bit(5);
}
inline const ::std::string& StorePacketResponse::checksum() const {
  return *checksum_;
}
inline void StorePacketResponse::set_checksum(const ::std::string& value) {
  _set_bit(5);
  if (checksum_ == &_default_checksum_) {
    checksum_ = new ::std::string;
  }
  checksum_->assign(value);
}
inline void StorePacketResponse::set_checksum(const char* value) {
  _set_bit(5);
  if (checksum_ == &_default_checksum_) {
    checksum_ = new ::std::string;
  }
  checksum_->assign(value);
}
inline void StorePacketResponse::set_checksum(const void* value, size_t size) {
  _set_bit(5);
  if (checksum_ == &_default_checksum_) {
    checksum_ = new ::std::string;
  }
  checksum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StorePacketResponse::mutable_checksum() {
  _set_bit(5);
  if (checksum_ == &_default_checksum_) {
    checksum_ = new ::std::string;
  }
  return checksum_;
}

// -------------------------------------------------------------------

// AddToWatchListRequest

// required bytes chunkname = 1;
inline bool AddToWatchListRequest::has_chunkname() const {
  return _has_bit(0);
}
inline void AddToWatchListRequest::clear_chunkname() {
  if (chunkname_ != &_default_chunkname_) {
    chunkname_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& AddToWatchListRequest::chunkname() const {
  return *chunkname_;
}
inline void AddToWatchListRequest::set_chunkname(const ::std::string& value) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(value);
}
inline void AddToWatchListRequest::set_chunkname(const char* value) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(value);
}
inline void AddToWatchListRequest::set_chunkname(const void* value, size_t size) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AddToWatchListRequest::mutable_chunkname() {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  return chunkname_;
}

// required .maidsafe.SignedSize signed_size = 2;
inline bool AddToWatchListRequest::has_signed_size() const {
  return _has_bit(1);
}
inline void AddToWatchListRequest::clear_signed_size() {
  if (signed_size_ != NULL) signed_size_->::maidsafe::SignedSize::Clear();
  _clear_bit(1);
}
inline const ::maidsafe::SignedSize& AddToWatchListRequest::signed_size() const {
  return signed_size_ != NULL ? *signed_size_ : *default_instance_->signed_size_;
}
inline ::maidsafe::SignedSize* AddToWatchListRequest::mutable_signed_size() {
  _set_bit(1);
  if (signed_size_ == NULL) signed_size_ = new ::maidsafe::SignedSize;
  return signed_size_;
}

// required bytes request_signature = 4;
inline bool AddToWatchListRequest::has_request_signature() const {
  return _has_bit(2);
}
inline void AddToWatchListRequest::clear_request_signature() {
  if (request_signature_ != &_default_request_signature_) {
    request_signature_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& AddToWatchListRequest::request_signature() const {
  return *request_signature_;
}
inline void AddToWatchListRequest::set_request_signature(const ::std::string& value) {
  _set_bit(2);
  if (request_signature_ == &_default_request_signature_) {
    request_signature_ = new ::std::string;
  }
  request_signature_->assign(value);
}
inline void AddToWatchListRequest::set_request_signature(const char* value) {
  _set_bit(2);
  if (request_signature_ == &_default_request_signature_) {
    request_signature_ = new ::std::string;
  }
  request_signature_->assign(value);
}
inline void AddToWatchListRequest::set_request_signature(const void* value, size_t size) {
  _set_bit(2);
  if (request_signature_ == &_default_request_signature_) {
    request_signature_ = new ::std::string;
  }
  request_signature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AddToWatchListRequest::mutable_request_signature() {
  _set_bit(2);
  if (request_signature_ == &_default_request_signature_) {
    request_signature_ = new ::std::string;
  }
  return request_signature_;
}

// -------------------------------------------------------------------

// AddToWatchListResponse

// required uint32 result = 1;
inline bool AddToWatchListResponse::has_result() const {
  return _has_bit(0);
}
inline void AddToWatchListResponse::clear_result() {
  result_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 AddToWatchListResponse::result() const {
  return result_;
}
inline void AddToWatchListResponse::set_result(::google::protobuf::uint32 value) {
  _set_bit(0);
  result_ = value;
}

// optional bytes pmid = 2;
inline bool AddToWatchListResponse::has_pmid() const {
  return _has_bit(1);
}
inline void AddToWatchListResponse::clear_pmid() {
  if (pmid_ != &_default_pmid_) {
    pmid_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& AddToWatchListResponse::pmid() const {
  return *pmid_;
}
inline void AddToWatchListResponse::set_pmid(const ::std::string& value) {
  _set_bit(1);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(value);
}
inline void AddToWatchListResponse::set_pmid(const char* value) {
  _set_bit(1);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(value);
}
inline void AddToWatchListResponse::set_pmid(const void* value, size_t size) {
  _set_bit(1);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AddToWatchListResponse::mutable_pmid() {
  _set_bit(1);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  return pmid_;
}

// optional uint32 upload_count = 3;
inline bool AddToWatchListResponse::has_upload_count() const {
  return _has_bit(2);
}
inline void AddToWatchListResponse::clear_upload_count() {
  upload_count_ = 0u;
  _clear_bit(2);
}
inline ::google::protobuf::uint32 AddToWatchListResponse::upload_count() const {
  return upload_count_;
}
inline void AddToWatchListResponse::set_upload_count(::google::protobuf::uint32 value) {
  _set_bit(2);
  upload_count_ = value;
}

// -------------------------------------------------------------------

// RemoveFromWatchListRequest

// required bytes chunkname = 1;
inline bool RemoveFromWatchListRequest::has_chunkname() const {
  return _has_bit(0);
}
inline void RemoveFromWatchListRequest::clear_chunkname() {
  if (chunkname_ != &_default_chunkname_) {
    chunkname_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& RemoveFromWatchListRequest::chunkname() const {
  return *chunkname_;
}
inline void RemoveFromWatchListRequest::set_chunkname(const ::std::string& value) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(value);
}
inline void RemoveFromWatchListRequest::set_chunkname(const char* value) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(value);
}
inline void RemoveFromWatchListRequest::set_chunkname(const void* value, size_t size) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RemoveFromWatchListRequest::mutable_chunkname() {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  return chunkname_;
}

// required bytes pmid = 2;
inline bool RemoveFromWatchListRequest::has_pmid() const {
  return _has_bit(1);
}
inline void RemoveFromWatchListRequest::clear_pmid() {
  if (pmid_ != &_default_pmid_) {
    pmid_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& RemoveFromWatchListRequest::pmid() const {
  return *pmid_;
}
inline void RemoveFromWatchListRequest::set_pmid(const ::std::string& value) {
  _set_bit(1);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(value);
}
inline void RemoveFromWatchListRequest::set_pmid(const char* value) {
  _set_bit(1);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(value);
}
inline void RemoveFromWatchListRequest::set_pmid(const void* value, size_t size) {
  _set_bit(1);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RemoveFromWatchListRequest::mutable_pmid() {
  _set_bit(1);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  return pmid_;
}

// required bytes public_key = 3;
inline bool RemoveFromWatchListRequest::has_public_key() const {
  return _has_bit(2);
}
inline void RemoveFromWatchListRequest::clear_public_key() {
  if (public_key_ != &_default_public_key_) {
    public_key_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& RemoveFromWatchListRequest::public_key() const {
  return *public_key_;
}
inline void RemoveFromWatchListRequest::set_public_key(const ::std::string& value) {
  _set_bit(2);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void RemoveFromWatchListRequest::set_public_key(const char* value) {
  _set_bit(2);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void RemoveFromWatchListRequest::set_public_key(const void* value, size_t size) {
  _set_bit(2);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RemoveFromWatchListRequest::mutable_public_key() {
  _set_bit(2);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  return public_key_;
}

// required bytes public_key_signature = 4;
inline bool RemoveFromWatchListRequest::has_public_key_signature() const {
  return _has_bit(3);
}
inline void RemoveFromWatchListRequest::clear_public_key_signature() {
  if (public_key_signature_ != &_default_public_key_signature_) {
    public_key_signature_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& RemoveFromWatchListRequest::public_key_signature() const {
  return *public_key_signature_;
}
inline void RemoveFromWatchListRequest::set_public_key_signature(const ::std::string& value) {
  _set_bit(3);
  if (public_key_signature_ == &_default_public_key_signature_) {
    public_key_signature_ = new ::std::string;
  }
  public_key_signature_->assign(value);
}
inline void RemoveFromWatchListRequest::set_public_key_signature(const char* value) {
  _set_bit(3);
  if (public_key_signature_ == &_default_public_key_signature_) {
    public_key_signature_ = new ::std::string;
  }
  public_key_signature_->assign(value);
}
inline void RemoveFromWatchListRequest::set_public_key_signature(const void* value, size_t size) {
  _set_bit(3);
  if (public_key_signature_ == &_default_public_key_signature_) {
    public_key_signature_ = new ::std::string;
  }
  public_key_signature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RemoveFromWatchListRequest::mutable_public_key_signature() {
  _set_bit(3);
  if (public_key_signature_ == &_default_public_key_signature_) {
    public_key_signature_ = new ::std::string;
  }
  return public_key_signature_;
}

// required bytes request_signature = 5;
inline bool RemoveFromWatchListRequest::has_request_signature() const {
  return _has_bit(4);
}
inline void RemoveFromWatchListRequest::clear_request_signature() {
  if (request_signature_ != &_default_request_signature_) {
    request_signature_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& RemoveFromWatchListRequest::request_signature() const {
  return *request_signature_;
}
inline void RemoveFromWatchListRequest::set_request_signature(const ::std::string& value) {
  _set_bit(4);
  if (request_signature_ == &_default_request_signature_) {
    request_signature_ = new ::std::string;
  }
  request_signature_->assign(value);
}
inline void RemoveFromWatchListRequest::set_request_signature(const char* value) {
  _set_bit(4);
  if (request_signature_ == &_default_request_signature_) {
    request_signature_ = new ::std::string;
  }
  request_signature_->assign(value);
}
inline void RemoveFromWatchListRequest::set_request_signature(const void* value, size_t size) {
  _set_bit(4);
  if (request_signature_ == &_default_request_signature_) {
    request_signature_ = new ::std::string;
  }
  request_signature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RemoveFromWatchListRequest::mutable_request_signature() {
  _set_bit(4);
  if (request_signature_ == &_default_request_signature_) {
    request_signature_ = new ::std::string;
  }
  return request_signature_;
}

// -------------------------------------------------------------------

// RemoveFromWatchListResponse

// required uint32 result = 1;
inline bool RemoveFromWatchListResponse::has_result() const {
  return _has_bit(0);
}
inline void RemoveFromWatchListResponse::clear_result() {
  result_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 RemoveFromWatchListResponse::result() const {
  return result_;
}
inline void RemoveFromWatchListResponse::set_result(::google::protobuf::uint32 value) {
  _set_bit(0);
  result_ = value;
}

// optional bytes pmid = 2;
inline bool RemoveFromWatchListResponse::has_pmid() const {
  return _has_bit(1);
}
inline void RemoveFromWatchListResponse::clear_pmid() {
  if (pmid_ != &_default_pmid_) {
    pmid_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& RemoveFromWatchListResponse::pmid() const {
  return *pmid_;
}
inline void RemoveFromWatchListResponse::set_pmid(const ::std::string& value) {
  _set_bit(1);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(value);
}
inline void RemoveFromWatchListResponse::set_pmid(const char* value) {
  _set_bit(1);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(value);
}
inline void RemoveFromWatchListResponse::set_pmid(const void* value, size_t size) {
  _set_bit(1);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RemoveFromWatchListResponse::mutable_pmid() {
  _set_bit(1);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  return pmid_;
}

// -------------------------------------------------------------------

// AddToReferenceListRequest

// required bytes chunkname = 1;
inline bool AddToReferenceListRequest::has_chunkname() const {
  return _has_bit(0);
}
inline void AddToReferenceListRequest::clear_chunkname() {
  if (chunkname_ != &_default_chunkname_) {
    chunkname_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& AddToReferenceListRequest::chunkname() const {
  return *chunkname_;
}
inline void AddToReferenceListRequest::set_chunkname(const ::std::string& value) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(value);
}
inline void AddToReferenceListRequest::set_chunkname(const char* value) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(value);
}
inline void AddToReferenceListRequest::set_chunkname(const void* value, size_t size) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AddToReferenceListRequest::mutable_chunkname() {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  return chunkname_;
}

// required .maidsafe.StoreContract store_contract = 2;
inline bool AddToReferenceListRequest::has_store_contract() const {
  return _has_bit(1);
}
inline void AddToReferenceListRequest::clear_store_contract() {
  if (store_contract_ != NULL) store_contract_->::maidsafe::StoreContract::Clear();
  _clear_bit(1);
}
inline const ::maidsafe::StoreContract& AddToReferenceListRequest::store_contract() const {
  return store_contract_ != NULL ? *store_contract_ : *default_instance_->store_contract_;
}
inline ::maidsafe::StoreContract* AddToReferenceListRequest::mutable_store_contract() {
  _set_bit(1);
  if (store_contract_ == NULL) store_contract_ = new ::maidsafe::StoreContract;
  return store_contract_;
}

// required bytes request_signature = 3;
inline bool AddToReferenceListRequest::has_request_signature() const {
  return _has_bit(2);
}
inline void AddToReferenceListRequest::clear_request_signature() {
  if (request_signature_ != &_default_request_signature_) {
    request_signature_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& AddToReferenceListRequest::request_signature() const {
  return *request_signature_;
}
inline void AddToReferenceListRequest::set_request_signature(const ::std::string& value) {
  _set_bit(2);
  if (request_signature_ == &_default_request_signature_) {
    request_signature_ = new ::std::string;
  }
  request_signature_->assign(value);
}
inline void AddToReferenceListRequest::set_request_signature(const char* value) {
  _set_bit(2);
  if (request_signature_ == &_default_request_signature_) {
    request_signature_ = new ::std::string;
  }
  request_signature_->assign(value);
}
inline void AddToReferenceListRequest::set_request_signature(const void* value, size_t size) {
  _set_bit(2);
  if (request_signature_ == &_default_request_signature_) {
    request_signature_ = new ::std::string;
  }
  request_signature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AddToReferenceListRequest::mutable_request_signature() {
  _set_bit(2);
  if (request_signature_ == &_default_request_signature_) {
    request_signature_ = new ::std::string;
  }
  return request_signature_;
}

// -------------------------------------------------------------------

// AddToReferenceListResponse

// required uint32 result = 1;
inline bool AddToReferenceListResponse::has_result() const {
  return _has_bit(0);
}
inline void AddToReferenceListResponse::clear_result() {
  result_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 AddToReferenceListResponse::result() const {
  return result_;
}
inline void AddToReferenceListResponse::set_result(::google::protobuf::uint32 value) {
  _set_bit(0);
  result_ = value;
}

// optional bytes pmid = 2;
inline bool AddToReferenceListResponse::has_pmid() const {
  return _has_bit(1);
}
inline void AddToReferenceListResponse::clear_pmid() {
  if (pmid_ != &_default_pmid_) {
    pmid_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& AddToReferenceListResponse::pmid() const {
  return *pmid_;
}
inline void AddToReferenceListResponse::set_pmid(const ::std::string& value) {
  _set_bit(1);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(value);
}
inline void AddToReferenceListResponse::set_pmid(const char* value) {
  _set_bit(1);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(value);
}
inline void AddToReferenceListResponse::set_pmid(const void* value, size_t size) {
  _set_bit(1);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AddToReferenceListResponse::mutable_pmid() {
  _set_bit(1);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  return pmid_;
}

// -------------------------------------------------------------------

// RemoveFromReferenceListRequest

// required bytes chunkname = 1;
inline bool RemoveFromReferenceListRequest::has_chunkname() const {
  return _has_bit(0);
}
inline void RemoveFromReferenceListRequest::clear_chunkname() {
  if (chunkname_ != &_default_chunkname_) {
    chunkname_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& RemoveFromReferenceListRequest::chunkname() const {
  return *chunkname_;
}
inline void RemoveFromReferenceListRequest::set_chunkname(const ::std::string& value) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(value);
}
inline void RemoveFromReferenceListRequest::set_chunkname(const char* value) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(value);
}
inline void RemoveFromReferenceListRequest::set_chunkname(const void* value, size_t size) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RemoveFromReferenceListRequest::mutable_chunkname() {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  return chunkname_;
}

// required bytes pmid = 2;
inline bool RemoveFromReferenceListRequest::has_pmid() const {
  return _has_bit(1);
}
inline void RemoveFromReferenceListRequest::clear_pmid() {
  if (pmid_ != &_default_pmid_) {
    pmid_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& RemoveFromReferenceListRequest::pmid() const {
  return *pmid_;
}
inline void RemoveFromReferenceListRequest::set_pmid(const ::std::string& value) {
  _set_bit(1);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(value);
}
inline void RemoveFromReferenceListRequest::set_pmid(const char* value) {
  _set_bit(1);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(value);
}
inline void RemoveFromReferenceListRequest::set_pmid(const void* value, size_t size) {
  _set_bit(1);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RemoveFromReferenceListRequest::mutable_pmid() {
  _set_bit(1);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  return pmid_;
}

// required bytes public_key = 3;
inline bool RemoveFromReferenceListRequest::has_public_key() const {
  return _has_bit(2);
}
inline void RemoveFromReferenceListRequest::clear_public_key() {
  if (public_key_ != &_default_public_key_) {
    public_key_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& RemoveFromReferenceListRequest::public_key() const {
  return *public_key_;
}
inline void RemoveFromReferenceListRequest::set_public_key(const ::std::string& value) {
  _set_bit(2);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void RemoveFromReferenceListRequest::set_public_key(const char* value) {
  _set_bit(2);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void RemoveFromReferenceListRequest::set_public_key(const void* value, size_t size) {
  _set_bit(2);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RemoveFromReferenceListRequest::mutable_public_key() {
  _set_bit(2);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  return public_key_;
}

// required bytes public_key_signature = 4;
inline bool RemoveFromReferenceListRequest::has_public_key_signature() const {
  return _has_bit(3);
}
inline void RemoveFromReferenceListRequest::clear_public_key_signature() {
  if (public_key_signature_ != &_default_public_key_signature_) {
    public_key_signature_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& RemoveFromReferenceListRequest::public_key_signature() const {
  return *public_key_signature_;
}
inline void RemoveFromReferenceListRequest::set_public_key_signature(const ::std::string& value) {
  _set_bit(3);
  if (public_key_signature_ == &_default_public_key_signature_) {
    public_key_signature_ = new ::std::string;
  }
  public_key_signature_->assign(value);
}
inline void RemoveFromReferenceListRequest::set_public_key_signature(const char* value) {
  _set_bit(3);
  if (public_key_signature_ == &_default_public_key_signature_) {
    public_key_signature_ = new ::std::string;
  }
  public_key_signature_->assign(value);
}
inline void RemoveFromReferenceListRequest::set_public_key_signature(const void* value, size_t size) {
  _set_bit(3);
  if (public_key_signature_ == &_default_public_key_signature_) {
    public_key_signature_ = new ::std::string;
  }
  public_key_signature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RemoveFromReferenceListRequest::mutable_public_key_signature() {
  _set_bit(3);
  if (public_key_signature_ == &_default_public_key_signature_) {
    public_key_signature_ = new ::std::string;
  }
  return public_key_signature_;
}

// required bytes request_signature = 5;
inline bool RemoveFromReferenceListRequest::has_request_signature() const {
  return _has_bit(4);
}
inline void RemoveFromReferenceListRequest::clear_request_signature() {
  if (request_signature_ != &_default_request_signature_) {
    request_signature_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& RemoveFromReferenceListRequest::request_signature() const {
  return *request_signature_;
}
inline void RemoveFromReferenceListRequest::set_request_signature(const ::std::string& value) {
  _set_bit(4);
  if (request_signature_ == &_default_request_signature_) {
    request_signature_ = new ::std::string;
  }
  request_signature_->assign(value);
}
inline void RemoveFromReferenceListRequest::set_request_signature(const char* value) {
  _set_bit(4);
  if (request_signature_ == &_default_request_signature_) {
    request_signature_ = new ::std::string;
  }
  request_signature_->assign(value);
}
inline void RemoveFromReferenceListRequest::set_request_signature(const void* value, size_t size) {
  _set_bit(4);
  if (request_signature_ == &_default_request_signature_) {
    request_signature_ = new ::std::string;
  }
  request_signature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RemoveFromReferenceListRequest::mutable_request_signature() {
  _set_bit(4);
  if (request_signature_ == &_default_request_signature_) {
    request_signature_ = new ::std::string;
  }
  return request_signature_;
}

// -------------------------------------------------------------------

// RemoveFromReferenceListResponse

// required uint32 result = 1;
inline bool RemoveFromReferenceListResponse::has_result() const {
  return _has_bit(0);
}
inline void RemoveFromReferenceListResponse::clear_result() {
  result_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 RemoveFromReferenceListResponse::result() const {
  return result_;
}
inline void RemoveFromReferenceListResponse::set_result(::google::protobuf::uint32 value) {
  _set_bit(0);
  result_ = value;
}

// optional bytes pmid = 2;
inline bool RemoveFromReferenceListResponse::has_pmid() const {
  return _has_bit(1);
}
inline void RemoveFromReferenceListResponse::clear_pmid() {
  if (pmid_ != &_default_pmid_) {
    pmid_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& RemoveFromReferenceListResponse::pmid() const {
  return *pmid_;
}
inline void RemoveFromReferenceListResponse::set_pmid(const ::std::string& value) {
  _set_bit(1);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(value);
}
inline void RemoveFromReferenceListResponse::set_pmid(const char* value) {
  _set_bit(1);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(value);
}
inline void RemoveFromReferenceListResponse::set_pmid(const void* value, size_t size) {
  _set_bit(1);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RemoveFromReferenceListResponse::mutable_pmid() {
  _set_bit(1);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  return pmid_;
}

// -------------------------------------------------------------------

// AmendAccountRequest

// required .maidsafe.AmendAccountRequest.Amendment amendment_type = 1;
inline bool AmendAccountRequest::has_amendment_type() const {
  return _has_bit(0);
}
inline void AmendAccountRequest::clear_amendment_type() {
  amendment_type_ = 0;
  _clear_bit(0);
}
inline ::maidsafe::AmendAccountRequest_Amendment AmendAccountRequest::amendment_type() const {
  return static_cast< ::maidsafe::AmendAccountRequest_Amendment >(amendment_type_);
}
inline void AmendAccountRequest::set_amendment_type(::maidsafe::AmendAccountRequest_Amendment value) {
  GOOGLE_DCHECK(::maidsafe::AmendAccountRequest_Amendment_IsValid(value));
  _set_bit(0);
  amendment_type_ = value;
}

// required bytes account_pmid = 2;
inline bool AmendAccountRequest::has_account_pmid() const {
  return _has_bit(1);
}
inline void AmendAccountRequest::clear_account_pmid() {
  if (account_pmid_ != &_default_account_pmid_) {
    account_pmid_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& AmendAccountRequest::account_pmid() const {
  return *account_pmid_;
}
inline void AmendAccountRequest::set_account_pmid(const ::std::string& value) {
  _set_bit(1);
  if (account_pmid_ == &_default_account_pmid_) {
    account_pmid_ = new ::std::string;
  }
  account_pmid_->assign(value);
}
inline void AmendAccountRequest::set_account_pmid(const char* value) {
  _set_bit(1);
  if (account_pmid_ == &_default_account_pmid_) {
    account_pmid_ = new ::std::string;
  }
  account_pmid_->assign(value);
}
inline void AmendAccountRequest::set_account_pmid(const void* value, size_t size) {
  _set_bit(1);
  if (account_pmid_ == &_default_account_pmid_) {
    account_pmid_ = new ::std::string;
  }
  account_pmid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AmendAccountRequest::mutable_account_pmid() {
  _set_bit(1);
  if (account_pmid_ == &_default_account_pmid_) {
    account_pmid_ = new ::std::string;
  }
  return account_pmid_;
}

// required .maidsafe.SignedSize signed_size = 3;
inline bool AmendAccountRequest::has_signed_size() const {
  return _has_bit(2);
}
inline void AmendAccountRequest::clear_signed_size() {
  if (signed_size_ != NULL) signed_size_->::maidsafe::SignedSize::Clear();
  _clear_bit(2);
}
inline const ::maidsafe::SignedSize& AmendAccountRequest::signed_size() const {
  return signed_size_ != NULL ? *signed_size_ : *default_instance_->signed_size_;
}
inline ::maidsafe::SignedSize* AmendAccountRequest::mutable_signed_size() {
  _set_bit(2);
  if (signed_size_ == NULL) signed_size_ = new ::maidsafe::SignedSize;
  return signed_size_;
}

// optional bytes chunkname = 4;
inline bool AmendAccountRequest::has_chunkname() const {
  return _has_bit(3);
}
inline void AmendAccountRequest::clear_chunkname() {
  if (chunkname_ != &_default_chunkname_) {
    chunkname_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& AmendAccountRequest::chunkname() const {
  return *chunkname_;
}
inline void AmendAccountRequest::set_chunkname(const ::std::string& value) {
  _set_bit(3);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(value);
}
inline void AmendAccountRequest::set_chunkname(const char* value) {
  _set_bit(3);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(value);
}
inline void AmendAccountRequest::set_chunkname(const void* value, size_t size) {
  _set_bit(3);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AmendAccountRequest::mutable_chunkname() {
  _set_bit(3);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  return chunkname_;
}

// -------------------------------------------------------------------

// AmendAccountResponse

// required uint32 result = 1;
inline bool AmendAccountResponse::has_result() const {
  return _has_bit(0);
}
inline void AmendAccountResponse::clear_result() {
  result_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 AmendAccountResponse::result() const {
  return result_;
}
inline void AmendAccountResponse::set_result(::google::protobuf::uint32 value) {
  _set_bit(0);
  result_ = value;
}

// optional bytes pmid = 2;
inline bool AmendAccountResponse::has_pmid() const {
  return _has_bit(1);
}
inline void AmendAccountResponse::clear_pmid() {
  if (pmid_ != &_default_pmid_) {
    pmid_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& AmendAccountResponse::pmid() const {
  return *pmid_;
}
inline void AmendAccountResponse::set_pmid(const ::std::string& value) {
  _set_bit(1);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(value);
}
inline void AmendAccountResponse::set_pmid(const char* value) {
  _set_bit(1);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(value);
}
inline void AmendAccountResponse::set_pmid(const void* value, size_t size) {
  _set_bit(1);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AmendAccountResponse::mutable_pmid() {
  _set_bit(1);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  return pmid_;
}

// -------------------------------------------------------------------

// AccountStatusRequest

// required bytes account_pmid = 1;
inline bool AccountStatusRequest::has_account_pmid() const {
  return _has_bit(0);
}
inline void AccountStatusRequest::clear_account_pmid() {
  if (account_pmid_ != &_default_account_pmid_) {
    account_pmid_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& AccountStatusRequest::account_pmid() const {
  return *account_pmid_;
}
inline void AccountStatusRequest::set_account_pmid(const ::std::string& value) {
  _set_bit(0);
  if (account_pmid_ == &_default_account_pmid_) {
    account_pmid_ = new ::std::string;
  }
  account_pmid_->assign(value);
}
inline void AccountStatusRequest::set_account_pmid(const char* value) {
  _set_bit(0);
  if (account_pmid_ == &_default_account_pmid_) {
    account_pmid_ = new ::std::string;
  }
  account_pmid_->assign(value);
}
inline void AccountStatusRequest::set_account_pmid(const void* value, size_t size) {
  _set_bit(0);
  if (account_pmid_ == &_default_account_pmid_) {
    account_pmid_ = new ::std::string;
  }
  account_pmid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountStatusRequest::mutable_account_pmid() {
  _set_bit(0);
  if (account_pmid_ == &_default_account_pmid_) {
    account_pmid_ = new ::std::string;
  }
  return account_pmid_;
}

// optional uint64 space_requested = 2;
inline bool AccountStatusRequest::has_space_requested() const {
  return _has_bit(1);
}
inline void AccountStatusRequest::clear_space_requested() {
  space_requested_ = GOOGLE_ULONGLONG(0);
  _clear_bit(1);
}
inline ::google::protobuf::uint64 AccountStatusRequest::space_requested() const {
  return space_requested_;
}
inline void AccountStatusRequest::set_space_requested(::google::protobuf::uint64 value) {
  _set_bit(1);
  space_requested_ = value;
}

// optional bytes public_key = 3;
inline bool AccountStatusRequest::has_public_key() const {
  return _has_bit(2);
}
inline void AccountStatusRequest::clear_public_key() {
  if (public_key_ != &_default_public_key_) {
    public_key_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& AccountStatusRequest::public_key() const {
  return *public_key_;
}
inline void AccountStatusRequest::set_public_key(const ::std::string& value) {
  _set_bit(2);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void AccountStatusRequest::set_public_key(const char* value) {
  _set_bit(2);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void AccountStatusRequest::set_public_key(const void* value, size_t size) {
  _set_bit(2);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountStatusRequest::mutable_public_key() {
  _set_bit(2);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  return public_key_;
}

// optional bytes public_key_signature = 4;
inline bool AccountStatusRequest::has_public_key_signature() const {
  return _has_bit(3);
}
inline void AccountStatusRequest::clear_public_key_signature() {
  if (public_key_signature_ != &_default_public_key_signature_) {
    public_key_signature_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& AccountStatusRequest::public_key_signature() const {
  return *public_key_signature_;
}
inline void AccountStatusRequest::set_public_key_signature(const ::std::string& value) {
  _set_bit(3);
  if (public_key_signature_ == &_default_public_key_signature_) {
    public_key_signature_ = new ::std::string;
  }
  public_key_signature_->assign(value);
}
inline void AccountStatusRequest::set_public_key_signature(const char* value) {
  _set_bit(3);
  if (public_key_signature_ == &_default_public_key_signature_) {
    public_key_signature_ = new ::std::string;
  }
  public_key_signature_->assign(value);
}
inline void AccountStatusRequest::set_public_key_signature(const void* value, size_t size) {
  _set_bit(3);
  if (public_key_signature_ == &_default_public_key_signature_) {
    public_key_signature_ = new ::std::string;
  }
  public_key_signature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountStatusRequest::mutable_public_key_signature() {
  _set_bit(3);
  if (public_key_signature_ == &_default_public_key_signature_) {
    public_key_signature_ = new ::std::string;
  }
  return public_key_signature_;
}

// optional bytes request_signature = 5;
inline bool AccountStatusRequest::has_request_signature() const {
  return _has_bit(4);
}
inline void AccountStatusRequest::clear_request_signature() {
  if (request_signature_ != &_default_request_signature_) {
    request_signature_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& AccountStatusRequest::request_signature() const {
  return *request_signature_;
}
inline void AccountStatusRequest::set_request_signature(const ::std::string& value) {
  _set_bit(4);
  if (request_signature_ == &_default_request_signature_) {
    request_signature_ = new ::std::string;
  }
  request_signature_->assign(value);
}
inline void AccountStatusRequest::set_request_signature(const char* value) {
  _set_bit(4);
  if (request_signature_ == &_default_request_signature_) {
    request_signature_ = new ::std::string;
  }
  request_signature_->assign(value);
}
inline void AccountStatusRequest::set_request_signature(const void* value, size_t size) {
  _set_bit(4);
  if (request_signature_ == &_default_request_signature_) {
    request_signature_ = new ::std::string;
  }
  request_signature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountStatusRequest::mutable_request_signature() {
  _set_bit(4);
  if (request_signature_ == &_default_request_signature_) {
    request_signature_ = new ::std::string;
  }
  return request_signature_;
}

// -------------------------------------------------------------------

// AccountStatusResponse

// required uint32 result = 1;
inline bool AccountStatusResponse::has_result() const {
  return _has_bit(0);
}
inline void AccountStatusResponse::clear_result() {
  result_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 AccountStatusResponse::result() const {
  return result_;
}
inline void AccountStatusResponse::set_result(::google::protobuf::uint32 value) {
  _set_bit(0);
  result_ = value;
}

// required bytes pmid = 2;
inline bool AccountStatusResponse::has_pmid() const {
  return _has_bit(1);
}
inline void AccountStatusResponse::clear_pmid() {
  if (pmid_ != &_default_pmid_) {
    pmid_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& AccountStatusResponse::pmid() const {
  return *pmid_;
}
inline void AccountStatusResponse::set_pmid(const ::std::string& value) {
  _set_bit(1);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(value);
}
inline void AccountStatusResponse::set_pmid(const char* value) {
  _set_bit(1);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(value);
}
inline void AccountStatusResponse::set_pmid(const void* value, size_t size) {
  _set_bit(1);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountStatusResponse::mutable_pmid() {
  _set_bit(1);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  return pmid_;
}

// optional uint64 space_offered = 3;
inline bool AccountStatusResponse::has_space_offered() const {
  return _has_bit(2);
}
inline void AccountStatusResponse::clear_space_offered() {
  space_offered_ = GOOGLE_ULONGLONG(0);
  _clear_bit(2);
}
inline ::google::protobuf::uint64 AccountStatusResponse::space_offered() const {
  return space_offered_;
}
inline void AccountStatusResponse::set_space_offered(::google::protobuf::uint64 value) {
  _set_bit(2);
  space_offered_ = value;
}

// optional uint64 space_given = 4;
inline bool AccountStatusResponse::has_space_given() const {
  return _has_bit(3);
}
inline void AccountStatusResponse::clear_space_given() {
  space_given_ = GOOGLE_ULONGLONG(0);
  _clear_bit(3);
}
inline ::google::protobuf::uint64 AccountStatusResponse::space_given() const {
  return space_given_;
}
inline void AccountStatusResponse::set_space_given(::google::protobuf::uint64 value) {
  _set_bit(3);
  space_given_ = value;
}

// optional uint64 space_taken = 5;
inline bool AccountStatusResponse::has_space_taken() const {
  return _has_bit(4);
}
inline void AccountStatusResponse::clear_space_taken() {
  space_taken_ = GOOGLE_ULONGLONG(0);
  _clear_bit(4);
}
inline ::google::protobuf::uint64 AccountStatusResponse::space_taken() const {
  return space_taken_;
}
inline void AccountStatusResponse::set_space_taken(::google::protobuf::uint64 value) {
  _set_bit(4);
  space_taken_ = value;
}

// -------------------------------------------------------------------

// CheckChunkRequest

// required bytes chunkname = 1;
inline bool CheckChunkRequest::has_chunkname() const {
  return _has_bit(0);
}
inline void CheckChunkRequest::clear_chunkname() {
  if (chunkname_ != &_default_chunkname_) {
    chunkname_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& CheckChunkRequest::chunkname() const {
  return *chunkname_;
}
inline void CheckChunkRequest::set_chunkname(const ::std::string& value) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(value);
}
inline void CheckChunkRequest::set_chunkname(const char* value) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(value);
}
inline void CheckChunkRequest::set_chunkname(const void* value, size_t size) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CheckChunkRequest::mutable_chunkname() {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  return chunkname_;
}

// -------------------------------------------------------------------

// CheckChunkResponse

// required uint32 result = 1;
inline bool CheckChunkResponse::has_result() const {
  return _has_bit(0);
}
inline void CheckChunkResponse::clear_result() {
  result_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 CheckChunkResponse::result() const {
  return result_;
}
inline void CheckChunkResponse::set_result(::google::protobuf::uint32 value) {
  _set_bit(0);
  result_ = value;
}

// required bytes pmid = 2;
inline bool CheckChunkResponse::has_pmid() const {
  return _has_bit(1);
}
inline void CheckChunkResponse::clear_pmid() {
  if (pmid_ != &_default_pmid_) {
    pmid_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& CheckChunkResponse::pmid() const {
  return *pmid_;
}
inline void CheckChunkResponse::set_pmid(const ::std::string& value) {
  _set_bit(1);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(value);
}
inline void CheckChunkResponse::set_pmid(const char* value) {
  _set_bit(1);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(value);
}
inline void CheckChunkResponse::set_pmid(const void* value, size_t size) {
  _set_bit(1);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CheckChunkResponse::mutable_pmid() {
  _set_bit(1);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  return pmid_;
}

// -------------------------------------------------------------------

// GetChunkRequest

// required bytes chunkname = 1;
inline bool GetChunkRequest::has_chunkname() const {
  return _has_bit(0);
}
inline void GetChunkRequest::clear_chunkname() {
  if (chunkname_ != &_default_chunkname_) {
    chunkname_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& GetChunkRequest::chunkname() const {
  return *chunkname_;
}
inline void GetChunkRequest::set_chunkname(const ::std::string& value) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(value);
}
inline void GetChunkRequest::set_chunkname(const char* value) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(value);
}
inline void GetChunkRequest::set_chunkname(const void* value, size_t size) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetChunkRequest::mutable_chunkname() {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  return chunkname_;
}

// -------------------------------------------------------------------

// GetChunkResponse

// required uint32 result = 1;
inline bool GetChunkResponse::has_result() const {
  return _has_bit(0);
}
inline void GetChunkResponse::clear_result() {
  result_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 GetChunkResponse::result() const {
  return result_;
}
inline void GetChunkResponse::set_result(::google::protobuf::uint32 value) {
  _set_bit(0);
  result_ = value;
}

// optional bytes content = 2;
inline bool GetChunkResponse::has_content() const {
  return _has_bit(1);
}
inline void GetChunkResponse::clear_content() {
  if (content_ != &_default_content_) {
    content_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& GetChunkResponse::content() const {
  return *content_;
}
inline void GetChunkResponse::set_content(const ::std::string& value) {
  _set_bit(1);
  if (content_ == &_default_content_) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void GetChunkResponse::set_content(const char* value) {
  _set_bit(1);
  if (content_ == &_default_content_) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void GetChunkResponse::set_content(const void* value, size_t size) {
  _set_bit(1);
  if (content_ == &_default_content_) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetChunkResponse::mutable_content() {
  _set_bit(1);
  if (content_ == &_default_content_) {
    content_ = new ::std::string;
  }
  return content_;
}

// optional bytes pmid = 3;
inline bool GetChunkResponse::has_pmid() const {
  return _has_bit(2);
}
inline void GetChunkResponse::clear_pmid() {
  if (pmid_ != &_default_pmid_) {
    pmid_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& GetChunkResponse::pmid() const {
  return *pmid_;
}
inline void GetChunkResponse::set_pmid(const ::std::string& value) {
  _set_bit(2);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(value);
}
inline void GetChunkResponse::set_pmid(const char* value) {
  _set_bit(2);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(value);
}
inline void GetChunkResponse::set_pmid(const void* value, size_t size) {
  _set_bit(2);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetChunkResponse::mutable_pmid() {
  _set_bit(2);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  return pmid_;
}

// -------------------------------------------------------------------

// GetPacketRequest

// required bytes packetname = 1;
inline bool GetPacketRequest::has_packetname() const {
  return _has_bit(0);
}
inline void GetPacketRequest::clear_packetname() {
  if (packetname_ != &_default_packetname_) {
    packetname_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& GetPacketRequest::packetname() const {
  return *packetname_;
}
inline void GetPacketRequest::set_packetname(const ::std::string& value) {
  _set_bit(0);
  if (packetname_ == &_default_packetname_) {
    packetname_ = new ::std::string;
  }
  packetname_->assign(value);
}
inline void GetPacketRequest::set_packetname(const char* value) {
  _set_bit(0);
  if (packetname_ == &_default_packetname_) {
    packetname_ = new ::std::string;
  }
  packetname_->assign(value);
}
inline void GetPacketRequest::set_packetname(const void* value, size_t size) {
  _set_bit(0);
  if (packetname_ == &_default_packetname_) {
    packetname_ = new ::std::string;
  }
  packetname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetPacketRequest::mutable_packetname() {
  _set_bit(0);
  if (packetname_ == &_default_packetname_) {
    packetname_ = new ::std::string;
  }
  return packetname_;
}

// optional bytes key_id = 2;
inline bool GetPacketRequest::has_key_id() const {
  return _has_bit(1);
}
inline void GetPacketRequest::clear_key_id() {
  if (key_id_ != &_default_key_id_) {
    key_id_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& GetPacketRequest::key_id() const {
  return *key_id_;
}
inline void GetPacketRequest::set_key_id(const ::std::string& value) {
  _set_bit(1);
  if (key_id_ == &_default_key_id_) {
    key_id_ = new ::std::string;
  }
  key_id_->assign(value);
}
inline void GetPacketRequest::set_key_id(const char* value) {
  _set_bit(1);
  if (key_id_ == &_default_key_id_) {
    key_id_ = new ::std::string;
  }
  key_id_->assign(value);
}
inline void GetPacketRequest::set_key_id(const void* value, size_t size) {
  _set_bit(1);
  if (key_id_ == &_default_key_id_) {
    key_id_ = new ::std::string;
  }
  key_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetPacketRequest::mutable_key_id() {
  _set_bit(1);
  if (key_id_ == &_default_key_id_) {
    key_id_ = new ::std::string;
  }
  return key_id_;
}

// optional bytes public_key = 3;
inline bool GetPacketRequest::has_public_key() const {
  return _has_bit(2);
}
inline void GetPacketRequest::clear_public_key() {
  if (public_key_ != &_default_public_key_) {
    public_key_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& GetPacketRequest::public_key() const {
  return *public_key_;
}
inline void GetPacketRequest::set_public_key(const ::std::string& value) {
  _set_bit(2);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void GetPacketRequest::set_public_key(const char* value) {
  _set_bit(2);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void GetPacketRequest::set_public_key(const void* value, size_t size) {
  _set_bit(2);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetPacketRequest::mutable_public_key() {
  _set_bit(2);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  return public_key_;
}

// optional bytes public_key_signature = 4;
inline bool GetPacketRequest::has_public_key_signature() const {
  return _has_bit(3);
}
inline void GetPacketRequest::clear_public_key_signature() {
  if (public_key_signature_ != &_default_public_key_signature_) {
    public_key_signature_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& GetPacketRequest::public_key_signature() const {
  return *public_key_signature_;
}
inline void GetPacketRequest::set_public_key_signature(const ::std::string& value) {
  _set_bit(3);
  if (public_key_signature_ == &_default_public_key_signature_) {
    public_key_signature_ = new ::std::string;
  }
  public_key_signature_->assign(value);
}
inline void GetPacketRequest::set_public_key_signature(const char* value) {
  _set_bit(3);
  if (public_key_signature_ == &_default_public_key_signature_) {
    public_key_signature_ = new ::std::string;
  }
  public_key_signature_->assign(value);
}
inline void GetPacketRequest::set_public_key_signature(const void* value, size_t size) {
  _set_bit(3);
  if (public_key_signature_ == &_default_public_key_signature_) {
    public_key_signature_ = new ::std::string;
  }
  public_key_signature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetPacketRequest::mutable_public_key_signature() {
  _set_bit(3);
  if (public_key_signature_ == &_default_public_key_signature_) {
    public_key_signature_ = new ::std::string;
  }
  return public_key_signature_;
}

// optional bytes request_signature = 5;
inline bool GetPacketRequest::has_request_signature() const {
  return _has_bit(4);
}
inline void GetPacketRequest::clear_request_signature() {
  if (request_signature_ != &_default_request_signature_) {
    request_signature_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& GetPacketRequest::request_signature() const {
  return *request_signature_;
}
inline void GetPacketRequest::set_request_signature(const ::std::string& value) {
  _set_bit(4);
  if (request_signature_ == &_default_request_signature_) {
    request_signature_ = new ::std::string;
  }
  request_signature_->assign(value);
}
inline void GetPacketRequest::set_request_signature(const char* value) {
  _set_bit(4);
  if (request_signature_ == &_default_request_signature_) {
    request_signature_ = new ::std::string;
  }
  request_signature_->assign(value);
}
inline void GetPacketRequest::set_request_signature(const void* value, size_t size) {
  _set_bit(4);
  if (request_signature_ == &_default_request_signature_) {
    request_signature_ = new ::std::string;
  }
  request_signature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetPacketRequest::mutable_request_signature() {
  _set_bit(4);
  if (request_signature_ == &_default_request_signature_) {
    request_signature_ = new ::std::string;
  }
  return request_signature_;
}

// -------------------------------------------------------------------

// GetPacketResponse

// required uint32 result = 1;
inline bool GetPacketResponse::has_result() const {
  return _has_bit(0);
}
inline void GetPacketResponse::clear_result() {
  result_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 GetPacketResponse::result() const {
  return result_;
}
inline void GetPacketResponse::set_result(::google::protobuf::uint32 value) {
  _set_bit(0);
  result_ = value;
}

// repeated .maidsafe.GenericPacket content = 2;
inline int GetPacketResponse::content_size() const {
  return content_.size();
}
inline void GetPacketResponse::clear_content() {
  content_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::maidsafe::GenericPacket >&
GetPacketResponse::content() const {
  return content_;
}
inline ::google::protobuf::RepeatedPtrField< ::maidsafe::GenericPacket >*
GetPacketResponse::mutable_content() {
  return &content_;
}
inline const ::maidsafe::GenericPacket& GetPacketResponse::content(int index) const {
  return content_.Get(index);
}
inline ::maidsafe::GenericPacket* GetPacketResponse::mutable_content(int index) {
  return content_.Mutable(index);
}
inline ::maidsafe::GenericPacket* GetPacketResponse::add_content() {
  return content_.Add();
}

// optional bytes pmid = 3;
inline bool GetPacketResponse::has_pmid() const {
  return _has_bit(2);
}
inline void GetPacketResponse::clear_pmid() {
  if (pmid_ != &_default_pmid_) {
    pmid_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& GetPacketResponse::pmid() const {
  return *pmid_;
}
inline void GetPacketResponse::set_pmid(const ::std::string& value) {
  _set_bit(2);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(value);
}
inline void GetPacketResponse::set_pmid(const char* value) {
  _set_bit(2);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(value);
}
inline void GetPacketResponse::set_pmid(const void* value, size_t size) {
  _set_bit(2);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetPacketResponse::mutable_pmid() {
  _set_bit(2);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  return pmid_;
}

// -------------------------------------------------------------------

// UpdateChunkRequest

// required bytes chunkname = 1;
inline bool UpdateChunkRequest::has_chunkname() const {
  return _has_bit(0);
}
inline void UpdateChunkRequest::clear_chunkname() {
  if (chunkname_ != &_default_chunkname_) {
    chunkname_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& UpdateChunkRequest::chunkname() const {
  return *chunkname_;
}
inline void UpdateChunkRequest::set_chunkname(const ::std::string& value) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(value);
}
inline void UpdateChunkRequest::set_chunkname(const char* value) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(value);
}
inline void UpdateChunkRequest::set_chunkname(const void* value, size_t size) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpdateChunkRequest::mutable_chunkname() {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  return chunkname_;
}

// required bytes data = 2;
inline bool UpdateChunkRequest::has_data() const {
  return _has_bit(1);
}
inline void UpdateChunkRequest::clear_data() {
  if (data_ != &_default_data_) {
    data_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& UpdateChunkRequest::data() const {
  return *data_;
}
inline void UpdateChunkRequest::set_data(const ::std::string& value) {
  _set_bit(1);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void UpdateChunkRequest::set_data(const char* value) {
  _set_bit(1);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void UpdateChunkRequest::set_data(const void* value, size_t size) {
  _set_bit(1);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpdateChunkRequest::mutable_data() {
  _set_bit(1);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  return data_;
}

// required bytes pmid = 3;
inline bool UpdateChunkRequest::has_pmid() const {
  return _has_bit(2);
}
inline void UpdateChunkRequest::clear_pmid() {
  if (pmid_ != &_default_pmid_) {
    pmid_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& UpdateChunkRequest::pmid() const {
  return *pmid_;
}
inline void UpdateChunkRequest::set_pmid(const ::std::string& value) {
  _set_bit(2);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(value);
}
inline void UpdateChunkRequest::set_pmid(const char* value) {
  _set_bit(2);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(value);
}
inline void UpdateChunkRequest::set_pmid(const void* value, size_t size) {
  _set_bit(2);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpdateChunkRequest::mutable_pmid() {
  _set_bit(2);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  return pmid_;
}

// required bytes public_key = 4;
inline bool UpdateChunkRequest::has_public_key() const {
  return _has_bit(3);
}
inline void UpdateChunkRequest::clear_public_key() {
  if (public_key_ != &_default_public_key_) {
    public_key_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& UpdateChunkRequest::public_key() const {
  return *public_key_;
}
inline void UpdateChunkRequest::set_public_key(const ::std::string& value) {
  _set_bit(3);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void UpdateChunkRequest::set_public_key(const char* value) {
  _set_bit(3);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void UpdateChunkRequest::set_public_key(const void* value, size_t size) {
  _set_bit(3);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpdateChunkRequest::mutable_public_key() {
  _set_bit(3);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  return public_key_;
}

// required bytes public_key_signature = 5;
inline bool UpdateChunkRequest::has_public_key_signature() const {
  return _has_bit(4);
}
inline void UpdateChunkRequest::clear_public_key_signature() {
  if (public_key_signature_ != &_default_public_key_signature_) {
    public_key_signature_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& UpdateChunkRequest::public_key_signature() const {
  return *public_key_signature_;
}
inline void UpdateChunkRequest::set_public_key_signature(const ::std::string& value) {
  _set_bit(4);
  if (public_key_signature_ == &_default_public_key_signature_) {
    public_key_signature_ = new ::std::string;
  }
  public_key_signature_->assign(value);
}
inline void UpdateChunkRequest::set_public_key_signature(const char* value) {
  _set_bit(4);
  if (public_key_signature_ == &_default_public_key_signature_) {
    public_key_signature_ = new ::std::string;
  }
  public_key_signature_->assign(value);
}
inline void UpdateChunkRequest::set_public_key_signature(const void* value, size_t size) {
  _set_bit(4);
  if (public_key_signature_ == &_default_public_key_signature_) {
    public_key_signature_ = new ::std::string;
  }
  public_key_signature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpdateChunkRequest::mutable_public_key_signature() {
  _set_bit(4);
  if (public_key_signature_ == &_default_public_key_signature_) {
    public_key_signature_ = new ::std::string;
  }
  return public_key_signature_;
}

// required bytes request_signature = 6;
inline bool UpdateChunkRequest::has_request_signature() const {
  return _has_bit(5);
}
inline void UpdateChunkRequest::clear_request_signature() {
  if (request_signature_ != &_default_request_signature_) {
    request_signature_->clear();
  }
  _clear_bit(5);
}
inline const ::std::string& UpdateChunkRequest::request_signature() const {
  return *request_signature_;
}
inline void UpdateChunkRequest::set_request_signature(const ::std::string& value) {
  _set_bit(5);
  if (request_signature_ == &_default_request_signature_) {
    request_signature_ = new ::std::string;
  }
  request_signature_->assign(value);
}
inline void UpdateChunkRequest::set_request_signature(const char* value) {
  _set_bit(5);
  if (request_signature_ == &_default_request_signature_) {
    request_signature_ = new ::std::string;
  }
  request_signature_->assign(value);
}
inline void UpdateChunkRequest::set_request_signature(const void* value, size_t size) {
  _set_bit(5);
  if (request_signature_ == &_default_request_signature_) {
    request_signature_ = new ::std::string;
  }
  request_signature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpdateChunkRequest::mutable_request_signature() {
  _set_bit(5);
  if (request_signature_ == &_default_request_signature_) {
    request_signature_ = new ::std::string;
  }
  return request_signature_;
}

// required int32 data_type = 7;
inline bool UpdateChunkRequest::has_data_type() const {
  return _has_bit(6);
}
inline void UpdateChunkRequest::clear_data_type() {
  data_type_ = 0;
  _clear_bit(6);
}
inline ::google::protobuf::int32 UpdateChunkRequest::data_type() const {
  return data_type_;
}
inline void UpdateChunkRequest::set_data_type(::google::protobuf::int32 value) {
  _set_bit(6);
  data_type_ = value;
}

// -------------------------------------------------------------------

// UpdateChunkResponse

// required uint32 result = 1;
inline bool UpdateChunkResponse::has_result() const {
  return _has_bit(0);
}
inline void UpdateChunkResponse::clear_result() {
  result_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 UpdateChunkResponse::result() const {
  return result_;
}
inline void UpdateChunkResponse::set_result(::google::protobuf::uint32 value) {
  _set_bit(0);
  result_ = value;
}

// optional bytes pmid = 2;
inline bool UpdateChunkResponse::has_pmid() const {
  return _has_bit(1);
}
inline void UpdateChunkResponse::clear_pmid() {
  if (pmid_ != &_default_pmid_) {
    pmid_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& UpdateChunkResponse::pmid() const {
  return *pmid_;
}
inline void UpdateChunkResponse::set_pmid(const ::std::string& value) {
  _set_bit(1);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(value);
}
inline void UpdateChunkResponse::set_pmid(const char* value) {
  _set_bit(1);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(value);
}
inline void UpdateChunkResponse::set_pmid(const void* value, size_t size) {
  _set_bit(1);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpdateChunkResponse::mutable_pmid() {
  _set_bit(1);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  return pmid_;
}

// -------------------------------------------------------------------

// DeleteChunkRequest

// required bytes chunkname = 1;
inline bool DeleteChunkRequest::has_chunkname() const {
  return _has_bit(0);
}
inline void DeleteChunkRequest::clear_chunkname() {
  if (chunkname_ != &_default_chunkname_) {
    chunkname_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& DeleteChunkRequest::chunkname() const {
  return *chunkname_;
}
inline void DeleteChunkRequest::set_chunkname(const ::std::string& value) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(value);
}
inline void DeleteChunkRequest::set_chunkname(const char* value) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(value);
}
inline void DeleteChunkRequest::set_chunkname(const void* value, size_t size) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeleteChunkRequest::mutable_chunkname() {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  return chunkname_;
}

// required .maidsafe.SignedSize signed_size = 2;
inline bool DeleteChunkRequest::has_signed_size() const {
  return _has_bit(1);
}
inline void DeleteChunkRequest::clear_signed_size() {
  if (signed_size_ != NULL) signed_size_->::maidsafe::SignedSize::Clear();
  _clear_bit(1);
}
inline const ::maidsafe::SignedSize& DeleteChunkRequest::signed_size() const {
  return signed_size_ != NULL ? *signed_size_ : *default_instance_->signed_size_;
}
inline ::maidsafe::SignedSize* DeleteChunkRequest::mutable_signed_size() {
  _set_bit(1);
  if (signed_size_ == NULL) signed_size_ = new ::maidsafe::SignedSize;
  return signed_size_;
}

// required bytes request_signature = 3;
inline bool DeleteChunkRequest::has_request_signature() const {
  return _has_bit(2);
}
inline void DeleteChunkRequest::clear_request_signature() {
  if (request_signature_ != &_default_request_signature_) {
    request_signature_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& DeleteChunkRequest::request_signature() const {
  return *request_signature_;
}
inline void DeleteChunkRequest::set_request_signature(const ::std::string& value) {
  _set_bit(2);
  if (request_signature_ == &_default_request_signature_) {
    request_signature_ = new ::std::string;
  }
  request_signature_->assign(value);
}
inline void DeleteChunkRequest::set_request_signature(const char* value) {
  _set_bit(2);
  if (request_signature_ == &_default_request_signature_) {
    request_signature_ = new ::std::string;
  }
  request_signature_->assign(value);
}
inline void DeleteChunkRequest::set_request_signature(const void* value, size_t size) {
  _set_bit(2);
  if (request_signature_ == &_default_request_signature_) {
    request_signature_ = new ::std::string;
  }
  request_signature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeleteChunkRequest::mutable_request_signature() {
  _set_bit(2);
  if (request_signature_ == &_default_request_signature_) {
    request_signature_ = new ::std::string;
  }
  return request_signature_;
}

// required int32 data_type = 4;
inline bool DeleteChunkRequest::has_data_type() const {
  return _has_bit(3);
}
inline void DeleteChunkRequest::clear_data_type() {
  data_type_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 DeleteChunkRequest::data_type() const {
  return data_type_;
}
inline void DeleteChunkRequest::set_data_type(::google::protobuf::int32 value) {
  _set_bit(3);
  data_type_ = value;
}

// -------------------------------------------------------------------

// DeleteChunkResponse

// required uint32 result = 1;
inline bool DeleteChunkResponse::has_result() const {
  return _has_bit(0);
}
inline void DeleteChunkResponse::clear_result() {
  result_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 DeleteChunkResponse::result() const {
  return result_;
}
inline void DeleteChunkResponse::set_result(::google::protobuf::uint32 value) {
  _set_bit(0);
  result_ = value;
}

// optional bytes pmid = 2;
inline bool DeleteChunkResponse::has_pmid() const {
  return _has_bit(1);
}
inline void DeleteChunkResponse::clear_pmid() {
  if (pmid_ != &_default_pmid_) {
    pmid_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& DeleteChunkResponse::pmid() const {
  return *pmid_;
}
inline void DeleteChunkResponse::set_pmid(const ::std::string& value) {
  _set_bit(1);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(value);
}
inline void DeleteChunkResponse::set_pmid(const char* value) {
  _set_bit(1);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(value);
}
inline void DeleteChunkResponse::set_pmid(const void* value, size_t size) {
  _set_bit(1);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeleteChunkResponse::mutable_pmid() {
  _set_bit(1);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  return pmid_;
}

// -------------------------------------------------------------------

// ValidityCheckRequest

// required bytes chunkname = 1;
inline bool ValidityCheckRequest::has_chunkname() const {
  return _has_bit(0);
}
inline void ValidityCheckRequest::clear_chunkname() {
  if (chunkname_ != &_default_chunkname_) {
    chunkname_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& ValidityCheckRequest::chunkname() const {
  return *chunkname_;
}
inline void ValidityCheckRequest::set_chunkname(const ::std::string& value) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(value);
}
inline void ValidityCheckRequest::set_chunkname(const char* value) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(value);
}
inline void ValidityCheckRequest::set_chunkname(const void* value, size_t size) {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  chunkname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ValidityCheckRequest::mutable_chunkname() {
  _set_bit(0);
  if (chunkname_ == &_default_chunkname_) {
    chunkname_ = new ::std::string;
  }
  return chunkname_;
}

// required bytes random_data = 2;
inline bool ValidityCheckRequest::has_random_data() const {
  return _has_bit(1);
}
inline void ValidityCheckRequest::clear_random_data() {
  if (random_data_ != &_default_random_data_) {
    random_data_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& ValidityCheckRequest::random_data() const {
  return *random_data_;
}
inline void ValidityCheckRequest::set_random_data(const ::std::string& value) {
  _set_bit(1);
  if (random_data_ == &_default_random_data_) {
    random_data_ = new ::std::string;
  }
  random_data_->assign(value);
}
inline void ValidityCheckRequest::set_random_data(const char* value) {
  _set_bit(1);
  if (random_data_ == &_default_random_data_) {
    random_data_ = new ::std::string;
  }
  random_data_->assign(value);
}
inline void ValidityCheckRequest::set_random_data(const void* value, size_t size) {
  _set_bit(1);
  if (random_data_ == &_default_random_data_) {
    random_data_ = new ::std::string;
  }
  random_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ValidityCheckRequest::mutable_random_data() {
  _set_bit(1);
  if (random_data_ == &_default_random_data_) {
    random_data_ = new ::std::string;
  }
  return random_data_;
}

// -------------------------------------------------------------------

// ValidityCheckResponse

// required uint32 result = 1;
inline bool ValidityCheckResponse::has_result() const {
  return _has_bit(0);
}
inline void ValidityCheckResponse::clear_result() {
  result_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 ValidityCheckResponse::result() const {
  return result_;
}
inline void ValidityCheckResponse::set_result(::google::protobuf::uint32 value) {
  _set_bit(0);
  result_ = value;
}

// optional bytes hash_content = 2;
inline bool ValidityCheckResponse::has_hash_content() const {
  return _has_bit(1);
}
inline void ValidityCheckResponse::clear_hash_content() {
  if (hash_content_ != &_default_hash_content_) {
    hash_content_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& ValidityCheckResponse::hash_content() const {
  return *hash_content_;
}
inline void ValidityCheckResponse::set_hash_content(const ::std::string& value) {
  _set_bit(1);
  if (hash_content_ == &_default_hash_content_) {
    hash_content_ = new ::std::string;
  }
  hash_content_->assign(value);
}
inline void ValidityCheckResponse::set_hash_content(const char* value) {
  _set_bit(1);
  if (hash_content_ == &_default_hash_content_) {
    hash_content_ = new ::std::string;
  }
  hash_content_->assign(value);
}
inline void ValidityCheckResponse::set_hash_content(const void* value, size_t size) {
  _set_bit(1);
  if (hash_content_ == &_default_hash_content_) {
    hash_content_ = new ::std::string;
  }
  hash_content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ValidityCheckResponse::mutable_hash_content() {
  _set_bit(1);
  if (hash_content_ == &_default_hash_content_) {
    hash_content_ = new ::std::string;
  }
  return hash_content_;
}

// required bytes pmid = 3;
inline bool ValidityCheckResponse::has_pmid() const {
  return _has_bit(2);
}
inline void ValidityCheckResponse::clear_pmid() {
  if (pmid_ != &_default_pmid_) {
    pmid_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& ValidityCheckResponse::pmid() const {
  return *pmid_;
}
inline void ValidityCheckResponse::set_pmid(const ::std::string& value) {
  _set_bit(2);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(value);
}
inline void ValidityCheckResponse::set_pmid(const char* value) {
  _set_bit(2);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(value);
}
inline void ValidityCheckResponse::set_pmid(const void* value, size_t size) {
  _set_bit(2);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ValidityCheckResponse::mutable_pmid() {
  _set_bit(2);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  return pmid_;
}

// -------------------------------------------------------------------

// SwapChunkRequest

// required int32 request_type = 1;
inline bool SwapChunkRequest::has_request_type() const {
  return _has_bit(0);
}
inline void SwapChunkRequest::clear_request_type() {
  request_type_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 SwapChunkRequest::request_type() const {
  return request_type_;
}
inline void SwapChunkRequest::set_request_type(::google::protobuf::int32 value) {
  _set_bit(0);
  request_type_ = value;
}

// required bytes chunkname1 = 2;
inline bool SwapChunkRequest::has_chunkname1() const {
  return _has_bit(1);
}
inline void SwapChunkRequest::clear_chunkname1() {
  if (chunkname1_ != &_default_chunkname1_) {
    chunkname1_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& SwapChunkRequest::chunkname1() const {
  return *chunkname1_;
}
inline void SwapChunkRequest::set_chunkname1(const ::std::string& value) {
  _set_bit(1);
  if (chunkname1_ == &_default_chunkname1_) {
    chunkname1_ = new ::std::string;
  }
  chunkname1_->assign(value);
}
inline void SwapChunkRequest::set_chunkname1(const char* value) {
  _set_bit(1);
  if (chunkname1_ == &_default_chunkname1_) {
    chunkname1_ = new ::std::string;
  }
  chunkname1_->assign(value);
}
inline void SwapChunkRequest::set_chunkname1(const void* value, size_t size) {
  _set_bit(1);
  if (chunkname1_ == &_default_chunkname1_) {
    chunkname1_ = new ::std::string;
  }
  chunkname1_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SwapChunkRequest::mutable_chunkname1() {
  _set_bit(1);
  if (chunkname1_ == &_default_chunkname1_) {
    chunkname1_ = new ::std::string;
  }
  return chunkname1_;
}

// optional bytes chunkcontent1 = 3;
inline bool SwapChunkRequest::has_chunkcontent1() const {
  return _has_bit(2);
}
inline void SwapChunkRequest::clear_chunkcontent1() {
  if (chunkcontent1_ != &_default_chunkcontent1_) {
    chunkcontent1_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& SwapChunkRequest::chunkcontent1() const {
  return *chunkcontent1_;
}
inline void SwapChunkRequest::set_chunkcontent1(const ::std::string& value) {
  _set_bit(2);
  if (chunkcontent1_ == &_default_chunkcontent1_) {
    chunkcontent1_ = new ::std::string;
  }
  chunkcontent1_->assign(value);
}
inline void SwapChunkRequest::set_chunkcontent1(const char* value) {
  _set_bit(2);
  if (chunkcontent1_ == &_default_chunkcontent1_) {
    chunkcontent1_ = new ::std::string;
  }
  chunkcontent1_->assign(value);
}
inline void SwapChunkRequest::set_chunkcontent1(const void* value, size_t size) {
  _set_bit(2);
  if (chunkcontent1_ == &_default_chunkcontent1_) {
    chunkcontent1_ = new ::std::string;
  }
  chunkcontent1_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SwapChunkRequest::mutable_chunkcontent1() {
  _set_bit(2);
  if (chunkcontent1_ == &_default_chunkcontent1_) {
    chunkcontent1_ = new ::std::string;
  }
  return chunkcontent1_;
}

// optional int32 size1 = 4;
inline bool SwapChunkRequest::has_size1() const {
  return _has_bit(3);
}
inline void SwapChunkRequest::clear_size1() {
  size1_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 SwapChunkRequest::size1() const {
  return size1_;
}
inline void SwapChunkRequest::set_size1(::google::protobuf::int32 value) {
  _set_bit(3);
  size1_ = value;
}

// optional bytes chunkname2 = 5;
inline bool SwapChunkRequest::has_chunkname2() const {
  return _has_bit(4);
}
inline void SwapChunkRequest::clear_chunkname2() {
  if (chunkname2_ != &_default_chunkname2_) {
    chunkname2_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& SwapChunkRequest::chunkname2() const {
  return *chunkname2_;
}
inline void SwapChunkRequest::set_chunkname2(const ::std::string& value) {
  _set_bit(4);
  if (chunkname2_ == &_default_chunkname2_) {
    chunkname2_ = new ::std::string;
  }
  chunkname2_->assign(value);
}
inline void SwapChunkRequest::set_chunkname2(const char* value) {
  _set_bit(4);
  if (chunkname2_ == &_default_chunkname2_) {
    chunkname2_ = new ::std::string;
  }
  chunkname2_->assign(value);
}
inline void SwapChunkRequest::set_chunkname2(const void* value, size_t size) {
  _set_bit(4);
  if (chunkname2_ == &_default_chunkname2_) {
    chunkname2_ = new ::std::string;
  }
  chunkname2_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SwapChunkRequest::mutable_chunkname2() {
  _set_bit(4);
  if (chunkname2_ == &_default_chunkname2_) {
    chunkname2_ = new ::std::string;
  }
  return chunkname2_;
}

// -------------------------------------------------------------------

// SwapChunkResponse

// required int32 request_type = 1;
inline bool SwapChunkResponse::has_request_type() const {
  return _has_bit(0);
}
inline void SwapChunkResponse::clear_request_type() {
  request_type_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 SwapChunkResponse::request_type() const {
  return request_type_;
}
inline void SwapChunkResponse::set_request_type(::google::protobuf::int32 value) {
  _set_bit(0);
  request_type_ = value;
}

// required uint32 result = 2;
inline bool SwapChunkResponse::has_result() const {
  return _has_bit(1);
}
inline void SwapChunkResponse::clear_result() {
  result_ = 0u;
  _clear_bit(1);
}
inline ::google::protobuf::uint32 SwapChunkResponse::result() const {
  return result_;
}
inline void SwapChunkResponse::set_result(::google::protobuf::uint32 value) {
  _set_bit(1);
  result_ = value;
}

// optional bytes chunkname1 = 3;
inline bool SwapChunkResponse::has_chunkname1() const {
  return _has_bit(2);
}
inline void SwapChunkResponse::clear_chunkname1() {
  if (chunkname1_ != &_default_chunkname1_) {
    chunkname1_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& SwapChunkResponse::chunkname1() const {
  return *chunkname1_;
}
inline void SwapChunkResponse::set_chunkname1(const ::std::string& value) {
  _set_bit(2);
  if (chunkname1_ == &_default_chunkname1_) {
    chunkname1_ = new ::std::string;
  }
  chunkname1_->assign(value);
}
inline void SwapChunkResponse::set_chunkname1(const char* value) {
  _set_bit(2);
  if (chunkname1_ == &_default_chunkname1_) {
    chunkname1_ = new ::std::string;
  }
  chunkname1_->assign(value);
}
inline void SwapChunkResponse::set_chunkname1(const void* value, size_t size) {
  _set_bit(2);
  if (chunkname1_ == &_default_chunkname1_) {
    chunkname1_ = new ::std::string;
  }
  chunkname1_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SwapChunkResponse::mutable_chunkname1() {
  _set_bit(2);
  if (chunkname1_ == &_default_chunkname1_) {
    chunkname1_ = new ::std::string;
  }
  return chunkname1_;
}

// optional bytes chunkcontent1 = 4;
inline bool SwapChunkResponse::has_chunkcontent1() const {
  return _has_bit(3);
}
inline void SwapChunkResponse::clear_chunkcontent1() {
  if (chunkcontent1_ != &_default_chunkcontent1_) {
    chunkcontent1_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& SwapChunkResponse::chunkcontent1() const {
  return *chunkcontent1_;
}
inline void SwapChunkResponse::set_chunkcontent1(const ::std::string& value) {
  _set_bit(3);
  if (chunkcontent1_ == &_default_chunkcontent1_) {
    chunkcontent1_ = new ::std::string;
  }
  chunkcontent1_->assign(value);
}
inline void SwapChunkResponse::set_chunkcontent1(const char* value) {
  _set_bit(3);
  if (chunkcontent1_ == &_default_chunkcontent1_) {
    chunkcontent1_ = new ::std::string;
  }
  chunkcontent1_->assign(value);
}
inline void SwapChunkResponse::set_chunkcontent1(const void* value, size_t size) {
  _set_bit(3);
  if (chunkcontent1_ == &_default_chunkcontent1_) {
    chunkcontent1_ = new ::std::string;
  }
  chunkcontent1_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SwapChunkResponse::mutable_chunkcontent1() {
  _set_bit(3);
  if (chunkcontent1_ == &_default_chunkcontent1_) {
    chunkcontent1_ = new ::std::string;
  }
  return chunkcontent1_;
}

// optional int32 size1 = 5;
inline bool SwapChunkResponse::has_size1() const {
  return _has_bit(4);
}
inline void SwapChunkResponse::clear_size1() {
  size1_ = 0;
  _clear_bit(4);
}
inline ::google::protobuf::int32 SwapChunkResponse::size1() const {
  return size1_;
}
inline void SwapChunkResponse::set_size1(::google::protobuf::int32 value) {
  _set_bit(4);
  size1_ = value;
}

// optional bytes chunkname2 = 6;
inline bool SwapChunkResponse::has_chunkname2() const {
  return _has_bit(5);
}
inline void SwapChunkResponse::clear_chunkname2() {
  if (chunkname2_ != &_default_chunkname2_) {
    chunkname2_->clear();
  }
  _clear_bit(5);
}
inline const ::std::string& SwapChunkResponse::chunkname2() const {
  return *chunkname2_;
}
inline void SwapChunkResponse::set_chunkname2(const ::std::string& value) {
  _set_bit(5);
  if (chunkname2_ == &_default_chunkname2_) {
    chunkname2_ = new ::std::string;
  }
  chunkname2_->assign(value);
}
inline void SwapChunkResponse::set_chunkname2(const char* value) {
  _set_bit(5);
  if (chunkname2_ == &_default_chunkname2_) {
    chunkname2_ = new ::std::string;
  }
  chunkname2_->assign(value);
}
inline void SwapChunkResponse::set_chunkname2(const void* value, size_t size) {
  _set_bit(5);
  if (chunkname2_ == &_default_chunkname2_) {
    chunkname2_ = new ::std::string;
  }
  chunkname2_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SwapChunkResponse::mutable_chunkname2() {
  _set_bit(5);
  if (chunkname2_ == &_default_chunkname2_) {
    chunkname2_ = new ::std::string;
  }
  return chunkname2_;
}

// optional bytes chunkcontent2 = 7;
inline bool SwapChunkResponse::has_chunkcontent2() const {
  return _has_bit(6);
}
inline void SwapChunkResponse::clear_chunkcontent2() {
  if (chunkcontent2_ != &_default_chunkcontent2_) {
    chunkcontent2_->clear();
  }
  _clear_bit(6);
}
inline const ::std::string& SwapChunkResponse::chunkcontent2() const {
  return *chunkcontent2_;
}
inline void SwapChunkResponse::set_chunkcontent2(const ::std::string& value) {
  _set_bit(6);
  if (chunkcontent2_ == &_default_chunkcontent2_) {
    chunkcontent2_ = new ::std::string;
  }
  chunkcontent2_->assign(value);
}
inline void SwapChunkResponse::set_chunkcontent2(const char* value) {
  _set_bit(6);
  if (chunkcontent2_ == &_default_chunkcontent2_) {
    chunkcontent2_ = new ::std::string;
  }
  chunkcontent2_->assign(value);
}
inline void SwapChunkResponse::set_chunkcontent2(const void* value, size_t size) {
  _set_bit(6);
  if (chunkcontent2_ == &_default_chunkcontent2_) {
    chunkcontent2_ = new ::std::string;
  }
  chunkcontent2_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SwapChunkResponse::mutable_chunkcontent2() {
  _set_bit(6);
  if (chunkcontent2_ == &_default_chunkcontent2_) {
    chunkcontent2_ = new ::std::string;
  }
  return chunkcontent2_;
}

// optional int32 size2 = 8;
inline bool SwapChunkResponse::has_size2() const {
  return _has_bit(7);
}
inline void SwapChunkResponse::clear_size2() {
  size2_ = 0;
  _clear_bit(7);
}
inline ::google::protobuf::int32 SwapChunkResponse::size2() const {
  return size2_;
}
inline void SwapChunkResponse::set_size2(::google::protobuf::int32 value) {
  _set_bit(7);
  size2_ = value;
}

// required bytes pmid = 9;
inline bool SwapChunkResponse::has_pmid() const {
  return _has_bit(8);
}
inline void SwapChunkResponse::clear_pmid() {
  if (pmid_ != &_default_pmid_) {
    pmid_->clear();
  }
  _clear_bit(8);
}
inline const ::std::string& SwapChunkResponse::pmid() const {
  return *pmid_;
}
inline void SwapChunkResponse::set_pmid(const ::std::string& value) {
  _set_bit(8);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(value);
}
inline void SwapChunkResponse::set_pmid(const char* value) {
  _set_bit(8);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(value);
}
inline void SwapChunkResponse::set_pmid(const void* value, size_t size) {
  _set_bit(8);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SwapChunkResponse::mutable_pmid() {
  _set_bit(8);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  return pmid_;
}

// -------------------------------------------------------------------

// VaultCommunication

// optional bytes chunkstore = 1;
inline bool VaultCommunication::has_chunkstore() const {
  return _has_bit(0);
}
inline void VaultCommunication::clear_chunkstore() {
  if (chunkstore_ != &_default_chunkstore_) {
    chunkstore_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& VaultCommunication::chunkstore() const {
  return *chunkstore_;
}
inline void VaultCommunication::set_chunkstore(const ::std::string& value) {
  _set_bit(0);
  if (chunkstore_ == &_default_chunkstore_) {
    chunkstore_ = new ::std::string;
  }
  chunkstore_->assign(value);
}
inline void VaultCommunication::set_chunkstore(const char* value) {
  _set_bit(0);
  if (chunkstore_ == &_default_chunkstore_) {
    chunkstore_ = new ::std::string;
  }
  chunkstore_->assign(value);
}
inline void VaultCommunication::set_chunkstore(const void* value, size_t size) {
  _set_bit(0);
  if (chunkstore_ == &_default_chunkstore_) {
    chunkstore_ = new ::std::string;
  }
  chunkstore_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VaultCommunication::mutable_chunkstore() {
  _set_bit(0);
  if (chunkstore_ == &_default_chunkstore_) {
    chunkstore_ = new ::std::string;
  }
  return chunkstore_;
}

// optional uint64 offered_space = 2;
inline bool VaultCommunication::has_offered_space() const {
  return _has_bit(1);
}
inline void VaultCommunication::clear_offered_space() {
  offered_space_ = GOOGLE_ULONGLONG(0);
  _clear_bit(1);
}
inline ::google::protobuf::uint64 VaultCommunication::offered_space() const {
  return offered_space_;
}
inline void VaultCommunication::set_offered_space(::google::protobuf::uint64 value) {
  _set_bit(1);
  offered_space_ = value;
}

// optional uint64 free_space = 3;
inline bool VaultCommunication::has_free_space() const {
  return _has_bit(2);
}
inline void VaultCommunication::clear_free_space() {
  free_space_ = GOOGLE_ULONGLONG(0);
  _clear_bit(2);
}
inline ::google::protobuf::uint64 VaultCommunication::free_space() const {
  return free_space_;
}
inline void VaultCommunication::set_free_space(::google::protobuf::uint64 value) {
  _set_bit(2);
  free_space_ = value;
}

// optional bytes ip = 4;
inline bool VaultCommunication::has_ip() const {
  return _has_bit(3);
}
inline void VaultCommunication::clear_ip() {
  if (ip_ != &_default_ip_) {
    ip_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& VaultCommunication::ip() const {
  return *ip_;
}
inline void VaultCommunication::set_ip(const ::std::string& value) {
  _set_bit(3);
  if (ip_ == &_default_ip_) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void VaultCommunication::set_ip(const char* value) {
  _set_bit(3);
  if (ip_ == &_default_ip_) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void VaultCommunication::set_ip(const void* value, size_t size) {
  _set_bit(3);
  if (ip_ == &_default_ip_) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VaultCommunication::mutable_ip() {
  _set_bit(3);
  if (ip_ == &_default_ip_) {
    ip_ = new ::std::string;
  }
  return ip_;
}

// optional uint32 port = 5;
inline bool VaultCommunication::has_port() const {
  return _has_bit(4);
}
inline void VaultCommunication::clear_port() {
  port_ = 0u;
  _clear_bit(4);
}
inline ::google::protobuf::uint32 VaultCommunication::port() const {
  return port_;
}
inline void VaultCommunication::set_port(::google::protobuf::uint32 value) {
  _set_bit(4);
  port_ = value;
}

// required uint32 timestamp = 6;
inline bool VaultCommunication::has_timestamp() const {
  return _has_bit(5);
}
inline void VaultCommunication::clear_timestamp() {
  timestamp_ = 0u;
  _clear_bit(5);
}
inline ::google::protobuf::uint32 VaultCommunication::timestamp() const {
  return timestamp_;
}
inline void VaultCommunication::set_timestamp(::google::protobuf::uint32 value) {
  _set_bit(5);
  timestamp_ = value;
}

// -------------------------------------------------------------------

// VaultStatusRequest

// required bytes encrypted_request = 1;
inline bool VaultStatusRequest::has_encrypted_request() const {
  return _has_bit(0);
}
inline void VaultStatusRequest::clear_encrypted_request() {
  if (encrypted_request_ != &_default_encrypted_request_) {
    encrypted_request_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& VaultStatusRequest::encrypted_request() const {
  return *encrypted_request_;
}
inline void VaultStatusRequest::set_encrypted_request(const ::std::string& value) {
  _set_bit(0);
  if (encrypted_request_ == &_default_encrypted_request_) {
    encrypted_request_ = new ::std::string;
  }
  encrypted_request_->assign(value);
}
inline void VaultStatusRequest::set_encrypted_request(const char* value) {
  _set_bit(0);
  if (encrypted_request_ == &_default_encrypted_request_) {
    encrypted_request_ = new ::std::string;
  }
  encrypted_request_->assign(value);
}
inline void VaultStatusRequest::set_encrypted_request(const void* value, size_t size) {
  _set_bit(0);
  if (encrypted_request_ == &_default_encrypted_request_) {
    encrypted_request_ = new ::std::string;
  }
  encrypted_request_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VaultStatusRequest::mutable_encrypted_request() {
  _set_bit(0);
  if (encrypted_request_ == &_default_encrypted_request_) {
    encrypted_request_ = new ::std::string;
  }
  return encrypted_request_;
}

// -------------------------------------------------------------------

// VaultStatusResponse

// required uint32 result = 1;
inline bool VaultStatusResponse::has_result() const {
  return _has_bit(0);
}
inline void VaultStatusResponse::clear_result() {
  result_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 VaultStatusResponse::result() const {
  return result_;
}
inline void VaultStatusResponse::set_result(::google::protobuf::uint32 value) {
  _set_bit(0);
  result_ = value;
}

// optional bytes encrypted_response = 2;
inline bool VaultStatusResponse::has_encrypted_response() const {
  return _has_bit(1);
}
inline void VaultStatusResponse::clear_encrypted_response() {
  if (encrypted_response_ != &_default_encrypted_response_) {
    encrypted_response_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& VaultStatusResponse::encrypted_response() const {
  return *encrypted_response_;
}
inline void VaultStatusResponse::set_encrypted_response(const ::std::string& value) {
  _set_bit(1);
  if (encrypted_response_ == &_default_encrypted_response_) {
    encrypted_response_ = new ::std::string;
  }
  encrypted_response_->assign(value);
}
inline void VaultStatusResponse::set_encrypted_response(const char* value) {
  _set_bit(1);
  if (encrypted_response_ == &_default_encrypted_response_) {
    encrypted_response_ = new ::std::string;
  }
  encrypted_response_->assign(value);
}
inline void VaultStatusResponse::set_encrypted_response(const void* value, size_t size) {
  _set_bit(1);
  if (encrypted_response_ == &_default_encrypted_response_) {
    encrypted_response_ = new ::std::string;
  }
  encrypted_response_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VaultStatusResponse::mutable_encrypted_response() {
  _set_bit(1);
  if (encrypted_response_ == &_default_encrypted_response_) {
    encrypted_response_ = new ::std::string;
  }
  return encrypted_response_;
}

// -------------------------------------------------------------------

// OwnVaultRequest

// required bytes public_key = 1;
inline bool OwnVaultRequest::has_public_key() const {
  return _has_bit(0);
}
inline void OwnVaultRequest::clear_public_key() {
  if (public_key_ != &_default_public_key_) {
    public_key_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& OwnVaultRequest::public_key() const {
  return *public_key_;
}
inline void OwnVaultRequest::set_public_key(const ::std::string& value) {
  _set_bit(0);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void OwnVaultRequest::set_public_key(const char* value) {
  _set_bit(0);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void OwnVaultRequest::set_public_key(const void* value, size_t size) {
  _set_bit(0);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OwnVaultRequest::mutable_public_key() {
  _set_bit(0);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  return public_key_;
}

// required bytes private_key = 2;
inline bool OwnVaultRequest::has_private_key() const {
  return _has_bit(1);
}
inline void OwnVaultRequest::clear_private_key() {
  if (private_key_ != &_default_private_key_) {
    private_key_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& OwnVaultRequest::private_key() const {
  return *private_key_;
}
inline void OwnVaultRequest::set_private_key(const ::std::string& value) {
  _set_bit(1);
  if (private_key_ == &_default_private_key_) {
    private_key_ = new ::std::string;
  }
  private_key_->assign(value);
}
inline void OwnVaultRequest::set_private_key(const char* value) {
  _set_bit(1);
  if (private_key_ == &_default_private_key_) {
    private_key_ = new ::std::string;
  }
  private_key_->assign(value);
}
inline void OwnVaultRequest::set_private_key(const void* value, size_t size) {
  _set_bit(1);
  if (private_key_ == &_default_private_key_) {
    private_key_ = new ::std::string;
  }
  private_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OwnVaultRequest::mutable_private_key() {
  _set_bit(1);
  if (private_key_ == &_default_private_key_) {
    private_key_ = new ::std::string;
  }
  return private_key_;
}

// required bytes signed_public_key = 3;
inline bool OwnVaultRequest::has_signed_public_key() const {
  return _has_bit(2);
}
inline void OwnVaultRequest::clear_signed_public_key() {
  if (signed_public_key_ != &_default_signed_public_key_) {
    signed_public_key_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& OwnVaultRequest::signed_public_key() const {
  return *signed_public_key_;
}
inline void OwnVaultRequest::set_signed_public_key(const ::std::string& value) {
  _set_bit(2);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  signed_public_key_->assign(value);
}
inline void OwnVaultRequest::set_signed_public_key(const char* value) {
  _set_bit(2);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  signed_public_key_->assign(value);
}
inline void OwnVaultRequest::set_signed_public_key(const void* value, size_t size) {
  _set_bit(2);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  signed_public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OwnVaultRequest::mutable_signed_public_key() {
  _set_bit(2);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  return signed_public_key_;
}

// required bytes chunkstore_dir = 4;
inline bool OwnVaultRequest::has_chunkstore_dir() const {
  return _has_bit(3);
}
inline void OwnVaultRequest::clear_chunkstore_dir() {
  if (chunkstore_dir_ != &_default_chunkstore_dir_) {
    chunkstore_dir_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& OwnVaultRequest::chunkstore_dir() const {
  return *chunkstore_dir_;
}
inline void OwnVaultRequest::set_chunkstore_dir(const ::std::string& value) {
  _set_bit(3);
  if (chunkstore_dir_ == &_default_chunkstore_dir_) {
    chunkstore_dir_ = new ::std::string;
  }
  chunkstore_dir_->assign(value);
}
inline void OwnVaultRequest::set_chunkstore_dir(const char* value) {
  _set_bit(3);
  if (chunkstore_dir_ == &_default_chunkstore_dir_) {
    chunkstore_dir_ = new ::std::string;
  }
  chunkstore_dir_->assign(value);
}
inline void OwnVaultRequest::set_chunkstore_dir(const void* value, size_t size) {
  _set_bit(3);
  if (chunkstore_dir_ == &_default_chunkstore_dir_) {
    chunkstore_dir_ = new ::std::string;
  }
  chunkstore_dir_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OwnVaultRequest::mutable_chunkstore_dir() {
  _set_bit(3);
  if (chunkstore_dir_ == &_default_chunkstore_dir_) {
    chunkstore_dir_ = new ::std::string;
  }
  return chunkstore_dir_;
}

// required uint32 port = 5;
inline bool OwnVaultRequest::has_port() const {
  return _has_bit(4);
}
inline void OwnVaultRequest::clear_port() {
  port_ = 0u;
  _clear_bit(4);
}
inline ::google::protobuf::uint32 OwnVaultRequest::port() const {
  return port_;
}
inline void OwnVaultRequest::set_port(::google::protobuf::uint32 value) {
  _set_bit(4);
  port_ = value;
}

// required uint64 space = 6;
inline bool OwnVaultRequest::has_space() const {
  return _has_bit(5);
}
inline void OwnVaultRequest::clear_space() {
  space_ = GOOGLE_ULONGLONG(0);
  _clear_bit(5);
}
inline ::google::protobuf::uint64 OwnVaultRequest::space() const {
  return space_;
}
inline void OwnVaultRequest::set_space(::google::protobuf::uint64 value) {
  _set_bit(5);
  space_ = value;
}

// -------------------------------------------------------------------

// OwnVaultResponse

// required .maidsafe.OwnVaultResult result = 1;
inline bool OwnVaultResponse::has_result() const {
  return _has_bit(0);
}
inline void OwnVaultResponse::clear_result() {
  result_ = 0;
  _clear_bit(0);
}
inline maidsafe::OwnVaultResult OwnVaultResponse::result() const {
  return static_cast< maidsafe::OwnVaultResult >(result_);
}
inline void OwnVaultResponse::set_result(maidsafe::OwnVaultResult value) {
  GOOGLE_DCHECK(maidsafe::OwnVaultResult_IsValid(value));
  _set_bit(0);
  result_ = value;
}

// optional bytes pmid_name = 2;
inline bool OwnVaultResponse::has_pmid_name() const {
  return _has_bit(1);
}
inline void OwnVaultResponse::clear_pmid_name() {
  if (pmid_name_ != &_default_pmid_name_) {
    pmid_name_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& OwnVaultResponse::pmid_name() const {
  return *pmid_name_;
}
inline void OwnVaultResponse::set_pmid_name(const ::std::string& value) {
  _set_bit(1);
  if (pmid_name_ == &_default_pmid_name_) {
    pmid_name_ = new ::std::string;
  }
  pmid_name_->assign(value);
}
inline void OwnVaultResponse::set_pmid_name(const char* value) {
  _set_bit(1);
  if (pmid_name_ == &_default_pmid_name_) {
    pmid_name_ = new ::std::string;
  }
  pmid_name_->assign(value);
}
inline void OwnVaultResponse::set_pmid_name(const void* value, size_t size) {
  _set_bit(1);
  if (pmid_name_ == &_default_pmid_name_) {
    pmid_name_ = new ::std::string;
  }
  pmid_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OwnVaultResponse::mutable_pmid_name() {
  _set_bit(1);
  if (pmid_name_ == &_default_pmid_name_) {
    pmid_name_ = new ::std::string;
  }
  return pmid_name_;
}

// -------------------------------------------------------------------

// IsOwnedRequest

// -------------------------------------------------------------------

// IsOwnedResponse

// required .maidsafe.VaultStatus status = 1;
inline bool IsOwnedResponse::has_status() const {
  return _has_bit(0);
}
inline void IsOwnedResponse::clear_status() {
  status_ = 0;
  _clear_bit(0);
}
inline maidsafe::VaultStatus IsOwnedResponse::status() const {
  return static_cast< maidsafe::VaultStatus >(status_);
}
inline void IsOwnedResponse::set_status(maidsafe::VaultStatus value) {
  GOOGLE_DCHECK(maidsafe::VaultStatus_IsValid(value));
  _set_bit(0);
  status_ = value;
}

// -------------------------------------------------------------------

// CreateBPRequest

// required bytes bufferpacket_name = 1;
inline bool CreateBPRequest::has_bufferpacket_name() const {
  return _has_bit(0);
}
inline void CreateBPRequest::clear_bufferpacket_name() {
  if (bufferpacket_name_ != &_default_bufferpacket_name_) {
    bufferpacket_name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& CreateBPRequest::bufferpacket_name() const {
  return *bufferpacket_name_;
}
inline void CreateBPRequest::set_bufferpacket_name(const ::std::string& value) {
  _set_bit(0);
  if (bufferpacket_name_ == &_default_bufferpacket_name_) {
    bufferpacket_name_ = new ::std::string;
  }
  bufferpacket_name_->assign(value);
}
inline void CreateBPRequest::set_bufferpacket_name(const char* value) {
  _set_bit(0);
  if (bufferpacket_name_ == &_default_bufferpacket_name_) {
    bufferpacket_name_ = new ::std::string;
  }
  bufferpacket_name_->assign(value);
}
inline void CreateBPRequest::set_bufferpacket_name(const void* value, size_t size) {
  _set_bit(0);
  if (bufferpacket_name_ == &_default_bufferpacket_name_) {
    bufferpacket_name_ = new ::std::string;
  }
  bufferpacket_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreateBPRequest::mutable_bufferpacket_name() {
  _set_bit(0);
  if (bufferpacket_name_ == &_default_bufferpacket_name_) {
    bufferpacket_name_ = new ::std::string;
  }
  return bufferpacket_name_;
}

// required bytes data = 2;
inline bool CreateBPRequest::has_data() const {
  return _has_bit(1);
}
inline void CreateBPRequest::clear_data() {
  if (data_ != &_default_data_) {
    data_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& CreateBPRequest::data() const {
  return *data_;
}
inline void CreateBPRequest::set_data(const ::std::string& value) {
  _set_bit(1);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void CreateBPRequest::set_data(const char* value) {
  _set_bit(1);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void CreateBPRequest::set_data(const void* value, size_t size) {
  _set_bit(1);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreateBPRequest::mutable_data() {
  _set_bit(1);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  return data_;
}

// required bytes pmid = 3;
inline bool CreateBPRequest::has_pmid() const {
  return _has_bit(2);
}
inline void CreateBPRequest::clear_pmid() {
  if (pmid_ != &_default_pmid_) {
    pmid_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& CreateBPRequest::pmid() const {
  return *pmid_;
}
inline void CreateBPRequest::set_pmid(const ::std::string& value) {
  _set_bit(2);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(value);
}
inline void CreateBPRequest::set_pmid(const char* value) {
  _set_bit(2);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(value);
}
inline void CreateBPRequest::set_pmid(const void* value, size_t size) {
  _set_bit(2);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreateBPRequest::mutable_pmid() {
  _set_bit(2);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  return pmid_;
}

// required bytes public_key = 4;
inline bool CreateBPRequest::has_public_key() const {
  return _has_bit(3);
}
inline void CreateBPRequest::clear_public_key() {
  if (public_key_ != &_default_public_key_) {
    public_key_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& CreateBPRequest::public_key() const {
  return *public_key_;
}
inline void CreateBPRequest::set_public_key(const ::std::string& value) {
  _set_bit(3);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void CreateBPRequest::set_public_key(const char* value) {
  _set_bit(3);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void CreateBPRequest::set_public_key(const void* value, size_t size) {
  _set_bit(3);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreateBPRequest::mutable_public_key() {
  _set_bit(3);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  return public_key_;
}

// required bytes signed_public_key = 5;
inline bool CreateBPRequest::has_signed_public_key() const {
  return _has_bit(4);
}
inline void CreateBPRequest::clear_signed_public_key() {
  if (signed_public_key_ != &_default_signed_public_key_) {
    signed_public_key_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& CreateBPRequest::signed_public_key() const {
  return *signed_public_key_;
}
inline void CreateBPRequest::set_signed_public_key(const ::std::string& value) {
  _set_bit(4);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  signed_public_key_->assign(value);
}
inline void CreateBPRequest::set_signed_public_key(const char* value) {
  _set_bit(4);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  signed_public_key_->assign(value);
}
inline void CreateBPRequest::set_signed_public_key(const void* value, size_t size) {
  _set_bit(4);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  signed_public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreateBPRequest::mutable_signed_public_key() {
  _set_bit(4);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  return signed_public_key_;
}

// required bytes signed_request = 6;
inline bool CreateBPRequest::has_signed_request() const {
  return _has_bit(5);
}
inline void CreateBPRequest::clear_signed_request() {
  if (signed_request_ != &_default_signed_request_) {
    signed_request_->clear();
  }
  _clear_bit(5);
}
inline const ::std::string& CreateBPRequest::signed_request() const {
  return *signed_request_;
}
inline void CreateBPRequest::set_signed_request(const ::std::string& value) {
  _set_bit(5);
  if (signed_request_ == &_default_signed_request_) {
    signed_request_ = new ::std::string;
  }
  signed_request_->assign(value);
}
inline void CreateBPRequest::set_signed_request(const char* value) {
  _set_bit(5);
  if (signed_request_ == &_default_signed_request_) {
    signed_request_ = new ::std::string;
  }
  signed_request_->assign(value);
}
inline void CreateBPRequest::set_signed_request(const void* value, size_t size) {
  _set_bit(5);
  if (signed_request_ == &_default_signed_request_) {
    signed_request_ = new ::std::string;
  }
  signed_request_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreateBPRequest::mutable_signed_request() {
  _set_bit(5);
  if (signed_request_ == &_default_signed_request_) {
    signed_request_ = new ::std::string;
  }
  return signed_request_;
}

// -------------------------------------------------------------------

// CreateBPResponse

// required uint32 result = 1;
inline bool CreateBPResponse::has_result() const {
  return _has_bit(0);
}
inline void CreateBPResponse::clear_result() {
  result_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 CreateBPResponse::result() const {
  return result_;
}
inline void CreateBPResponse::set_result(::google::protobuf::uint32 value) {
  _set_bit(0);
  result_ = value;
}

// optional bytes pmid_id = 2;
inline bool CreateBPResponse::has_pmid_id() const {
  return _has_bit(1);
}
inline void CreateBPResponse::clear_pmid_id() {
  if (pmid_id_ != &_default_pmid_id_) {
    pmid_id_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& CreateBPResponse::pmid_id() const {
  return *pmid_id_;
}
inline void CreateBPResponse::set_pmid_id(const ::std::string& value) {
  _set_bit(1);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  pmid_id_->assign(value);
}
inline void CreateBPResponse::set_pmid_id(const char* value) {
  _set_bit(1);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  pmid_id_->assign(value);
}
inline void CreateBPResponse::set_pmid_id(const void* value, size_t size) {
  _set_bit(1);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  pmid_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreateBPResponse::mutable_pmid_id() {
  _set_bit(1);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  return pmid_id_;
}

// optional bytes public_key = 3;
inline bool CreateBPResponse::has_public_key() const {
  return _has_bit(2);
}
inline void CreateBPResponse::clear_public_key() {
  if (public_key_ != &_default_public_key_) {
    public_key_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& CreateBPResponse::public_key() const {
  return *public_key_;
}
inline void CreateBPResponse::set_public_key(const ::std::string& value) {
  _set_bit(2);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void CreateBPResponse::set_public_key(const char* value) {
  _set_bit(2);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void CreateBPResponse::set_public_key(const void* value, size_t size) {
  _set_bit(2);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreateBPResponse::mutable_public_key() {
  _set_bit(2);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  return public_key_;
}

// optional bytes signed_public_key = 4;
inline bool CreateBPResponse::has_signed_public_key() const {
  return _has_bit(3);
}
inline void CreateBPResponse::clear_signed_public_key() {
  if (signed_public_key_ != &_default_signed_public_key_) {
    signed_public_key_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& CreateBPResponse::signed_public_key() const {
  return *signed_public_key_;
}
inline void CreateBPResponse::set_signed_public_key(const ::std::string& value) {
  _set_bit(3);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  signed_public_key_->assign(value);
}
inline void CreateBPResponse::set_signed_public_key(const char* value) {
  _set_bit(3);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  signed_public_key_->assign(value);
}
inline void CreateBPResponse::set_signed_public_key(const void* value, size_t size) {
  _set_bit(3);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  signed_public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreateBPResponse::mutable_signed_public_key() {
  _set_bit(3);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  return signed_public_key_;
}

// -------------------------------------------------------------------

// ModifyBPInfoRequest

// required bytes bufferpacket_name = 1;
inline bool ModifyBPInfoRequest::has_bufferpacket_name() const {
  return _has_bit(0);
}
inline void ModifyBPInfoRequest::clear_bufferpacket_name() {
  if (bufferpacket_name_ != &_default_bufferpacket_name_) {
    bufferpacket_name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& ModifyBPInfoRequest::bufferpacket_name() const {
  return *bufferpacket_name_;
}
inline void ModifyBPInfoRequest::set_bufferpacket_name(const ::std::string& value) {
  _set_bit(0);
  if (bufferpacket_name_ == &_default_bufferpacket_name_) {
    bufferpacket_name_ = new ::std::string;
  }
  bufferpacket_name_->assign(value);
}
inline void ModifyBPInfoRequest::set_bufferpacket_name(const char* value) {
  _set_bit(0);
  if (bufferpacket_name_ == &_default_bufferpacket_name_) {
    bufferpacket_name_ = new ::std::string;
  }
  bufferpacket_name_->assign(value);
}
inline void ModifyBPInfoRequest::set_bufferpacket_name(const void* value, size_t size) {
  _set_bit(0);
  if (bufferpacket_name_ == &_default_bufferpacket_name_) {
    bufferpacket_name_ = new ::std::string;
  }
  bufferpacket_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModifyBPInfoRequest::mutable_bufferpacket_name() {
  _set_bit(0);
  if (bufferpacket_name_ == &_default_bufferpacket_name_) {
    bufferpacket_name_ = new ::std::string;
  }
  return bufferpacket_name_;
}

// required bytes data = 2;
inline bool ModifyBPInfoRequest::has_data() const {
  return _has_bit(1);
}
inline void ModifyBPInfoRequest::clear_data() {
  if (data_ != &_default_data_) {
    data_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& ModifyBPInfoRequest::data() const {
  return *data_;
}
inline void ModifyBPInfoRequest::set_data(const ::std::string& value) {
  _set_bit(1);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void ModifyBPInfoRequest::set_data(const char* value) {
  _set_bit(1);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void ModifyBPInfoRequest::set_data(const void* value, size_t size) {
  _set_bit(1);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModifyBPInfoRequest::mutable_data() {
  _set_bit(1);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  return data_;
}

// required bytes pmid = 3;
inline bool ModifyBPInfoRequest::has_pmid() const {
  return _has_bit(2);
}
inline void ModifyBPInfoRequest::clear_pmid() {
  if (pmid_ != &_default_pmid_) {
    pmid_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& ModifyBPInfoRequest::pmid() const {
  return *pmid_;
}
inline void ModifyBPInfoRequest::set_pmid(const ::std::string& value) {
  _set_bit(2);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(value);
}
inline void ModifyBPInfoRequest::set_pmid(const char* value) {
  _set_bit(2);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(value);
}
inline void ModifyBPInfoRequest::set_pmid(const void* value, size_t size) {
  _set_bit(2);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModifyBPInfoRequest::mutable_pmid() {
  _set_bit(2);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  return pmid_;
}

// required bytes public_key = 4;
inline bool ModifyBPInfoRequest::has_public_key() const {
  return _has_bit(3);
}
inline void ModifyBPInfoRequest::clear_public_key() {
  if (public_key_ != &_default_public_key_) {
    public_key_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& ModifyBPInfoRequest::public_key() const {
  return *public_key_;
}
inline void ModifyBPInfoRequest::set_public_key(const ::std::string& value) {
  _set_bit(3);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void ModifyBPInfoRequest::set_public_key(const char* value) {
  _set_bit(3);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void ModifyBPInfoRequest::set_public_key(const void* value, size_t size) {
  _set_bit(3);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModifyBPInfoRequest::mutable_public_key() {
  _set_bit(3);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  return public_key_;
}

// required bytes signed_public_key = 5;
inline bool ModifyBPInfoRequest::has_signed_public_key() const {
  return _has_bit(4);
}
inline void ModifyBPInfoRequest::clear_signed_public_key() {
  if (signed_public_key_ != &_default_signed_public_key_) {
    signed_public_key_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& ModifyBPInfoRequest::signed_public_key() const {
  return *signed_public_key_;
}
inline void ModifyBPInfoRequest::set_signed_public_key(const ::std::string& value) {
  _set_bit(4);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  signed_public_key_->assign(value);
}
inline void ModifyBPInfoRequest::set_signed_public_key(const char* value) {
  _set_bit(4);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  signed_public_key_->assign(value);
}
inline void ModifyBPInfoRequest::set_signed_public_key(const void* value, size_t size) {
  _set_bit(4);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  signed_public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModifyBPInfoRequest::mutable_signed_public_key() {
  _set_bit(4);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  return signed_public_key_;
}

// required bytes signed_request = 6;
inline bool ModifyBPInfoRequest::has_signed_request() const {
  return _has_bit(5);
}
inline void ModifyBPInfoRequest::clear_signed_request() {
  if (signed_request_ != &_default_signed_request_) {
    signed_request_->clear();
  }
  _clear_bit(5);
}
inline const ::std::string& ModifyBPInfoRequest::signed_request() const {
  return *signed_request_;
}
inline void ModifyBPInfoRequest::set_signed_request(const ::std::string& value) {
  _set_bit(5);
  if (signed_request_ == &_default_signed_request_) {
    signed_request_ = new ::std::string;
  }
  signed_request_->assign(value);
}
inline void ModifyBPInfoRequest::set_signed_request(const char* value) {
  _set_bit(5);
  if (signed_request_ == &_default_signed_request_) {
    signed_request_ = new ::std::string;
  }
  signed_request_->assign(value);
}
inline void ModifyBPInfoRequest::set_signed_request(const void* value, size_t size) {
  _set_bit(5);
  if (signed_request_ == &_default_signed_request_) {
    signed_request_ = new ::std::string;
  }
  signed_request_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModifyBPInfoRequest::mutable_signed_request() {
  _set_bit(5);
  if (signed_request_ == &_default_signed_request_) {
    signed_request_ = new ::std::string;
  }
  return signed_request_;
}

// -------------------------------------------------------------------

// ModifyBPInfoResponse

// required uint32 result = 1;
inline bool ModifyBPInfoResponse::has_result() const {
  return _has_bit(0);
}
inline void ModifyBPInfoResponse::clear_result() {
  result_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 ModifyBPInfoResponse::result() const {
  return result_;
}
inline void ModifyBPInfoResponse::set_result(::google::protobuf::uint32 value) {
  _set_bit(0);
  result_ = value;
}

// optional bytes pmid_id = 2;
inline bool ModifyBPInfoResponse::has_pmid_id() const {
  return _has_bit(1);
}
inline void ModifyBPInfoResponse::clear_pmid_id() {
  if (pmid_id_ != &_default_pmid_id_) {
    pmid_id_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& ModifyBPInfoResponse::pmid_id() const {
  return *pmid_id_;
}
inline void ModifyBPInfoResponse::set_pmid_id(const ::std::string& value) {
  _set_bit(1);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  pmid_id_->assign(value);
}
inline void ModifyBPInfoResponse::set_pmid_id(const char* value) {
  _set_bit(1);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  pmid_id_->assign(value);
}
inline void ModifyBPInfoResponse::set_pmid_id(const void* value, size_t size) {
  _set_bit(1);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  pmid_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModifyBPInfoResponse::mutable_pmid_id() {
  _set_bit(1);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  return pmid_id_;
}

// optional bytes public_key = 3;
inline bool ModifyBPInfoResponse::has_public_key() const {
  return _has_bit(2);
}
inline void ModifyBPInfoResponse::clear_public_key() {
  if (public_key_ != &_default_public_key_) {
    public_key_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& ModifyBPInfoResponse::public_key() const {
  return *public_key_;
}
inline void ModifyBPInfoResponse::set_public_key(const ::std::string& value) {
  _set_bit(2);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void ModifyBPInfoResponse::set_public_key(const char* value) {
  _set_bit(2);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void ModifyBPInfoResponse::set_public_key(const void* value, size_t size) {
  _set_bit(2);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModifyBPInfoResponse::mutable_public_key() {
  _set_bit(2);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  return public_key_;
}

// optional bytes signed_public_key = 4;
inline bool ModifyBPInfoResponse::has_signed_public_key() const {
  return _has_bit(3);
}
inline void ModifyBPInfoResponse::clear_signed_public_key() {
  if (signed_public_key_ != &_default_signed_public_key_) {
    signed_public_key_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& ModifyBPInfoResponse::signed_public_key() const {
  return *signed_public_key_;
}
inline void ModifyBPInfoResponse::set_signed_public_key(const ::std::string& value) {
  _set_bit(3);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  signed_public_key_->assign(value);
}
inline void ModifyBPInfoResponse::set_signed_public_key(const char* value) {
  _set_bit(3);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  signed_public_key_->assign(value);
}
inline void ModifyBPInfoResponse::set_signed_public_key(const void* value, size_t size) {
  _set_bit(3);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  signed_public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModifyBPInfoResponse::mutable_signed_public_key() {
  _set_bit(3);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  return signed_public_key_;
}

// -------------------------------------------------------------------

// GetBPMessagesRequest

// required bytes bufferpacket_name = 1;
inline bool GetBPMessagesRequest::has_bufferpacket_name() const {
  return _has_bit(0);
}
inline void GetBPMessagesRequest::clear_bufferpacket_name() {
  if (bufferpacket_name_ != &_default_bufferpacket_name_) {
    bufferpacket_name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& GetBPMessagesRequest::bufferpacket_name() const {
  return *bufferpacket_name_;
}
inline void GetBPMessagesRequest::set_bufferpacket_name(const ::std::string& value) {
  _set_bit(0);
  if (bufferpacket_name_ == &_default_bufferpacket_name_) {
    bufferpacket_name_ = new ::std::string;
  }
  bufferpacket_name_->assign(value);
}
inline void GetBPMessagesRequest::set_bufferpacket_name(const char* value) {
  _set_bit(0);
  if (bufferpacket_name_ == &_default_bufferpacket_name_) {
    bufferpacket_name_ = new ::std::string;
  }
  bufferpacket_name_->assign(value);
}
inline void GetBPMessagesRequest::set_bufferpacket_name(const void* value, size_t size) {
  _set_bit(0);
  if (bufferpacket_name_ == &_default_bufferpacket_name_) {
    bufferpacket_name_ = new ::std::string;
  }
  bufferpacket_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetBPMessagesRequest::mutable_bufferpacket_name() {
  _set_bit(0);
  if (bufferpacket_name_ == &_default_bufferpacket_name_) {
    bufferpacket_name_ = new ::std::string;
  }
  return bufferpacket_name_;
}

// required bytes public_key = 2;
inline bool GetBPMessagesRequest::has_public_key() const {
  return _has_bit(1);
}
inline void GetBPMessagesRequest::clear_public_key() {
  if (public_key_ != &_default_public_key_) {
    public_key_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& GetBPMessagesRequest::public_key() const {
  return *public_key_;
}
inline void GetBPMessagesRequest::set_public_key(const ::std::string& value) {
  _set_bit(1);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void GetBPMessagesRequest::set_public_key(const char* value) {
  _set_bit(1);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void GetBPMessagesRequest::set_public_key(const void* value, size_t size) {
  _set_bit(1);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetBPMessagesRequest::mutable_public_key() {
  _set_bit(1);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  return public_key_;
}

// required bytes pmid = 3;
inline bool GetBPMessagesRequest::has_pmid() const {
  return _has_bit(2);
}
inline void GetBPMessagesRequest::clear_pmid() {
  if (pmid_ != &_default_pmid_) {
    pmid_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& GetBPMessagesRequest::pmid() const {
  return *pmid_;
}
inline void GetBPMessagesRequest::set_pmid(const ::std::string& value) {
  _set_bit(2);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(value);
}
inline void GetBPMessagesRequest::set_pmid(const char* value) {
  _set_bit(2);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(value);
}
inline void GetBPMessagesRequest::set_pmid(const void* value, size_t size) {
  _set_bit(2);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetBPMessagesRequest::mutable_pmid() {
  _set_bit(2);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  return pmid_;
}

// required bytes signed_public_key = 4;
inline bool GetBPMessagesRequest::has_signed_public_key() const {
  return _has_bit(3);
}
inline void GetBPMessagesRequest::clear_signed_public_key() {
  if (signed_public_key_ != &_default_signed_public_key_) {
    signed_public_key_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& GetBPMessagesRequest::signed_public_key() const {
  return *signed_public_key_;
}
inline void GetBPMessagesRequest::set_signed_public_key(const ::std::string& value) {
  _set_bit(3);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  signed_public_key_->assign(value);
}
inline void GetBPMessagesRequest::set_signed_public_key(const char* value) {
  _set_bit(3);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  signed_public_key_->assign(value);
}
inline void GetBPMessagesRequest::set_signed_public_key(const void* value, size_t size) {
  _set_bit(3);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  signed_public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetBPMessagesRequest::mutable_signed_public_key() {
  _set_bit(3);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  return signed_public_key_;
}

// required bytes signed_request = 5;
inline bool GetBPMessagesRequest::has_signed_request() const {
  return _has_bit(4);
}
inline void GetBPMessagesRequest::clear_signed_request() {
  if (signed_request_ != &_default_signed_request_) {
    signed_request_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& GetBPMessagesRequest::signed_request() const {
  return *signed_request_;
}
inline void GetBPMessagesRequest::set_signed_request(const ::std::string& value) {
  _set_bit(4);
  if (signed_request_ == &_default_signed_request_) {
    signed_request_ = new ::std::string;
  }
  signed_request_->assign(value);
}
inline void GetBPMessagesRequest::set_signed_request(const char* value) {
  _set_bit(4);
  if (signed_request_ == &_default_signed_request_) {
    signed_request_ = new ::std::string;
  }
  signed_request_->assign(value);
}
inline void GetBPMessagesRequest::set_signed_request(const void* value, size_t size) {
  _set_bit(4);
  if (signed_request_ == &_default_signed_request_) {
    signed_request_ = new ::std::string;
  }
  signed_request_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetBPMessagesRequest::mutable_signed_request() {
  _set_bit(4);
  if (signed_request_ == &_default_signed_request_) {
    signed_request_ = new ::std::string;
  }
  return signed_request_;
}

// -------------------------------------------------------------------

// GetBPMessagesResponse

// required uint32 result = 1;
inline bool GetBPMessagesResponse::has_result() const {
  return _has_bit(0);
}
inline void GetBPMessagesResponse::clear_result() {
  result_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 GetBPMessagesResponse::result() const {
  return result_;
}
inline void GetBPMessagesResponse::set_result(::google::protobuf::uint32 value) {
  _set_bit(0);
  result_ = value;
}

// repeated bytes messages = 2;
inline int GetBPMessagesResponse::messages_size() const {
  return messages_.size();
}
inline void GetBPMessagesResponse::clear_messages() {
  messages_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GetBPMessagesResponse::messages() const {
  return messages_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GetBPMessagesResponse::mutable_messages() {
  return &messages_;
}
inline const ::std::string& GetBPMessagesResponse::messages(int index) const {
  return messages_.Get(index);
}
inline ::std::string* GetBPMessagesResponse::mutable_messages(int index) {
  return messages_.Mutable(index);
}
inline void GetBPMessagesResponse::set_messages(int index, const ::std::string& value) {
  messages_.Mutable(index)->assign(value);
}
inline void GetBPMessagesResponse::set_messages(int index, const char* value) {
  messages_.Mutable(index)->assign(value);
}
inline void GetBPMessagesResponse::set_messages(int index, const void* value, size_t size) {
  messages_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetBPMessagesResponse::add_messages() {
  return messages_.Add();
}
inline void GetBPMessagesResponse::add_messages(const ::std::string& value) {
  messages_.Add()->assign(value);
}
inline void GetBPMessagesResponse::add_messages(const char* value) {
  messages_.Add()->assign(value);
}
inline void GetBPMessagesResponse::add_messages(const void* value, size_t size) {
  messages_.Add()->assign(reinterpret_cast<const char*>(value), size);
}

// optional bytes pmid_id = 3;
inline bool GetBPMessagesResponse::has_pmid_id() const {
  return _has_bit(2);
}
inline void GetBPMessagesResponse::clear_pmid_id() {
  if (pmid_id_ != &_default_pmid_id_) {
    pmid_id_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& GetBPMessagesResponse::pmid_id() const {
  return *pmid_id_;
}
inline void GetBPMessagesResponse::set_pmid_id(const ::std::string& value) {
  _set_bit(2);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  pmid_id_->assign(value);
}
inline void GetBPMessagesResponse::set_pmid_id(const char* value) {
  _set_bit(2);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  pmid_id_->assign(value);
}
inline void GetBPMessagesResponse::set_pmid_id(const void* value, size_t size) {
  _set_bit(2);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  pmid_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetBPMessagesResponse::mutable_pmid_id() {
  _set_bit(2);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  return pmid_id_;
}

// optional bytes public_key = 4;
inline bool GetBPMessagesResponse::has_public_key() const {
  return _has_bit(3);
}
inline void GetBPMessagesResponse::clear_public_key() {
  if (public_key_ != &_default_public_key_) {
    public_key_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& GetBPMessagesResponse::public_key() const {
  return *public_key_;
}
inline void GetBPMessagesResponse::set_public_key(const ::std::string& value) {
  _set_bit(3);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void GetBPMessagesResponse::set_public_key(const char* value) {
  _set_bit(3);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void GetBPMessagesResponse::set_public_key(const void* value, size_t size) {
  _set_bit(3);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetBPMessagesResponse::mutable_public_key() {
  _set_bit(3);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  return public_key_;
}

// optional bytes signed_public_key = 5;
inline bool GetBPMessagesResponse::has_signed_public_key() const {
  return _has_bit(4);
}
inline void GetBPMessagesResponse::clear_signed_public_key() {
  if (signed_public_key_ != &_default_signed_public_key_) {
    signed_public_key_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& GetBPMessagesResponse::signed_public_key() const {
  return *signed_public_key_;
}
inline void GetBPMessagesResponse::set_signed_public_key(const ::std::string& value) {
  _set_bit(4);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  signed_public_key_->assign(value);
}
inline void GetBPMessagesResponse::set_signed_public_key(const char* value) {
  _set_bit(4);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  signed_public_key_->assign(value);
}
inline void GetBPMessagesResponse::set_signed_public_key(const void* value, size_t size) {
  _set_bit(4);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  signed_public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetBPMessagesResponse::mutable_signed_public_key() {
  _set_bit(4);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  return signed_public_key_;
}

// -------------------------------------------------------------------

// AddBPMessageRequest

// required bytes bufferpacket_name = 1;
inline bool AddBPMessageRequest::has_bufferpacket_name() const {
  return _has_bit(0);
}
inline void AddBPMessageRequest::clear_bufferpacket_name() {
  if (bufferpacket_name_ != &_default_bufferpacket_name_) {
    bufferpacket_name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& AddBPMessageRequest::bufferpacket_name() const {
  return *bufferpacket_name_;
}
inline void AddBPMessageRequest::set_bufferpacket_name(const ::std::string& value) {
  _set_bit(0);
  if (bufferpacket_name_ == &_default_bufferpacket_name_) {
    bufferpacket_name_ = new ::std::string;
  }
  bufferpacket_name_->assign(value);
}
inline void AddBPMessageRequest::set_bufferpacket_name(const char* value) {
  _set_bit(0);
  if (bufferpacket_name_ == &_default_bufferpacket_name_) {
    bufferpacket_name_ = new ::std::string;
  }
  bufferpacket_name_->assign(value);
}
inline void AddBPMessageRequest::set_bufferpacket_name(const void* value, size_t size) {
  _set_bit(0);
  if (bufferpacket_name_ == &_default_bufferpacket_name_) {
    bufferpacket_name_ = new ::std::string;
  }
  bufferpacket_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AddBPMessageRequest::mutable_bufferpacket_name() {
  _set_bit(0);
  if (bufferpacket_name_ == &_default_bufferpacket_name_) {
    bufferpacket_name_ = new ::std::string;
  }
  return bufferpacket_name_;
}

// required bytes data = 2;
inline bool AddBPMessageRequest::has_data() const {
  return _has_bit(1);
}
inline void AddBPMessageRequest::clear_data() {
  if (data_ != &_default_data_) {
    data_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& AddBPMessageRequest::data() const {
  return *data_;
}
inline void AddBPMessageRequest::set_data(const ::std::string& value) {
  _set_bit(1);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void AddBPMessageRequest::set_data(const char* value) {
  _set_bit(1);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void AddBPMessageRequest::set_data(const void* value, size_t size) {
  _set_bit(1);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AddBPMessageRequest::mutable_data() {
  _set_bit(1);
  if (data_ == &_default_data_) {
    data_ = new ::std::string;
  }
  return data_;
}

// required bytes pmid = 3;
inline bool AddBPMessageRequest::has_pmid() const {
  return _has_bit(2);
}
inline void AddBPMessageRequest::clear_pmid() {
  if (pmid_ != &_default_pmid_) {
    pmid_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& AddBPMessageRequest::pmid() const {
  return *pmid_;
}
inline void AddBPMessageRequest::set_pmid(const ::std::string& value) {
  _set_bit(2);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(value);
}
inline void AddBPMessageRequest::set_pmid(const char* value) {
  _set_bit(2);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(value);
}
inline void AddBPMessageRequest::set_pmid(const void* value, size_t size) {
  _set_bit(2);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  pmid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AddBPMessageRequest::mutable_pmid() {
  _set_bit(2);
  if (pmid_ == &_default_pmid_) {
    pmid_ = new ::std::string;
  }
  return pmid_;
}

// required bytes public_key = 4;
inline bool AddBPMessageRequest::has_public_key() const {
  return _has_bit(3);
}
inline void AddBPMessageRequest::clear_public_key() {
  if (public_key_ != &_default_public_key_) {
    public_key_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& AddBPMessageRequest::public_key() const {
  return *public_key_;
}
inline void AddBPMessageRequest::set_public_key(const ::std::string& value) {
  _set_bit(3);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void AddBPMessageRequest::set_public_key(const char* value) {
  _set_bit(3);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void AddBPMessageRequest::set_public_key(const void* value, size_t size) {
  _set_bit(3);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AddBPMessageRequest::mutable_public_key() {
  _set_bit(3);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  return public_key_;
}

// required bytes signed_public_key = 5;
inline bool AddBPMessageRequest::has_signed_public_key() const {
  return _has_bit(4);
}
inline void AddBPMessageRequest::clear_signed_public_key() {
  if (signed_public_key_ != &_default_signed_public_key_) {
    signed_public_key_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& AddBPMessageRequest::signed_public_key() const {
  return *signed_public_key_;
}
inline void AddBPMessageRequest::set_signed_public_key(const ::std::string& value) {
  _set_bit(4);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  signed_public_key_->assign(value);
}
inline void AddBPMessageRequest::set_signed_public_key(const char* value) {
  _set_bit(4);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  signed_public_key_->assign(value);
}
inline void AddBPMessageRequest::set_signed_public_key(const void* value, size_t size) {
  _set_bit(4);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  signed_public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AddBPMessageRequest::mutable_signed_public_key() {
  _set_bit(4);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  return signed_public_key_;
}

// required bytes signed_request = 6;
inline bool AddBPMessageRequest::has_signed_request() const {
  return _has_bit(5);
}
inline void AddBPMessageRequest::clear_signed_request() {
  if (signed_request_ != &_default_signed_request_) {
    signed_request_->clear();
  }
  _clear_bit(5);
}
inline const ::std::string& AddBPMessageRequest::signed_request() const {
  return *signed_request_;
}
inline void AddBPMessageRequest::set_signed_request(const ::std::string& value) {
  _set_bit(5);
  if (signed_request_ == &_default_signed_request_) {
    signed_request_ = new ::std::string;
  }
  signed_request_->assign(value);
}
inline void AddBPMessageRequest::set_signed_request(const char* value) {
  _set_bit(5);
  if (signed_request_ == &_default_signed_request_) {
    signed_request_ = new ::std::string;
  }
  signed_request_->assign(value);
}
inline void AddBPMessageRequest::set_signed_request(const void* value, size_t size) {
  _set_bit(5);
  if (signed_request_ == &_default_signed_request_) {
    signed_request_ = new ::std::string;
  }
  signed_request_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AddBPMessageRequest::mutable_signed_request() {
  _set_bit(5);
  if (signed_request_ == &_default_signed_request_) {
    signed_request_ = new ::std::string;
  }
  return signed_request_;
}

// -------------------------------------------------------------------

// AddBPMessageResponse

// required uint32 result = 1;
inline bool AddBPMessageResponse::has_result() const {
  return _has_bit(0);
}
inline void AddBPMessageResponse::clear_result() {
  result_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 AddBPMessageResponse::result() const {
  return result_;
}
inline void AddBPMessageResponse::set_result(::google::protobuf::uint32 value) {
  _set_bit(0);
  result_ = value;
}

// optional bytes pmid_id = 2;
inline bool AddBPMessageResponse::has_pmid_id() const {
  return _has_bit(1);
}
inline void AddBPMessageResponse::clear_pmid_id() {
  if (pmid_id_ != &_default_pmid_id_) {
    pmid_id_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& AddBPMessageResponse::pmid_id() const {
  return *pmid_id_;
}
inline void AddBPMessageResponse::set_pmid_id(const ::std::string& value) {
  _set_bit(1);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  pmid_id_->assign(value);
}
inline void AddBPMessageResponse::set_pmid_id(const char* value) {
  _set_bit(1);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  pmid_id_->assign(value);
}
inline void AddBPMessageResponse::set_pmid_id(const void* value, size_t size) {
  _set_bit(1);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  pmid_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AddBPMessageResponse::mutable_pmid_id() {
  _set_bit(1);
  if (pmid_id_ == &_default_pmid_id_) {
    pmid_id_ = new ::std::string;
  }
  return pmid_id_;
}

// optional bytes public_key = 3;
inline bool AddBPMessageResponse::has_public_key() const {
  return _has_bit(2);
}
inline void AddBPMessageResponse::clear_public_key() {
  if (public_key_ != &_default_public_key_) {
    public_key_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& AddBPMessageResponse::public_key() const {
  return *public_key_;
}
inline void AddBPMessageResponse::set_public_key(const ::std::string& value) {
  _set_bit(2);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void AddBPMessageResponse::set_public_key(const char* value) {
  _set_bit(2);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(value);
}
inline void AddBPMessageResponse::set_public_key(const void* value, size_t size) {
  _set_bit(2);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AddBPMessageResponse::mutable_public_key() {
  _set_bit(2);
  if (public_key_ == &_default_public_key_) {
    public_key_ = new ::std::string;
  }
  return public_key_;
}

// optional bytes signed_public_key = 4;
inline bool AddBPMessageResponse::has_signed_public_key() const {
  return _has_bit(3);
}
inline void AddBPMessageResponse::clear_signed_public_key() {
  if (signed_public_key_ != &_default_signed_public_key_) {
    signed_public_key_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& AddBPMessageResponse::signed_public_key() const {
  return *signed_public_key_;
}
inline void AddBPMessageResponse::set_signed_public_key(const ::std::string& value) {
  _set_bit(3);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  signed_public_key_->assign(value);
}
inline void AddBPMessageResponse::set_signed_public_key(const char* value) {
  _set_bit(3);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  signed_public_key_->assign(value);
}
inline void AddBPMessageResponse::set_signed_public_key(const void* value, size_t size) {
  _set_bit(3);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  signed_public_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AddBPMessageResponse::mutable_signed_public_key() {
  _set_bit(3);
  if (signed_public_key_ == &_default_signed_public_key_) {
    signed_public_key_ = new ::std::string;
  }
  return signed_public_key_;
}


}  // namespace maidsafe
#endif  // PROTOBUF_maidsafe_5fservice_5fmessages_2eproto__INCLUDED
